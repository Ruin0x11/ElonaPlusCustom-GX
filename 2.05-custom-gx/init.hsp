#include "defines\\mod.hsp"

// Macros
#define global nullstr 

#define cfgRead(%1,%2,%3=nullstr) \
if instr(s,0,%1)!-1{	%c\
	i=0:p=0	%c\
	repeat	%c\
	p(2)=instr(s,p,"\"") : if p(2)=-1:break	%c\
	p+=p(2)	%c\
	p(1)=instr(s,p+1,"\"") : if p(1)=-1:break	%c\
	rtvaln(i)=strmid(s,p+1,p(1)):p+=strlen(rtvaln(i))+2	%c\
	i++		%c\
	loop	%c\
	%2:%3:continue}

#define global promptYesNo(%1=160,%2=1,%3=prompty) promptl(0,0)=stryes,"y","0"\
	:promptl(0,1)=strno,"n","1"\
	:promptmax=2:val=promptx,%3,%1,%2:gosub *prompt_key

#define global promptOk(%1=200,%2=1,%3=prompty) promptl(0,0)=lang("オッケー","Ok"),"y","0"\
	:promptmax=1:val=promptx,%3,%1,%2:gosub *prompt_key

#define global promptAdd(%1,%2="null",%3=promptmax) promptl(0,promptmax)=%1,%2,""+%3:promptmax++

#define global promptTagTeam(%1=200,%2=1,%3=prompty) txtselecttc 2\
			:repeat 2\
				:promptAdd s(cnt), key_select(cnt)\
			:loop\
			:val=promptx,%3,%1,%2\
			:gosub *prompt_key

#define global page_check cs_bk=-1:pagemax=(listmax-1)/pagesize:if page<0:page=pagemax:else:if page>pagemax:page=0

#define global page_change(%1,%2=SOUNDLIST_POP1)	\
	if key=key_pageup	:if pagemax!0:snd %2:page++:goto %1%c\
	if key=key_pagedown	:if pagemax!0:snd %2:page--:goto %1%c

#define setCom(%1,%2="") list(0,listmax)=listmax:listn(0,listmax)=%1,%2:listmax++

#define global txt(%1,%2="",%3="",%4="",%5="",%6="",%7="",%8="",%9="") \
	:txtvalid=0:txtc=1+(%2!"")+(%3!"")+(%4!"")+(%5!"")+(%6!"")+(%7!"")+(%8!"")+(%9!"") \
	:txtc=rnd(txtc):txt_select %1,%2,%3,%4,%5,%6,%7,%8,%9:tcol@txtfunc=255,255,255

#define chatList(%1,%2) list(0,listmax)=%1 : listn(0,listmax)=%2 : listmax++
#define chatMore(%1,%2=strmore,%3=0) listmax=0:buff=%1:tc=tc*(%3=0)+(%3!0)*%3:chatList 0,%2:chatesc=1:gosub *chat_select :if scenemode:if scene_cut=1 : goto *chat_end

#deffunc netload str netload_filename
	netrequest netload_filename
	repeat
		netexec locvar_netload_res
		if ( locvar_netload_res ) {
			break
		}
		await 50
	loop
	if ( locvar_netload_res > 0 ) {
		return
	}
	neterror locvar_netload_estr
	dialog lang("エラー:", "Error:") + locvar_netload_estr
	return

/********** ANNA CUSTOM - BEGINNING **********/

#defcfunc xy2pic int xy2pic_x, int xy2pic_y
	return (xy2pic_x \ 33) + (xy2pic_y * 33)

#include "custom_lib.hsp"
#include "custom_pet.hsp"
#include "custom_itemlist.hsp"

/********** ANNA CUSTOM - ENDING **********/

/********** RUIN0X11 CUSTOM - BEGINNING **********/

#include "custom_dmgpop.hsp"
#include "custom_autopick.hsp"

/********** RUIN0X11 CUSTOM - ENDING **********/

/********** CUSTOM NEFIA TYPES - BEGINNING **********/

#include "custom_nefiatypes.hsp"

/********** CUSTOM NEFIA TYPES - ENDING **********/

#defcfunc hantozen str hantozen_arg1, var hantozen_arg2, int hantozen_arg3
	return LCMapStringA(GetUserDefaultLCID(), 8388608, hantozen_arg1, -1, hantozen_arg2, hantozen_arg3)

#defcfunc zentohan str zentohan_arg1, var zentohan_arg2, int zentohan_arg3
	return LCMapStringA(GetUserDefaultLCID(), 4194304, zentohan_arg1, -1, zentohan_arg2, zentohan_arg3)

#deffunc tmset
	timeBeginPeriod 1
	return

#deffunc tmend
	timeEndPeriod 1
	return

#defcfunc lang str lang_jp, str lang_en
	if ( jp ) {
		return lang_jp
	}
	else {
		return lang_en
	}

#defcfunc cnvrank int cnvrank_rank
	if ( jp ) {
		return "" + cnvrank_rank
	}
	if ( cnvrank_rank \ 10 == 1 ) {
		if ( cnvrank_rank != 11 ) {
			return "" + cnvrank_rank + "st"
		}
	}
	if ( cnvrank_rank \ 10 == 2 ) {
		if ( cnvrank_rank != 12 ) {
			return "" + cnvrank_rank + "nd"
		}
	}
	if ( cnvrank_rank \ 10 == 3 ) {
		if ( cnvrank_rank != 13 ) {
			return "" + cnvrank_rank + "rd"
		}
	}
	return "" + cnvrank_rank + "th"

#defcfunc cnvtalk str cnvtalk_str
	return "\"" + cnvtalk_str + "\" "

#defcfunc cnvarticle str cnvarticle_str
	if ( jp ) {
		return cnvarticle_str
	}
	return "[" + cnvarticle_str + "]"

#defcfunc cnvitemname int cnvitemname_itemid
	if ( cnvitemname_itemid == ITEM_ID_WILD_FLOWER ) {
		return iknownnameref(cnvitemname_itemid)
	}
	if ( jp ) {
		return ioriginalnameref(cnvitemname_itemid)
	}
	if ( ioriginalnameref2(cnvitemname_itemid) == "" ) {
		return ioriginalnameref(cnvitemname_itemid)
	}
	return ioriginalnameref2(cnvitemname_itemid) + " of " + ioriginalnameref(cnvitemname_itemid)

#defcfunc cnven str cnven_str
	if ( jp ) {
		return cnven_str
	}
	locvar_cnven_s = cnven_str
	locvar_cnven_p = peek(locvar_cnven_s, 0)
	if ( locvar_cnven_p == 42 ) {
		locvar_cnven_p = peek(locvar_cnven_s, 1)
		if ( locvar_cnven_p >= 97 ) {
			if ( locvar_cnven_p <= 122 ) {
				poke locvar_cnven_s, 1, locvar_cnven_p - 32
			}
		}
	}
	else {
		if ( locvar_cnven_p >= 97 ) {
			if ( locvar_cnven_p <= 122 ) {
				poke locvar_cnven_s, 0, locvar_cnven_p - 32
			}
		}
	}
	return locvar_cnven_s

#defcfunc cbit int cbit_bit, int cbit_charid
	HMMBITCHECK cdata(STARTING_CDATA_CHARA_BIT + cbit_bit / 32, cbit_charid), cbit_bit \ 32
	return abs(stat)

#deffunc cbitmod int cbitmod_bit, int cbitmod_charid, int cbitmod_seton
	if ( cbitmod_seton == 0 ) {
		HMMBITOFF cdata(STARTING_CDATA_CHARA_BIT + cbitmod_bit / 32, cbitmod_charid), cbitmod_bit \ 32
		return
	}
	HMMBITON cdata(STARTING_CDATA_CHARA_BIT + cbitmod_bit / 32, cbitmod_charid), cbitmod_bit \ 32
	return

#defcfunc refchara int refchara_dbid, int refchara_dbspec, int refchara_charid
	dbmode = DBMODE_REF_SPEC
	dbid = refchara_dbid
	dbspec = refchara_dbspec
	gosub *db_creature
	if ( refchara_charid == CHARA_PLAYER ) {
		return stat
	}
	else {
		return refstr
	}

#defcfunc refclass int refclass_dbid, int refclass_dbspec
	dbmode = DBMODE_REF_SPEC
	dbidn = cdatan(CDATAN_CLASS, refclass_dbid)
	dbspec = refclass_dbspec
	gosub *db_class
	return stat

#defcfunc refrace str refrace_dbidn, int refrace_dbspec
	dbmode = DBMODE_REF_SPEC
	dbidn = refrace_dbidn
	dbspec = refrace_dbspec
	gosub *db_race
	return stat

#defcfunc ranktitle int ranktitle_rank
	locvar_ranktitle_p = gdata(ranktitle_rank + 120) / 100
	if ( locvar_ranktitle_p == 1 ) {
		return rankn(0, ranktitle_rank)
	}
	if ( locvar_ranktitle_p <= 5 ) {
		return rankn(1, ranktitle_rank)
	}
	if ( locvar_ranktitle_p <= 10 ) {
		return rankn(2, ranktitle_rank)
	}
	if ( locvar_ranktitle_p <= 80 ) {
		return rankn(locvar_ranktitle_p / 15 + 3, ranktitle_rank)
	}
	return rankn(9, ranktitle_rank)

*rank_init
	sdim rankn, 30, 11, 9
	rankn(0, 0) = lang("アリーナのチャンピオン", "Arena champion"), lang("アリーナの超エリート闘士", "Super elite gladiator"), lang("アリーナのスター闘士", "Star gladiator"), lang("アリーナのエリート闘士", "Elite gladiator"), lang("アリーナの熟練闘士", "Veteran gladiator"), lang("アリーナの中堅闘士", "Popular gladiator"), lang("アリーナの期待の星", "New hope"), lang("アリーナのダークホース", "Darkhorse"), lang("アリーナの下級闘士", "Low class fighter"), lang("アリーナの無名の闘士", "Unknown fighter"), lang("アリーナ", "Arena")
	rankn(0, 1) = lang("全てのペットの王", "King of tamer"), lang("超エリートペット使い", "Super elite tamer"), lang("ペットの王子", "Prince of animals"), lang("ペットの憧れの的", "Chief of animals"), lang("ペット使いのエリート", "Elite tamer"), lang("名の知れたペット使い", "Notorious tamer"), lang("ペットの母", "New hope"), lang("なかなかのペット使い", "Average tamer"), lang("駆け出しのペット使い", "Petty tamer"), lang("無名のペット使い", "Unknown tamer"), lang("ペットアリーナ", "Pet Arena")
	rankn(0, 2) = lang("ネフィアを統べる者", "King of Nefia"), lang("迷宮の覇者", "Champion of labyrinth"), lang("ダンジョンの主", "Dungeon master"), lang("高名な探検者", "Famous adventurer"), lang("子供達の憧れの的", "Children's star"), lang("ダンジョン案内人", "Guide of Nefia"), lang("名の知れた遺跡荒らし", "Notorious tomb robber"), lang("探検者", "Tomb robber"), lang("ちんけな遺跡荒らし", "Famous tourist"), lang("観光客", "Tourist"), lang("クローラー", "Crawler")
	rankn(0, 3) = lang("ティリス最大の博物館", "Tyris' greatest museum"), lang("超有名な博物館", "Royal museum"), lang("大人気の博物館", "Great museum"), lang("有名な博物館", "Top museum"), lang("来客の絶えない博物館", "Great museum"), lang("ちょっと人気のある博物館", "Good museum"), lang("名の知れた博物館", "Average museum"), lang("まあまあの博物館", "Small museum"), lang("来客の少ない博物館", "Unknown museum"), lang("無名の博物館", "Unknown Ruin"), lang("博物館", "Museum")
	rankn(0, 4) = lang("イルヴァの楽園", "Heaven of Tyris"), lang("超セレブな家", "Royal mansion"), lang("世界有数の家", "Celebrity mansion"), lang("とても住みたくなる家", "Dream mansion"), lang("主婦の憧れの家", "Cozy mansion"), lang("ちょっと人目をひく家", "Attractive house"), lang("まあまあの家", "Average house"), lang("少しみすぼらしい家", "Poor house"), lang("貧困にあえぐ家", "Peasant's shack"), lang("乞食の家", "Beggar's shack"), lang("ホーム", "Home")
	rankn(0, 5) = lang("イルヴァ最大の店", "Tyris' greatest mall"), lang("王様が来る店", "Royal mall"), lang("大繁盛している店", "Prosperous mall"), lang("セレブが来る店", "Celebrity shop"), lang("来客の絶えない店", "Prosperous shop"), lang("マダムの来る店", "Popular shop"), lang("リピーターのいる店", "Average shop"), lang("人が増えてきた売店", "Small shop"), lang("ほとんど売れない売店", "Souvenir shop"), lang("無名の売店", "Unknown shop"), lang("店", "Shop")
	rankn(0, 6) = lang("ボス", "Boss"), lang("王様のアドバイザー", "King's advisor"), lang("エリートコンサルター", "Elite consultant"), lang("ご意見番", "Famous consultant"), lang("有権者の鑑", "Model voter"), lang("マダム好みの有権者", "Nice voter"), lang("名の知れた有権者", "Infamous voter"), lang("普通の有権者", "Average voter"), lang("無関心な有権者", "Indifferent voter"), lang("ぎりぎり有権者", "Almost voter"), lang("コミュニティ", "Community")
	rankn(0, 8) = lang("次代ギルドマスター", "Next master"), lang("ギルドマスターの右腕", "Master"), lang("ギルドの重役", "Adept"), lang("ギルドの重役候補", "Expert"), lang("アダプト", "Journeyman"), lang("エキスパート", "Senior"), lang("ジャーニーマン", "Apprentice"), lang("ギルドの正式メンバー", "Official member"), lang("ギルドのメンバー候補", "Candidate"), lang("見習い", "Thug"), lang("ギルド", "Guild")
	dim ranknorma, 9
	ranknorma(0) = 20
	ranknorma(1) = 60
	ranknorma(2) = 45
	ranknorma(6) = 30
	return

#defcfunc guildname
	locvar_guildname_s = lang("なし", "None")
	if ( gdata(GDATA_FLAG_GUILD_MAGE) != 0 ) {
		locvar_guildname_s = lang("魔術士ギルド", "Mages Guild")
	}
	if ( gdata(GDATA_FLAG_GUILD_FIGHTER) != 0 ) {
		locvar_guildname_s = lang("戦士ギルド", "Fighters Guild")
	}
	if ( gdata(GDATA_FLAG_GUILD_THIEF) != 0 ) {
		locvar_guildname_s = lang("盗賊ギルド", "Thieves Guild")
	}
	return locvar_guildname_s

*politics_init
	sdim popostname, 20, 7
	popostname(1) = lang("市長", "mayor")
	popostname(2) = lang("村長", "chief")
	popostname(3) = lang("司祭", "priest")
	popostname(4) = lang("守衛長", "guard master")
	popostname(5) = lang("徴税官", "tax master")
	popostname(6) = lang("建設主任", "head architect")
	dim pochart, 10, 10, 10
	pochart(0, 0, 0) = 2
	pochart(0, 1, 0) = 3, 4
	pochart(0, 2, 0) = 5, 6
	dim podata, 300, 20
	return

*building_init
	dim bddata, 40, 20, 10
	dim bdref, 10, 7
	sdim bdrefn, 20, 7
	bdref(0, 1) = 0, 1500
	bdref(0, 2) = 1, 2500
	bdref(0, 3) = 2, 2500
	bdref(0, 4) = 3, 2500
	bdref(0, 5) = 4, 2500
	bdref(0, 6) = 5, 2500
	bdrefn(1) = lang("炭鉱", "Mine")
	bdrefn(2) = lang("畑", "Field")
	bdrefn(3) = lang("アトリエ", "Art Atelier")
	bdrefn(4) = lang("寺院", "Temple")
	bdrefn(5) = lang("盗賊の隠れ家", "Smuggler's Hideout")
	bdrefn(6) = lang("灯台", "Light House")
	return

#include "buff.hsp"

#include "skill.hsp"

#include "trait.hsp"

#defcfunc ibit int ibit_bit, int ibit_itemid
	HMMBITCHECK inv(STARTING_INV_ITEM_BIT + ibit_bit / 32, ibit_itemid), ibit_bit \ 32
	return abs(stat)

#deffunc ibitmod int ibitmod_bit, int ibitmod_itemid, int ibitmod_seton
	if ( ibitmod_seton == 0 ) {
		HMMBITOFF inv(STARTING_INV_ITEM_BIT + ibitmod_bit / 32, ibitmod_itemid), ibitmod_bit \ 32
		return
	}
	HMMBITON inv(STARTING_INV_ITEM_BIT + ibitmod_bit / 32, ibitmod_itemid), ibitmod_bit \ 32
	return

#defcfunc refitem int refitem_dbid, int refitem_dbspec
	dbmode = DBMODE_REF_SPEC
	dbid = refitem_dbid
	dbspec = refitem_dbspec
	gosub *db_item
	return stat

#defcfunc iequiploc int iequiploc_itemid
	locvar_iequiploc_p = refitem(inv(INV_ITEM_ID, iequiploc_itemid), DBSPEC_TYPE)
	if ( locvar_iequiploc_p == FILTER_HELM ) {
		return EQUIP_SLOT_HEAD
	}
	if ( locvar_iequiploc_p == FILTER_ACCESSORY_AMULET ) {
		return EQUIP_SLOT_NECK
	}
	if ( locvar_iequiploc_p == FILTER_CLOAK ) {
		return EQUIP_SLOT_BACK
	}
	if ( locvar_iequiploc_p == FILTER_ARMOR ) {
		return EQUIP_SLOT_BODY
	}
	if ( locvar_iequiploc_p == FILTER_WEAPON ) {
		return EQUIP_SLOT_HAND
	}
	if ( locvar_iequiploc_p == FILTER_SHIELD ) {
		return EQUIP_SLOT_HAND
	}
	if ( locvar_iequiploc_p == FILTER_ACCESSORY_RING ) {
		return EQUIP_SLOT_RING
	}
	if ( locvar_iequiploc_p == FILTER_GLOVES ) {
		return EQUIP_SLOT_ARM
	}
	if ( locvar_iequiploc_p == FILTER_BOOTS ) {
		return EQUIP_SLOT_LEG
	}
	if ( locvar_iequiploc_p == FILTER_RANGE ) {
		return EQUIP_SLOT_SHOOT
	}
	if ( locvar_iequiploc_p == FILTER_AMMO ) {
		return EQUIP_SLOT_AMMO
	}
	if ( locvar_iequiploc_p == FILTER_GIRDLE ) {
		return EQUIP_SLOT_WAIST
	}
	return EQUIP_SLOT_NONE

#deffunc setunid int setunid_charid, int setunid_unid
	cdata(CDATA_USERNPC_ID, setunid_charid) = setunid_unid
	if ( cdata(CDATA_PIC, setunid_charid) < xy2pic(0, 21) | cdata(CDATA_PIC, setunid_charid) > xy2pic(31, 21) ) {
		cdata(CDATA_PIC, setunid_charid) = xy2pic(0, SPRITE_SHEET_ROWS_CHARA) + setunid_unid
		cdata(CDATA_PIC, setunid_charid) += COLOR_DEFAULT * COLOR_TINT_MULT
		cdata(CDATA_CHARA_PIC, setunid_charid) = xy2pic(1, 0)
	}
	return

#deffunc getunid int getunid_charid
	locvar_getunid_f = 0
	repeat usernpcmax
		if ( cdatan(CDATAN_USER_NPC_TAG, getunid_charid) == userdatan(0, cnt) ) {
			setunid getunid_charid, cnt
			locvar_getunid_f = 1
			break
		}
	loop
	if ( locvar_getunid_f == 0 ) {
		cdata(CDATA_PIC, getunid_charid) = COLOR_DEFAULT * COLOR_TINT_MULT + 1
		cdata(CDATA_USERNPC_ID, getunid_charid) = usernpcmax
		cdatan(CDATAN_NAME, getunid_charid) = lang("残りカス", "a garbage")
	}
	return locvar_getunid_f

#defcfunc findunid str findunid_arg1
	locvar_getunid_f = 0
	repeat usernpcmax
		if ( findunid_arg1 == userdatan(0, cnt) ) {
			locvar_getunid_f = 1 + cnt
			break
		}
	loop
	return locvar_getunid_f

#defcfunc synccheck int synccheck_arg1, int synccheck_arg2
	if ( synccheck_arg2 == (-1) ) {
		if ( cdata(CDATA_IN_TAGTEAM, synccheck_arg1) == 1 ) {
			return 1
		}
	}
	if ( synccheck_arg2 == (-1) ) {
		return cdata(CDATA_SYNC, synccheck_arg1) == msync | synccheck_arg1 == gdata(GDATA_RIDER)
	}
	if ( mapsync(synccheck_arg1, synccheck_arg2) == msync ) {
		return 1
	}
	return 0

#defcfunc evid
	if ( evnum <= 0 ) {
		return -1
	}
	return evlist(evnum - 1)

#defcfunc evfind int evfind_eventid
	locvar_evfind_f = 0
	repeat evnum
		if ( evlist(cnt) == evfind_eventid ) {
			locvar_evfind_f = 1
		}
	loop
	return locvar_evfind_f

#deffunc evadd int evadd_arg1, int evadd_arg2, int evadd_arg3
	if ( evproc ) {
		evlist(evnum) = evlist(evnum - 1)
		evdata1(evnum) = evdata1(evnum - 1)
		evdata2(evnum) = evdata2(evnum - 1)
		evlist(evnum - 1) = evadd_arg1
		evdata1(evnum - 1) = evadd_arg2
		evdata2(evnum - 1) = evadd_arg3
	}
	else {
		evlist(evnum) = evadd_arg1
		evdata1(evnum) = evadd_arg2
		evdata2(evnum) = evadd_arg3
	}
	evnum++
	return

#include "sound.hsp"

/********** ANNA CUSTOM - BEGINNING **********/

#include "custom_tweaks.hsp"

/********** ANNA CUSTOM - ENDING **********/

#deffunc key_check int key_check_arg1
	if ( ginfo(2) == 0 ) {
		objsel 0
	}
	else {
		key = ""
		objprm 0, ""
		keylog = ""
		await 100
		return
	}
	if ( msgalert == 1 ) {
		if ( cfg_alert > 1 ) {
			repeat cfg_alert
				await 10
				locvar_key_check_p = 0
				repeat 106
					if ( cnt == 32 | cnt == 13 | (cnt >= 65 & cnt <= 90) | (cnt >= 96 & cnt <= 105) ) {
						getkey locvar_key_check_a, cnt
						if ( locvar_key_check_a ) {
							locvar_key_check_p = 1
							break
						}
					}
				loop
				if ( locvar_key_check_p == 0 ) {
					break
				}
			loop
			msgalert = 0
			keylog = ""
			objprm 0, ""
		}
	}
	key = ""
	if ( keylog != "" ) {
		keylog = strmid(keylog, 0, 1)
		if ( peek(keylog, 0) == 13 ) {
			keylog = key_enter
		}
		key = keylog
		keylog = ""
		objprm 0, ""
	}
	mousel = 0
	locvar_key_check_f = 0
	key_tab = 0
	key_escape = 0
	stick locvar_key_check_p, 15
	if ( locvar_key_check_p != 0 ) {
		if ( locvar_key_check_p == 128 ) {
			if ( keywait == 0 ) {
				key = key_cancel
				key_escape = 1
			}
		}
		if ( locvar_key_check_p == 1024 ) {
			key_tab = 1
			key = key_next
		}
	}
	else {
		getkey locvar_key_check_a, 12
		if ( locvar_key_check_a ) {
			key = key_wait
			locvar_key_check_f = 1
		}
		getkey locvar_key_check_a, 45
		if ( locvar_key_check_a ) {
			key = key_get
			locvar_key_check_f = 1
		}
		getkey locvar_key_check_a, 36
		if ( locvar_key_check_a ) {
			locvar_key_check_p = 3
		}
		getkey locvar_key_check_a, 33
		if ( locvar_key_check_a ) {
			locvar_key_check_p = 6
		}
		getkey locvar_key_check_a, 35
		if ( locvar_key_check_a ) {
			locvar_key_check_p = 9
		}
		getkey locvar_key_check_a, 34
		if ( locvar_key_check_a ) {
			locvar_key_check_p = 12
		}
	}
	getkey locvar_key_check_a, 17
	if ( locvar_key_check_a ) {
		key_ctrl = 1
	}
	else {
		key_ctrl = 0
	}
	getkey locvar_key_check_a, 18
	if ( locvar_key_check_a ) {
		key_alt = 1
	}
	else {
		key_alt = 0
	}
	getkey locvar_key_check_a, 16
	if ( locvar_key_check_a ) {
		keybd_wait = 100000
		key_shift = 1
		if ( keywait != 0 ) {
			if ( locvar_key_check_a == 0 ) {
				if ( key_shift == 0 ) {
					keywait = 0
				}
			}
		}
		if ( keywait == 0 ) {
			if ( locvar_key_check_a == 1 ) {
				key = key_cancel
				keywait = 1
			}
		}
	}
	else {
		keywait = 0
		key_shift = 0
	}
	if ( cfg_joypad ) {
		locvar_key_check_j = 0
		DIGETJOYSTATE locvar_key_check_j, 0
		HMMBITCHECK locvar_key_check_j, 0
		if ( stat ) {
			locvar_key_check_p += 2
		}
		HMMBITCHECK locvar_key_check_j, 1
		if ( stat ) {
			locvar_key_check_p += 8
		}
		HMMBITCHECK locvar_key_check_j, 2
		if ( stat ) {
			locvar_key_check_p += 1
		}
		HMMBITCHECK locvar_key_check_j, 3
		if ( stat ) {
			locvar_key_check_p += 4
		}
		locvar_key_check_a = 0
		repeat 12
			HMMBITCHECK locvar_key_check_j, 4 + cnt
			if ( stat ) {
				locvar_key_check_a = 1
				if ( jkey(cnt) == key_alter ) {
					key_alt = 1
				}
				if ( jkey(cnt) == key_cancel ) {
					key_shift = 1
					if ( locvar_key_check_p != 0 ) {
						keybd_wait = 100000
					}
				}
				if ( locvar_key_check_prevjoy != cnt ) {
					key = jkey(cnt)
					locvar_key_check_prevjoy = cnt
					if ( key == key_esc ) {
						key = key_cancel
						key_escape = 1
					}
					if ( key_check_arg1 == 0 ) {
						locvar_key_check_b = 0
						if ( key == key_fire ) {
							key = key_northeast
							locvar_key_check_b = 1
						}
						if ( key == key_target ) {
							key = key_northwest
							locvar_key_check_b = 1
						}
						if ( key == key_get ) {
							key = key_northeast
							locvar_key_check_b = 1
						}
						if ( key == key_alter ) {
							key = key_northwest
							locvar_key_check_b = 1
						}
						if ( locvar_key_check_b == 0 & key != key_enter & key != key_cancel & key != key_esc ) {
							key = key_identify
						}
					}
				}
			}
		loop
		if ( locvar_key_check_a == 0 ) {
			locvar_key_check_prevjoy = -1
		}
		else {
			if ( key_check_arg1 == 2 ) {
				return
			}
		}
	}
	if ( quickkeywait ) {
		if ( locvar_key_check_p != 0 ) {
			return
		}
		else {
			quickkeywait = 0
		}
	}
	if ( keybd_wait >= 100000 ) {
		if ( key_shift == 0 ) {
			keybd_wait = 1000
		}
	}
	if ( locvar_key_check_p == 1 ) {
		if ( key_alt == 0 ) {
			key = key_west
			locvar_key_check_f = 1
		}
	}
	if ( locvar_key_check_p == 2 ) {
		if ( key_alt == 0 ) {
			key = key_north
			locvar_key_check_f = 1
		}
	}
	if ( locvar_key_check_p == 4 ) {
		if ( key_alt == 0 ) {
			key = key_east
			locvar_key_check_f = 1
		}
	}
	if ( locvar_key_check_p == 8 ) {
		if ( key_alt == 0 ) {
			key = key_south
			locvar_key_check_f = 1
		}
	}
	if ( locvar_key_check_p == 3 ) {
		key = key_northwest
		locvar_key_check_f = 1
	}
	if ( locvar_key_check_p == 6 ) {
		key = key_northeast
		locvar_key_check_f = 1
	}
	if ( locvar_key_check_p == 9 ) {
		key = key_southwest
		locvar_key_check_f = 1
	}
	if ( locvar_key_check_p == 12 ) {
		key = key_southeast
		locvar_key_check_f = 1
	}
	if ( key_check_arg1 == 2 ) {
		return
	}
	if ( locvar_key_check_f ) {
		if ( locvar_key_check_keyactive != key ) {
			locvar_key_check_keyactive = key
		}
		if ( keybd_wait == 0 ) {
			locvar_key_check_keyactive = key
		}
		if ( key_check_arg1 == 1 ) {
			if ( keybd_attacking != 0 ) {
				if ( keybd_wait \ cfg_attackwait != 0 ) {
					key = ""
				}
			}
			else {
				if ( cfg_scroll == 0 ) {
					if ( keybd_wait < cfg_walkwait * cfg_startrun ) {
						if ( keybd_wait \ cfg_walkwait != 0 ) {
							key = ""
						}
					}
					else {
						running = 1
						if ( keybd_wait < 100000 ) {
							if ( keybd_wait \ cfg_runwait != 0 ) {
								key = ""
							}
						}
					}
				}
				else {
					if ( locvar_key_check_p == 0 ) {
						if ( keybd_wait < 10 ) {
							if ( keybd_wait != 0 ) {
								key = ""
							}
						}
					}
					else {
						if ( keybd_wait > cfg_startrun ) {
							if ( cfg_runscroll == 0 ) {
								if ( keybd_wait \ cfg_runwait != 0 ) {
									key = ""
								}
							}
							running = 1
						}
					}
				}
			}
		}
		else {
			if ( keybd_wait < 14 ) {
				if ( keybd_wait != 0 & keybd_wait != 7 ) {
					key = ""
				}
			}
			else {
				if ( keybd_wait < 1000 ) {
					if ( keybd_wait \ 2 != 1 ) {
						key = ""
					}
				}
			}
		}
		keybd_wait++
	}
	else {
		keybd_wait = 0
		keybd_attacking = 0
		running = 0
		locvar_key_check_keyactive = ""
	}
	repeat 10, 48
		getkey locvar_key_check_p, cnt
		if ( locvar_key_check_p ) {
			locvar_key_check_p = (cnt - 48) \ 10
			key = "sc"
			sc = cnt - 48 + (key_shift == 1 | key_ctrl == 1) * 10
			keybd_event cnt, 0, 2
			locvar_key_check_scon = 1
		}
	loop
	if ( locvar_key_check_scon ) {
		key = "sc"
		locvar_key_check_scon = 0
		keylog = ""
		objprm 0, ""
		return
	}
	if ( keyhalt != 0 ) {
		if ( key != "" | keybd_wait != 0 ) {
			key = ""
		}
		else {
			keyhalt = 0
		}
	}
	return

#deffunc keyrelease
	repeat
		await 30
		stick locvar_keyrelease_a, 768
		if ( locvar_keyrelease_a == 0 ) {
			key_check
			if ( key == "" ) {
				break
			}
		}
	loop
	return

#deffunc press int press_arg1
	repeat
		await 20
		key_check
		if ( press_arg1 == 0 ) {
			if ( key != "" ) {
				break
			}
		}
		if ( press_arg1 == 1 ) {
			if ( key == key_enter | key == key_cancel ) {
				break
			}
		}
	loop
	keyhalt = 1
	return

#deffunc bmes str bmes_arg1, int bmes_arg2, int bmes_arg3, int bmes_arg4
	; use the DPI-scaled positions
	locvar_bmes_pos_x = ginfo(22)
	locvar_bmes_pos_y = ginfo(23)
	locvar_bmes_mes_color = bmes_arg2, bmes_arg3, bmes_arg4
	repeat 3
		locvar_bmes_mes_y = cnt + locvar_bmes_pos_y - 1
		repeat 3
			pos@HSP locvar_bmes_pos_x - 1 + cnt, locvar_bmes_mes_y
#ifdef CUSTOM_GX_MOCK
			mes bmes_arg1
#else
			mes@HSP bmes_arg1
#endif
		loop
	loop
	color locvar_bmes_mes_color(0), locvar_bmes_mes_color(1), locvar_bmes_mes_color(2)
	pos@HSP locvar_bmes_pos_x, locvar_bmes_pos_y
#ifdef CUSTOM_GX_MOCK
	mes bmes_arg1
#else
	mes@HSP bmes_arg1
#endif
	return

#deffunc talk_conv var talk_conv_arg1, int talk_conv_arg2
	n@txtfunc = 0
	if ( jp ) {
		msgtemp@txtfunc = talk_conv_arg1
		talk_conv_arg1 = ""
		repeat 100
			len@txtfunc = strlen(msgtemp@txtfunc)
			p2@txtfunc = 0
			if ( len@txtfunc < talk_conv_arg2 ) {
				break
			}
			repeat len@txtfunc
				p@txtfunc = peek(msgtemp@txtfunc, p2@txtfunc)
				if ( p2@txtfunc > len@txtfunc ) {
					break
				}
				if ( p@txtfunc >= 129 & p@txtfunc <= 159 | p@txtfunc >= 224 & p@txtfunc <= 252 ) {
					p@txtfunc = 2
				}
				else {
					p@txtfunc = 1
				}
				p2@txtfunc += p@txtfunc
				if ( p2@txtfunc > talk_conv_arg2 ) {
					m@txtfunc = strmid(msgtemp@txtfunc, p2@txtfunc, 2)
					if ( m@txtfunc == "。" | m@txtfunc == "、" | m@txtfunc == "」" | m@txtfunc == "』" | m@txtfunc == "！" | m@txtfunc == "？" | m@txtfunc == "…" ) {
						p2@txtfunc += 2
					}
					talk_conv_arg1 += strmid(msgtemp@txtfunc, 0, p2@txtfunc) + "\n"
					n@txtfunc++
					msgtemp@txtfunc = strmid(msgtemp@txtfunc, p2@txtfunc, len@txtfunc - p2@txtfunc)
					break
				}
			loop
		loop
		talk_conv_arg1 += msgtemp@txtfunc
	}
	else {
		msgtemp@txtfunc = talk_conv_arg1
		talk_conv_arg1 = ""
		repeat 1000
			len@txtfunc = 0
			repeat 1000
				p@txtfunc = instr(msgtemp@txtfunc, 0, " ") + 1
				if ( p@txtfunc == 0 ) {
					break
				}

				/********** ANNA CUSTOM - BEGINNING **********/ // Fix linebreak when text contains newlines

				if ( instr(msgtemp@txtfunc, 0, "\n") != (-1) & scenemode == 0 ) {
					break
				}

				/********** ANNA CUSTOM - ENDING **********/

				if ( len@txtfunc + p@txtfunc > talk_conv_arg2 ) {
					talk_conv_arg1 += "\n"
					n@txtfunc++
					break
				}
				talk_conv_arg1 += strmid(msgtemp@txtfunc, 0, p@txtfunc)
				len@txtfunc += p@txtfunc
				msgtemp@txtfunc = strmid(msgtemp@txtfunc, p@txtfunc, strlen(msgtemp@txtfunc) - p@txtfunc)
			loop
			if ( p@txtfunc == 0 ) {
				break
			}
		loop
		talk_conv_arg1 += msgtemp@txtfunc
	}
	return n@txtfunc

#deffunc msg_write var msg_write_arg1
	repeat 1
		mp@txtfunc = instr(msg_write_arg1, 0, "♪")
		if ( mp@txtfunc != (-1) ) {
			mark@txtfunc = int(strmid(msg_write_arg1, mp@txtfunc + 2, 1))
			if ( jp ) {
				if ( mark@txtfunc == 0 ) {
					break
				}
			}
			msg_write_arg1 = strmid(msg_write_arg1, 0, mp@txtfunc) + "  " + strmid(msg_write_arg1, mp@txtfunc + 2 + (mark@txtfunc != 0), 9999)
			pos (msglen + mp@txtfunc) * inf_mesfont / 2 + inf_msgx + 7 + en * 3, (inf_msgline - 1) * inf_msgspace + inf_msgy + 5
			gmode 2
			gcopy 3, 600 + mark@txtfunc * 24, 360, 16, 16
			continue cnt
		}
	loop
	color tcol@txtfunc(0), tcol@txtfunc(1), tcol@txtfunc(2)
	pos msglen * inf_mesfont / 2 + inf_msgx + 6, (inf_msgline - 1) * inf_msgspace + inf_msgy + 6
	font lang(cfg_font1, cfg_font2), inf_mesfont - en * 2, 0
	mes msg_write_arg1
	return

#deffunc txtmore
	tmore@txtfunc = 1
	return

#deffunc txtcontinue
	tcontinue@txtfunc = 1
	return

#deffunc anime_halt
	key = ""
	objprm 0, ""
	keylog = ""
	redraw 0
	gmode 0
	gsel 3
	pos 672, 504
	gcopy 0, x@txtfunc, y@txtfunc, 120, 24
	gsel 0
	repeat 12
		redraw 0
		await 10
		pos x@txtfunc, y@txtfunc + 12 - cnt
		gzoom 120, cnt * 2 + 1, 3, 552, 504, 120, 22
		redraw 1
	loop
	press 1
	snd SOUNDLIST_OK1
	repeat 7
		redraw 0
		await 10
		pos x@txtfunc, y@txtfunc
		gcopy 3, 672, 504, 120, 24
		if ( cnt != 6 ) {
			pos x@txtfunc, y@txtfunc + cnt * 2
			gzoom 120, 22 - cnt * 4, 3, 552, 504, 120, 22
		}
		redraw 1
	loop
	redraw 0
	gmode 2
	return

#deffunc msg_halt
	x@txtfunc = windoww - 120
	y@txtfunc = windowh - 22
	anime_halt
	screenupdate = -1
	gosub *screen_draw
	return

#deffunc help_halt
	x@txtfunc = wx + dx - 140
	y@txtfunc = wy + dy - 1
	anime_halt
	return

#deffunc txtef int txtef_color
	tcol@txtfunc = 255 - c_col(0, txtef_color), 255 - c_col(1, txtef_color), 255 - c_col(2, txtef_color)
	if ( txtef_color == COLOR_YELLOW ) {
		tcolfix@txtfunc = 1
	}
	else {
		tcolfix@txtfunc = 0
	}
	return

#deffunc msg_newlog
	if ( cfg_exlog == 0 ) {
		return
	}
	gsel 8
	gmode 0
	pos 0, msgline \ inf_maxlog * inf_msgspace
	gcopy 0, inf_msgx, inf_msgy + 5 + inf_msgspace * 3 + en * 3, windoww - inf_msgx, inf_msgspace
	gsel 0
	return

#deffunc msg_newline
	msg_newlog
	msglen = 0
	msgline++
	if ( msgline >= inf_maxlog ) {
		msgline -= inf_maxlog
	}
	msg(msgline \ inf_maxlog) = ""
	p@txtfunc = (windoww - inf_msgx) / 192
	redraw 0
	gmode 0
	pos inf_msgx, inf_msgy + 5
	gcopy 0, inf_msgx, inf_msgy + 5 + inf_msgspace, windoww - inf_msgx, inf_msgspace * 3 + en * 3
	repeat p@txtfunc + 1
		if ( cnt == p@txtfunc ) {
			x@txtfunc = (windoww - inf_msgx) \ 192
		}
		else {
			x@txtfunc = 192
		}
		pos cnt * 192 + inf_msgx, inf_msgy + 5 + inf_msgspace * 3 + en * 2
		gcopy 3, 496, 536 + msgline \ 4 * inf_msgspace, x@txtfunc, inf_msgspace
	loop
	gmode 2
	msgtempprev = ""
	return

#deffunc txtnew
	if ( tnew == 0 ) {
		if ( strlen(msg(msgline \ inf_maxlog)) > 4 ) {
			msg_newline
			msglen = 2
		}
	}
	return

#deffunc msg_clear
	msg_len = 0
	msgtemp = ""
	repeat 3
		msg_newline
	loop
	return

#deffunc txt_conv
	redraw 0
	if ( msgtemp == "" ) {
		return
	}
#ifdef CUSTOM_GX_MOCK
	logmes "[txt] " + msgtemp
	return
#endif
	if ( tcopy ) {
		tcopy = 0
		txtcopy = "" + msgtemp
	}
	if ( tnew == 1 ) {
		if ( msg(msgline \ inf_maxlog) != "" ) {
			if ( cfg_msgtrans ) {
				p@txtfunc = (windoww - inf_msgx) / 192
				redraw 0
				gmode 4, , , cfg_msgtrans * 20
				repeat p@txtfunc + 1
					if ( cnt == p@txtfunc ) {
						x@txtfunc = (windoww - inf_msgx) \ 192
					}
					else {
						x@txtfunc = 192
					}
					pos cnt * 192 + inf_msgx, inf_msgy + 5
					gcopy 3, 496, 536, x@txtfunc, inf_msgspace * 4
				loop
			}
			msg_newline
			tnew = 0
			if ( cfg_msgaddtime ) {
				msgtemp = "[" + gdata(GDATA_MIN) + "] " + msgtemp
			}
			else {
				msglen = 2
			}
		}
	}
	if ( msgdup != 0 ) {
		if ( msgtempprev == msgtemp ) {
			return
		}
		msgtempprev = msgtemp
		msgdup = 0
	}
	if ( jp ) {
		if ( instr(msgtemp, 0, "「") != (-1) ) {
			if ( tcolfix@txtfunc == 0 ) {
				tcol@txtfunc = 210, 250, 160
			}
			else {
				tcolfix@txtfunc = 0
			}
		}
		repeat
			len@txtfunc = strlen(msgtemp)
			if ( msglen + 4 > inf_maxmsglen ) {
				if ( msgtemp != "" ) {
					msg_newline
				}
			}
			if ( msglen + len@txtfunc > inf_maxmsglen ) {
				p2@txtfunc = 0
				repeat
					p@txtfunc = peek(msgtemp, p2@txtfunc)
					p2@txtfunc++
					if ( p@txtfunc > 128 & p@txtfunc < 160 ) {
						p2@txtfunc++
					}
					if ( p@txtfunc > 223 & p@txtfunc < 253 ) {
						p2@txtfunc++
					}
					if ( p2@txtfunc + msglen > inf_maxmsglen ) {
						if ( p2@txtfunc + msglen > inf_maxmsglen + 2 ) {
							break
						}
						m@txtfunc = strmid(msgtemp, p2@txtfunc, 2)
						if ( m@txtfunc != "。" & m@txtfunc != "、" & m@txtfunc != "」" & m@txtfunc != "』" & m@txtfunc != "！" & m@txtfunc != "？" & m@txtfunc != "…" ) {
							break
						}
					}
				loop
				m@txtfunc = strmid(msgtemp, 0, p2@txtfunc)
				msg(msgline \ inf_maxlog) += m@txtfunc
				msg_write m@txtfunc
				msgtemp = strmid(msgtemp, p2@txtfunc, len@txtfunc - p2@txtfunc)
				if ( msgtemp == "" | msgtemp == " " ) {
					break
				}
				msg_newline
				continue
			}
			break
		loop
		msg(msgline \ inf_maxlog) += msgtemp
		msg_write msgtemp
		msglen += len@txtfunc
	}
	else {
		if ( tcontinue@txtfunc == 0 ) {
			b@txtfunc = peek(msgtemp, 0)
			if ( instr(msgtemp, 0, "\"") != (-1) ) {
				if ( tcolfix@txtfunc == 0 ) {
					tcol@txtfunc = 210, 250, 160
				}
				else {
					tcolfix@txtfunc = 0
				}
			}
			if ( b@txtfunc >= 97 & b@txtfunc <= 122 ) {
				poke msgtemp, 0, b@txtfunc - 32
			}
		}
		else {
			tcontinue@txtfunc = 0
		}
		msgtemp += " "
		repeat
			await
			p@txtfunc = instr(msgtemp, 0, " ") + 1
			if ( p@txtfunc == 0 ) {
				break
			}
			if ( msglen + p@txtfunc > inf_maxmsglen ) {
				if ( p@txtfunc > inf_maxmsglen ) {
					msg_newline
					p@txtfunc = inf_maxmsglen
					mst@txtfunc = strmid(msgtemp, 0, p@txtfunc)
					msg(msgline \ inf_maxlog) += mst@txtfunc
					msg_write mst@txtfunc
					msglen += p@txtfunc
					msgtemp = strmid(msgtemp, p@txtfunc, strlen(msgtemp) - p@txtfunc)
					continue
				}
				msg_newline
				continue
			}
			mst@txtfunc = strmid(msgtemp, 0, p@txtfunc)
			msg(msgline \ inf_maxlog) += mst@txtfunc
			msg_write mst@txtfunc
			msglen += p@txtfunc
			msgtemp = strmid(msgtemp, p@txtfunc, strlen(msgtemp) - p@txtfunc)
		loop
		msg(msgline \ inf_maxlog) += msgtemp
		msg_write msgtemp
		msglen += strlen(msgtemp)
	}
	return

#defcfunc name int name_arg1
	if ( name_arg1 == CHARA_PLAYER ) {
		if ( gdata(GDATA_TEMPORARY_FLAGS) == 7777 ) {
			return cdatan(CDATAN_NAME, CHARA_PLAYER)
		}
		return lang("あなた", "you")
	}
	if ( synccheck(name_arg1, -1) == 0 ) {
		return lang("何か", "something")
	}
	if ( cdata(CDATA_CONDITION_BLIND, CHARA_PLAYER) != 0 | (cbit(CHARA_BIT_INVISIBLE, name_arg1) == 1 & cbit(CHARA_BIT_SEE_INVISIBLE, CHARA_PLAYER) == 0 & cdata(CDATA_CONDITION_WET, name_arg1) == 0) ) {
		return lang("何か", "something")
	}
	if ( en ) {
		locvar_name_s = strmid(cdatan(CDATAN_NAME, name_arg1), 0, 1)
		if ( locvar_name_s == "\"" | locvar_name_s == "<" ) {
			return cdatan(CDATAN_NAME, name_arg1)
		}
		if ( cbit(CHARA_BIT_HAS_NAME, name_arg1) == 0 ) {
			return "the " + cdatan(CDATAN_NAME, name_arg1)
		}
	}
	return cdatan(CDATAN_NAME, name_arg1)

#defcfunc aln int aln_charid
	if ( aln_charid == CHARA_PLAYER ) {
		return ""
	}
	if ( synccheck(aln_charid, -1) == 0 ) {
		return "それは"
	}
	return "" + cdatan(CDATAN_NAME, aln_charid) + "は"

#defcfunc npcn int npcn_charid
	if ( npcn_charid == CHARA_PLAYER ) {
		return ""
	}
	if ( synccheck(npcn_charid, -1) == 0 ) {
		return "それは"
	}
	return "" + cdatan(CDATAN_NAME, npcn_charid) + "は"

#defcfunc _s int _s_charid, int _s_arg2
	if ( _s_charid < CHARA_PLAYER | _s_charid >= MAX_CHARA_TOTAL ) {
		if ( _s_arg2 ) {
			return "es"
		}
		else {
			return "s"
		}
	}
	if ( _s_charid == CHARA_PLAYER ) {
		return ""
	}
	if ( _s_arg2 ) {
		return "es"
	}
	else {
		return "s"
	}

#defcfunc _s2 int _s2_arg1
	if ( _s2_arg1 > 1 ) {
		return ""
	}
	else {
		return "s"
	}

#defcfunc is2 int is2_arg1
	if ( is2_arg1 > 1 ) {
		return "are"
	}
	else {
		return "is"
	}

#defcfunc is int is_charid
	if ( is_charid < CHARA_PLAYER | is_charid >= MAX_CHARA_TOTAL ) {
		return "is"
	}
	if ( is_charid == CHARA_PLAYER ) {
		return "are"
	}
	return "is"

#defcfunc was int was_charid
	if ( was_charid < CHARA_PLAYER | was_charid >= MAX_CHARA_TOTAL ) {
		return "was"
	}
	if ( was_charid == CHARA_PLAYER ) {
		return "were"
	}
	return "was"

#defcfunc have int have_charid
	if ( have_charid < CHARA_PLAYER | have_charid >= MAX_CHARA_TOTAL ) {
		return "has"
	}
	if ( have_charid == CHARA_PLAYER ) {
		return "have"
	}
	return "has"

#defcfunc does int does_arg1
	if ( does_arg1 == 1 ) {
		return "do"
	}
	else {
		return "does"
	}

#defcfunc he int he_charid, int he_arg2
	if ( he_arg2 ) {
		if ( cdatan(CDATAN_NEWSEX, he_charid) == lang("男性", "male") | cdatan(CDATAN_NEWSEX, he_charid) == lang("なし", "none") ) {
			return lang("彼", "he")
		}
		if ( cdatan(CDATAN_NEWSEX, he_charid) == lang("自称男性", "male?") | cdatan(CDATAN_NEWSEX, he_charid) == lang("自称男性", "trans-male") ) {
			return lang("彼？", "he?")
		}
		if ( cdatan(CDATAN_NEWSEX, he_charid) == lang("女性", "female") | cdatan(CDATAN_NEWSEX, he_charid) == lang("両性具有", "hermaphrodite") ) {
			return lang("彼女", "she")
		}
		if ( cdatan(CDATAN_NEWSEX, he_charid) == lang("自称女性", "female?") | cdatan(CDATAN_NEWSEX, he_charid) == lang("自称女性", "trans-female") ) {
			return lang("彼女？", "she?")
		}
		if ( cdata(CDATA_SEX, he_charid) == 0 ) {
			return lang("彼", "he")
		}
		else {
			return lang("彼女", "she")
		}
	}
	if ( he_charid < CHARA_PLAYER | he_charid >= MAX_CHARA_TOTAL ) {
		return "it"
	}
	if ( synccheck(he_charid, -1) == 0 ) {
		return "it"
	}
	if ( he_charid == CHARA_PLAYER ) {
		return "you"
	}
	if ( cdata(CDATA_SEX, he_charid) == 0 ) {
		return "he"
	}
	return "she"

/********** ANNA/BLOODYSHADE CUSTOM - BEGINNING **********/

#defcfunc _s3 int _s3_num
	if ( _s3_num > 1 ) {
		return "s"
	}

	return ""

#defcfunc _s4 int their_item_idx
	if ( inv(INV_ITEM_NUM, their_item_idx) == 1 ) {
		return "s"
	}
	return ""

#defcfunc its int its_item_idx
	if ( inv(INV_ITEM_NUM, its_item_idx) == 1 ) {
		return "its"
	}
	return "their"

#defcfunc its2 int its_item_idx
	if ( inv(INV_ITEM_NUM, its_item_idx) == 1 ) {
		return "'s"
	}
	return "'"

#defcfunc his2 int EntityID
	if ( EntityID == CHARA_PLAYER ) {
		return "your"
	}

	return name(EntityID)

#defcfunc his3 int his3_EntityID
	his3_entity_sex = cdata(CDATA_SEX, his3_EntityID)
	his3_entity_sexadv = cdatan(CDATAN_NEWSEX, his3_EntityID)

	switch his3_entity_sexadv
		case "男性"
		case "male"
		case "なし"
		case "none"
			return "his"
			swbreak
		case "女性"
		case "female"
		case "両性具有"
		case "hermaphrodite"
			return "her"
			swbreak
		case "自称男性"
		case "male?"
		case "trans-male"
			return "his?"
			swbreak
		case "自称女性"
		case "female?"
		case "trans-female"
			return "her?"
			swbreak
		default
			swbreak
	swend

	if ( his3_entity_sex == 0 ) {
		return "his"
	}

	return "her"

#defcfunc him2 int him2_EntityID
	him2_entity_sex = cdata(CDATA_SEX, him2_EntityID)
	him2_entity_sexadv = cdatan(CDATAN_NEWSEX, him2_EntityID)

	switch him2_entity_sexadv
		case "男性"
		case "male"
		case "なし"
		case "none"
			return "him"
			swbreak
		case "女性"
		case "female"
		case "両性具有"
		case "hermaphrodite"
			return "her"
			swbreak
		case "自称男性"
		case "male?"
		case "trans-male"
			return "him?"
			swbreak
		case "自称女性"
		case "female?"
		case "trans-female"
			return "her?"
			swbreak
		default
			swbreak
	swend

	if ( him2_entity_sex == 0 ) {
		return "him"
	}

	return "her"

/********** ANNA/BLOODYSHADE CUSTOM - ENDING **********/

#defcfunc his int his_charid, int his_arg2
	if ( his_arg2 ) {
		if ( his_charid == CHARA_PLAYER ) {
			return lang("あなたの", "your")
		}
		if ( cdatan(CDATAN_NEWSEX, his_charid) == lang("男性", "male") | cdatan(CDATAN_NEWSEX, his_charid) == lang("なし", "none") ) {
			return lang("彼の", "his")
		}
		if ( cdatan(CDATAN_NEWSEX, his_charid) == lang("自称男性", "male?") | cdatan(CDATAN_NEWSEX, his_charid) == lang("自称男性", "trans-male") ) {
			return lang("彼？の", "his?")
		}
		if ( cdatan(CDATAN_NEWSEX, his_charid) == lang("女性", "female") | cdatan(CDATAN_NEWSEX, his_charid) == lang("両性具有", "hermaphrodite") ) {
			return lang("彼女の", "her")
		}
		if ( cdatan(CDATAN_NEWSEX, his_charid) == lang("自称男性", "female?") | cdatan(CDATAN_NEWSEX, his_charid) == lang("自称女性", "trans-female") ) {
			return lang("彼女？の", "her?")
		}
		if ( cdata(CDATA_SEX, his_charid) == SEX_MALE ) {
			return lang("彼の", "his")
		}
		else {
			return lang("彼女の", "her")
		}
	}
	if ( his_charid < CHARA_PLAYER | his_charid >= MAX_CHARA_TOTAL ) {
		return "its"
	}
	if ( synccheck(his_charid, -1) == 0 ) {
		return "its"
	}
	if ( his_charid == CHARA_PLAYER ) {
		return "your"
	}
	if ( cdata(CDATA_SEX, his_charid) == SEX_MALE ) {
		return "his"
	}
	return "her"

#defcfunc him int him_charid, int him_arg2
	if ( him_arg2 ) {
		if ( cdatan(CDATAN_NEWSEX, him_charid) == lang("男性", "male") | cdatan(CDATAN_NEWSEX, him_charid) == lang("なし", "none") ) {
			return lang("彼", "he")
		}
		if ( cdatan(CDATAN_NEWSEX, him_charid) == lang("自称男性", "male?") | cdatan(CDATAN_NEWSEX, him_charid) == lang("自称男性", "trans-male") ) {
			return lang("彼？", "he?")
		}
		if ( cdatan(CDATAN_NEWSEX, him_charid) == lang("女性", "female") | cdatan(CDATAN_NEWSEX, him_charid) == lang("両性具有", "hermaphrodite") ) {
			return lang("彼女", "she")
		}
		if ( cdatan(CDATAN_NEWSEX, him_charid) == lang("自称女性", "female?") | cdatan(CDATAN_NEWSEX, him_charid) == lang("自称女性", "trans-female") ) {
			return lang("彼女？", "she?")
		}
		if ( cdata(CDATA_SEX, him_charid) == 0 ) {
			return lang("彼", "him")
		}
		else {
			return lang("彼女", "her")
		}
	}
	if ( him_charid < CHARA_PLAYER | him_charid >= MAX_CHARA_TOTAL ) {
		return "it"
	}
	if ( synccheck(him_charid, -1) == 0 ) {
		return "it"
	}
	if ( him_charid == CHARA_PLAYER ) {
		return "yourself"
	}
	if ( cdata(CDATA_SEX, him_charid) == 0 ) {
		return "him"
	}
	return "her"

/********** ANNA CUSTOM - BEGINNING **********/

#defcfunc your2 int EntityID2
	if ( EntityID2 == CHARA_PLAYER ) {
		return ""
	}
	return "'s"

/********** ANNA CUSTOM - ENDING **********/

#defcfunc your int your_charid, int
	if ( your_charid < CHARA_PLAYER | your_charid >= MAX_CHARA_TOTAL ) {
		return "'s"
	}
	if ( your_charid == CHARA_PLAYER ) {
		return "r"
	}
	return "'s"

#defcfunc yourself int yourself_charid
	if ( yourself_charid < CHARA_PLAYER | yourself_charid >= MAX_CHARA_TOTAL ) {
		return "itself"
	}
	if ( synccheck(yourself_charid, -1) == 0 ) {
		return "itself"
	}
	if ( yourself_charid == CHARA_PLAYER ) {
		return "yourself"
	}
	if ( cdata(CDATA_SEX, yourself_charid) == 0 ) {
		return "himself"
	}
	return "herself"

/********** RUIN0X11 CUSTOM - BEGINNING **********/

#defcfunc gendername int gendername_charid
	if ( cdatan(CDATAN_NEWSEX, gendername_charid) == "" ) {
		if ( cdata(CDATA_SEX, gendername_charid) == SEX_MALE ) {
			return cnven(strmale)
		}
		else {
			return cnven(strfemale)
		}
	}
    else {
		if ( cdatan(CDATAN_NEWSEX, gendername_charid) == lang("なし", "none") ) {
			return lang("性別不明", "unknown")
		}
    	else {
			return cdatan(CDATAN_NEWSEX, gendername_charid)
    	}
    }

/********** RUIN0X11 CUSTOM - ENDING **********/

#deffunc txt_check int txt_check_arg1
	txtvalid = -1
	if ( txt_check_arg1 == 0 ) {
		if ( cc >= CHARA_PLAYER ) {
			if ( synccheck(cc, -1) | cc == CHARA_PLAYER ) {
				txtvalid = 0
				return
			}
		}
	}
	if ( txt_check_arg1 == 1 ) {
		if ( tc >= CHARA_PLAYER ) {
			if ( synccheck(tc, -1) | tc == CHARA_PLAYER ) {
				txtvalid = 0
				return
			}
		}
	}
	if ( txt_check_arg1 == 2 ) {
		if ( cc == CHARA_PLAYER | cdata(CDATA_RELATION, cc) == 10 ) {
			txtvalid = 0
			return
		}
	}
	if ( txt_check_arg1 == 3 ) {
		if ( cc > CHARA_PLAYER ) {
			if ( synccheck(cc, -1) ) {
				txtvalid = 0
				return
			}
		}
	}
	if ( txt_check_arg1 == 4 ) {
		if ( tc == CHARA_PLAYER ) {
			txtvalid = 0
			return
		}
	}
	if ( txt_check_arg1 == 5 ) {
		if ( tc > CHARA_PLAYER ) {
			if ( synccheck(tc, -1) ) {
				txtvalid = 0
			}
		}
	}
	return

#deffunc txt_select str txt_select_arg1, str txt_select_arg2, str txt_select_arg3, str txt_select_arg4, str txt_select_arg5, str txt_select_arg6, str txt_select_arg7, str txt_select_arg8, str txt_select_arg9
	if ( txtvalid == (-1) ) {
		txtvalid = 0
		return
	}
	if ( hear != 0 ) {
		snd hear
		hear = 0
	}
	if ( txtc == 0 ) {
		msgtemp = txt_select_arg1
		txt_conv
	}
	else {
		if ( txtc == 1 ) {
			msgtemp = txt_select_arg2
			txt_conv
		}
		else {
			if ( txtc == 2 ) {
				msgtemp = txt_select_arg3
				txt_conv
			}
			else {
				if ( txtc == 3 ) {
					msgtemp = txt_select_arg4
					txt_conv
				}
				else {
					if ( txtc == 4 ) {
						msgtemp = txt_select_arg5
						txt_conv
					}
					else {
						if ( txtc == 5 ) {
							msgtemp = txt_select_arg6
							txt_conv
						}
						else {
							if ( txtc == 6 ) {
								msgtemp = txt_select_arg7
								txt_conv
							}
							else {
								if ( txtc == 7 ) {
									msgtemp = txt_select_arg8
									txt_conv
								}
								else {
									msgtemp = txt_select_arg9
									txt_conv
								}
							}
						}
					}
				}
			}
		}
	}
	return

#defcfunc cnvfix int cnvfix_arg1
	if ( cnvfix_arg1 >= 0 ) {
		return "+" + cnvfix_arg1
	}
	return "" + cnvfix_arg1

#deffunc stxt int stxt_arg1, str stxt_arg2
	if ( stxt_arg1 == 0 | (synccheck(stxt_arg1, -1) & cdata(CDATA_CONDITION_BLIND, CHARA_PLAYER) == 0) ) {
		txt stxt_arg2
	}
	return

#defcfunc cnvdate int cnvdate_arg1, int cnvdate_arg2
	locvar_cnvdate_p = cnvdate_arg1
	locvar_cnvdate_hour = cnvdate_arg1 \ 24
	locvar_cnvdate_day = cnvdate_arg1 / 24 \ 30
	if ( locvar_cnvdate_day == 0 ) {
		locvar_cnvdate_day = 30
		locvar_cnvdate_p -= 24 * 30
	}
	locvar_cnvdate_month = locvar_cnvdate_p / 24 / 30 \ 12
	if ( locvar_cnvdate_month == 0 ) {
		locvar_cnvdate_month = 12
		locvar_cnvdate_p -= 24 * 30 * 12
	}
	locvar_cnvdate_year = locvar_cnvdate_p / 24 / 30 / 12
	locvar_cnvdate_s = "" + locvar_cnvdate_year + lang("年", " ") + locvar_cnvdate_month + lang("月", "/") + locvar_cnvdate_day + lang("日", " ")
	if ( cnvdate_arg2 == 1 ) {
		locvar_cnvdate_s += "" + locvar_cnvdate_hour + lang("時", "h")
	}
   	if ( cnvdate_arg2 == 2 ) {
   		locvar_cnvdate_s = "" + locvar_cnvdate_month + lang("月", "/") + locvar_cnvdate_day + lang("日", " ") + locvar_cnvdate_hour + lang("時", "h")
   	}
	return locvar_cnvdate_s

#defcfunc cnvplaytime int cnvplaytime_arg1
	return "" + cnvplaytime_arg1 / 60 / 60 + lang("時間", ":") + cnvplaytime_arg1 / 60 \ 60 + lang("分", ":") + cnvplaytime_arg1 \ 60 + lang("秒", " Sec")

#defcfunc roundmargin int roundmargin_arg1, int roundmargin_arg2
	if ( roundmargin_arg1 > roundmargin_arg2 ) {
		return roundmargin_arg1 - rnd(roundmargin_arg1 - roundmargin_arg2)
	}
	if ( roundmargin_arg1 < roundmargin_arg2 ) {
		return roundmargin_arg1 + rnd(roundmargin_arg2 - roundmargin_arg1)
	}
	return roundmargin_arg1

#deffunc at int at_waittime
	if ( cc == CHARA_PLAYER ) {
		autoturn = 1
		if ( cfg_autoturn == 0 ) {
			await at_waittime
			scrturn++
		}
		if ( cfg_autoturn != 2 | firstautoturn == 1 ) {
			screenupdate = -1
			gosub *screen_draw
		}
		if ( cfg_autoturn == 0 ) {
			redraw 1
		}
	}
	return

#include "text.hsp"

*system_init

	/********** ANNA / BLOODYSHADE CUSTOM - BEGINNING **********/

    gosub *ErrorMsgInit

	dim dblist_dup_card, MAX_DB, 2
	dim dblist_dup_fig, MAX_DB, 2

	// Custom AI Declarations
	gosub *InitCustomAI

	/********** ANNA / BLOODYSHADE CUSTOM - ENDING **********/

	tmset
	time_warn = timeGetTime() / 1000
	time_begin = timeGetTime() / 1000
	procid = (procid + 1) \ 4
	proclist(procid) = "system_init" + " ct:" + ct
	exist exedir + "config.txt"
	if ( strsize == (-1) ) {
		bcopy exedir + "original\\" + "config.txt", exedir + "config.txt"
	}
	exist exedir + "user\\export.txt"
	if ( strsize == (-1) ) {
		bcopy exedir + "original\\" + "export.txt", exedir + "user\\export.txt"
	}
	exist exedir + "user\\lastwords.txt"
	if ( strsize == (-1) ) {
		bcopy exedir + "original\\" + "lastwords.txt", exedir + "user\\lastwords.txt"
	}
	exist exedir + "user\\lastwords-e.txt"
	if ( strsize == (-1) ) {
		bcopy exedir + "original\\" + "lastwords-e.txt", exedir + "user\\lastwords-e.txt"
	}
	exist exedir + "user\\music\\musiclist.txt"
	if ( strsize == (-1) ) {
		bcopy exedir + "original\\" + "musiclist.txt", exedir + "user\\music\\musiclist.txt"
	}
	exist exedir + "user\\graphic\\face1.bmp"
	if ( strsize == (-1) ) {
		bcopy exedir + "original\\" + "face1.bmp", exedir + "user\\graphic\\face1.bmp"
	}
	gosub *mutexobj
	sdim s, 160, 40
	dim p, 100
	dim rtval, 10
	sdim rtvaln, 50, 10
	sdim key_select, 2, 20
	sdim buff, 10000
	gosub *config_init
	gosub *config_loadCore
	gosub *config_load
	gosub *screen_init
    gosub *DamagePopupsInit
	HIGHDPI_Initialize cfg_highdpi_scaling, cfg_highdpi_smoothing
	if ( cfg_fullscreen ) {
		chgdisp 1, windoww, windowh
		bgscr 0, windoww, windowh, 0, 0
		width windoww, windowh, 0, 0
	}
	else {
		screen 0, windoww, windowh, 0, windowx, windowy
	}
	gsel 0
	redraw 0
	color 0
	boxf
	redraw 1
	onkey gosub *esc_check
	onkey 0
	onexit goto *exit_game
	buffer 3, 1440, 800
	picload exedir + "\\graphic\\interface" + devfile + ".bmp", 1
	buffer 4, windoww, windowh
	cfg_exlog = 1
	if ( cfg_exlog ) {
		buffer 8, windoww, windowh
		p = windoww / 192
		repeat inf_maxlog
			cnt2 = cnt
			repeat p + 1
				if ( cnt == p ) {
					x = (windoww - inf_msgx) \ 192
				}
				else {
					x = 192
				}
				pos cnt * 192, cnt2 * inf_msgspace
				gcopy 3, 496, 536 + cnt2 \ 4 * inf_msgspace, x, inf_msgspace
			loop
		loop
		gsel 0
	}
	procid = (procid + 1) \ 4
	proclist(procid) = "Init buffer" + " ct:" + ct
	folder = exedir + "user\\graphic\\"
	buffer 1, SPRITE_SHEET_COLS_ITEM * SPRITE_SIZE_ITEM, SPRITE_SHEET_ROWS_ITEM * SPRITE_SIZE_ITEM
	picload exedir + "\\graphic\\item" + devfile + ".bmp", 1
	if ( inf_tiles != SPRITE_SIZE_ITEM ) {
		pos 0, 0
		gzoom SPRITE_SHEET_COLS_ITEM * inf_tiles, SPRITE_SHEET_ROWS_ITEM * inf_tiles, 1, 0, 0, SPRITE_SHEET_COLS_ITEM * SPRITE_SIZE_ITEM, SPRITE_SHEET_ROWS_ITEM * SPRITE_SIZE_ITEM
	}
	buffer 2, SPRITE_SHEET_COLS_ITEM * inf_tiles, SPRITE_SHEET_ROWS_ITEM * inf_tiles
	buffer 6, SPRITE_SHEET_COLS_ITEM * inf_tiles, SPRITE_SHEET_ROWS_ITEM * inf_tiles
	buffer 7, 24, 24
	buffer 9, 24, 24
	procid = (procid + 1) \ 4
	proclist(procid) = "dim" + " ct:" + ct
	dim initeq, 2, 50
	dup eqhelm, initeq(0, 0)
	dup eqweapon1, initeq(0, 1)
	dup eqshield, initeq(0, 2)
	dup eqrange, initeq(0, 3)
	dup eqammo, initeq(0, 4)
	dup eqweapon2, initeq(0, 5)
	dup eqarmor, initeq(0, 6)
	dup eqglove, initeq(0, 7)
	dup eqboots, initeq(0, 8)
	dup eqcloack, initeq(0, 9)
	dup eqgirdle, initeq(0, 10)
	dup eqring1, initeq(0, 11)
	dup eqring2, initeq(0, 12)
	dup eqamulet1, initeq(0, 13)
	dup eqamulet2, initeq(0, 14)
	dim cmapdata, 5, 400
	dim fixeditemenc, 10 * 2
	dim dir, 5
	dim dblist, 2, MAX_DB
	dim unlist, MAX_DB
	sdim csv, 1000, 40
	sdim filemod
	sdim csvbuff, 10000
	sdim csvidx, 100, 40
	sdim inputlog, 100
	sdim key, 20
	sdim keylog, 20
	sdim msg, 120, inf_maxlog
	sdim msgtemp, 1000
	sdim msgref, 200
	sdim randn1, 30, 20
	sdim randn2, 30, 20
	sdim select, 200
	dim n, 40
	dim rtval, 10
	dim list, 3, 500
	sdim listn, 40, 2, 500
	dim invctrl, 2
	sdim promptl, 50, 3, 20
	sdim description, 1000, 3
	sdim file, 1000
	sdim folder, 1000
	sdim msgtempprev
	dim mef, 9, 200
	dim adata, 40, 500
	dim qdata, QDATA_MAX_SIZE, QDATA_MAX_CLIENT
	sdim qname, QNAME_MAX_SIZE, QDATA_MAX_CLIENT
	dim gdata, 1000
	dim genetemp, 1000
	sdim gdatan, 40, MAX_GDATAN
	dim mdatatmp, 100
	dim mdata, 100
	sdim mdatan, 20, MAX_MDATAN
	sdim cdatan, 40, MAX_CDATAN, MAX_CHARA_TOTAL
	sdim s1, 1000
	dim cdata, MAX_CHARA_DATA, MAX_CHARA_TOTAL
	dim sdata, MAX_SKILL_DATA, MAX_CHARA_TOTAL
	dim spell, MAX_SPELL_COUNT
	dim spells, MAX_SPELL_COUNT
	dim spact, MAX_SPACT_COUNT
	dim mat, MAX_MATERIAL_COUNT
	dim inv, INV_ITEM_MAX, MAX_INV_DATA
	dim trait, 500
	dim itemmemory, 3, MAX_DB
	dim npcmemory, 2, MAX_DB
	dim recipememory, MAX_RPDATA
	dim invmark, 35
	dim commark, 3
	dim feat, 5
	sdim iname, 40
	dim val, 10
	sdim valn, 50, 10
	dim dirchk, 3, 2
	dirchk(0, 0) = -1, 0, 1
	dirchk(0, 1) = 1, 0, -1
	dim chatval, 5
	dim evlist, 10
	dim matneed, 20
	dim pcc, 30, 20
	maxrain = windoww * windowh / 3500
	dim rainx, maxrain * 2
	dim rainy, maxrain * 2
	sdim fltnrace
	dim card, 4, MAX_CARD
	dim deck, MAX_CARD
	gosub *sRefDefine
	gosub *bRefDefine
	gosub *mRefDefine
	dim rdata, 30, 20
	dup roomexist, rdata(0, 0)
	dup roomx, rdata(0, 1)
	dup roomy, rdata(0, 2)
	dup roomwidth, rdata(0, 3)
	dup roomheight, rdata(0, 4)
	dup roomexit, rdata(0, 5)
	dup roomexitmax, rdata(0, 6)
	dup roomentrancex, rdata(0, 7)
	dup roomentrancey, rdata(0, 8)
	dim idata, 8
	dim dirxy, 2, 4
	dirxy(0, 3) = 0, -1
	dirxy(0, 0) = 0, 1
	dirxy(0, 1) = -1, 0
	dirxy(0, 2) = 1, 0
	dim c_col, 3, MAX_COLOR
	c_col(0, COLOR_DEFAULT) = 0, 0, 0
	c_col(0, COLOR_GREEN) = 80, 0, 80
	c_col(0, COLOR_RED) = 0, 100, 100
	c_col(0, COLOR_BLUE) = 80, 80, 0
	c_col(0, COLOR_BROWN) = 0, 40, 80
	c_col(0, COLOR_YELLOW) = 0, 0, 80
	c_col(0, COLOR_BLACK) = 100, 101, 102
	c_col(0, COLOR_PURPLE) = 70, 100, 40
	c_col(0, COLOR_SKY_BLUE) = 100, 50, 50
	c_col(0, COLOR_PINK) = 0, 60, 70
	c_col(0, COLOR_ORANGE) = 20, 40, 100
	c_col(0, COLOR_WHITE) = 10, 10, 10
	c_col(0, COLOR_FRESH) = 30, 40, 70
	c_col(0, COLOR_DARK_GREEN) = 150, 20, 150
	c_col(0, COLOR_GRAY) = 50, 50, 50
	c_col(0, COLOR_LIGHT_RED) = 0, 30, 30
	c_col(0, COLOR_LIGHT_BLUE) = 30, 30, 0
	c_col(0, COLOR_LIGHT_PURPLE) = 30, 60, 0
	c_col(0, COLOR_LIGHT_GREEN) = 40, 0, 40
	c_col(0, COLOR_TALK) = 45, 5, 95
	c_col(0, COLOR_LIGHT_BLUE2) = 255, 100, 1
	c_col(0, COLOR_RED2) = 0, 200, 200
	c_col(0, COLOR_LIME) = 90, 60, 250
	c_col(0, COLOR_DARK_GRAY) = 150, 150, 150
	c_col(0, COLOR_YELLOW2) = 0, 0, 200
	c_col(0, COLOR_PURPLE2) = 80, 150, 0
	c_col(0, COLOR_LIGHT_BROWN) = 90, 110, 130
	c_col(0, COLOR_DARK_GRAY2) = 180, 180, 180
	c_col(0, COLOR_DARK_GRAY3) = 230, 230, 230
	c_col(0, COLOR_LIGHT_BLUE3) = 0, 150, 150
	dim dirchk, 3, 2
	dirchk(0, 0) = -1, 0, 1
	dirchk(0, 1) = 1, 0, -1
	dim val_skill, 5
	sdim valn_skill, 40, 3
	dim cs_posbk, 4
	dim floorstack, 400
	sdim key_list, 2, 20
	sdim playerheader, 100
	sdim artifactlocation
	sdim newsbuff
	sdim soundfile, 30, SOUNDLIST_MAX
	sdim musicfile, 30, MUSICLIST_MAX + 5
	dim slight, inf_screenw + 4, inf_screenh + 4
	dim slightbk, inf_screenw + 4, inf_screenh + 4
	gsel 3
	gmode 0
	redraw 0
	color 1, 1, 1
	font lang(cfg_font1, cfg_font2), 15 - en * 2, 0
	repeat 18
		pos cnt * 24 + 72, 30
		gcopy 3, 0, 30, 24, 18
		pos cnt * 24 + 77, 31
		color 50, 60, 80
		bmes key_select(cnt), 250, 240, 230
	loop
	gsel 0
	gmode 2
	text_set
	notesel msg_log
	repeat inf_maxlog - 2
		noteadd ""
	loop
	noteadd lang("■メッセージログ", "<Message Log>")
	noteadd lang("過去の20行分のメッセージが表示されます。", "Past 20 message lines are logged.")
	fmode = 10
	gosub *game_ctrlFile
	tc = CHARA_PLAYER
	tcol@txtfunc = 255, 255, 255
	invctrl = 0, 0
	pos -40, -40
	mesbox keylog, 0, 0, 1, 10
	sdim buffboard
	notesel buffboard
	noteload exedir + "data\\board.txt"
	sdim filter_item
	sdim rffilter_item
	sdim ioriginalnameref
	sdim ioriginalnameref2
	sdim iknownnameref
	sdim ialphanameref
	dim irandomname, MAX_DB
	dim icolref
	dim keybd_st, 256
	dim trate, 9
	sdim filtern
	sdim filter_creature
	sdim netbuf, 20000
	gosub *del_userNpc
	gosub *del_userTemp
	gosub *db_setFilterRace
	gosub *db_setFilterCreature
	gosub *db_setFilterItem
	gosub *chip_init
	gosub *building_init
	gosub *setArea
	gosub *setCellObj
	gosub *random_titleInit
	gdata(GDATA_RAND_SEED_A) = rnd(800) + 2
	gdata(GDATA_RAND_SEED_B) = rnd(200) + 2
	gosub *god_init
	gosub *db_setItem
	gosub *trait_init
	gosub *rank_init
	gosub *politics_init
	gosub *item_materialInit
	gosub *item_egoInit
	gosub *item_encInit
	gosub *item_fltInit
	gosub *item_foodInit
	gosub *recipe_init
	gosub *fish_init
	gosub *map_randNameInit
	gosub *setHome
	gosub *userNpc_update
	if ( cfg_music == 1 ) {
		DMINIT
		if ( stat == 0 ) {
			cfg_music = 2
		}
	}
	if ( cfg_sound == 1 ) {
		DSINIT
		if ( stat == 0 ) {
			cfg_sound = 2
		}
	}
	if ( cfg_joypad == 1 ) {
		DIINIT
		DIGETJOYNUM
		if ( stat == 0 ) {
			cfg_joypad = 0
		}
	}
	gosub *sound_init
	gosub *music_init
	mainskill = SKILL_NORMAL_EVASION, SKILL_WEAPON_MARTIAL_ARTS, SKILL_WEAPON_BOW
	dim cycle, 15, 5
	sdim cyclekey, 5, 15
	cycle(0, 0) = 1, 2, 5, 7, 8, 9, 14, 15, 17, 26, -1
	cycle(0, 1) = 1, 5, 7, 8, 14, -1
	cycle(0, 2) = 10, 25, -1
	cycle(0, 3) = 22, 24, -1
	cycle(0, 4) = 2, -1
	cyclemax = 9, 4, 1, 1, 0
	shadowmap = 0, 9, 10, 5, 12, 7, 0, 1, 11, 0, 6, 3, 8, 4, 2, 0, 0
	lastctrl = 1
	dim invicon, 40
	sdim invkey, 4, 40
	invkey = "", "" + key_inventory, "" + key_drop, "", "", "" + key_eat, "", "" + key_read, "" + key_drink, "" + key_zap, "", "", "", "", "" + key_use, "" + key_open, "", "" + key_dip
	invkey(26) = "" + key_throw
	invicon = -1, 7, 8, -1, -1, 2, -1, 3, 0, 1, 17, -1, -1, -1, 5, 4, -1, 6, -1, -1, -1, -1, 17, -1, 17, 17, 18, -1, -1, -1, -1, -1, -1, -1, -1
	hour_played = 0
	if ( cfg_autonumlock ) {
		GetKeyboardState keybd_st
		if ( peek(keybd_st, 144) == 1 ) {
			keybd_event 144
			keybd_event 144, 0, 2
		}
	}
#ifdef CUSTOM_GX_LUA
	gosub *lua_init
#endif
	goto *game_init

*ErrorMsgInit
    sdim ErrorMsg, 2, 42

    ErrorMsg(0, 0) = "",                                            ""
    ErrorMsg(0, 1) = "システムエラーが発生しました",                "Unknown system error"
    ErrorMsg(0, 2) = "文法が間違っています",                        "Syntax error"
    ErrorMsg(0, 3) = "パラメータの値が異常です",                    "Illegal function call"
    ErrorMsg(0, 4) = "計算式でエラーが発生しました",                "Wrong expression"
    ErrorMsg(0, 5) = "パラメータの省略はできません",                "Default parameter not allowed"
    ErrorMsg(0, 6) = "パラメータの型が違います",                    "Type mismatch"
    ErrorMsg(0, 7) = "配列の要素が無効です",                        "Array overflow"
    ErrorMsg(0, 8) = "有効なラベルが指定されていません",            "Not a label object"
    ErrorMsg(0, 9) = "サブルーチンやループのネストが深すぎます",    "Too many nesting"
    ErrorMsg(0, 10) = "サブルーチン外のreturnは無効です",           "Return without gosub"
    ErrorMsg(0, 11) = "repeat外でのloopは無効です",                 "Loop without repeat"
    ErrorMsg(0, 12) = "ファイルが見つからないか無効な名前です",     "File I/O error"
    ErrorMsg(0, 13) = "画像ファイルがありません",                   "Picture file missing"
    ErrorMsg(0, 14) = "外部ファイル呼び出し中のエラーです",         "External execute error"
    ErrorMsg(0, 15) = "計算式でカッコの記述が違います",             "Priority error"
    ErrorMsg(0, 16) = "パラメータの数が多すぎます",                 "Too many parameters"
    ErrorMsg(0, 17) = "文字列式で扱える文字数を越えました",         "Temporary buffer overflow"
    ErrorMsg(0, 18) = "代入できない変数名を指定しています",         "Wrong valiable name"
    ErrorMsg(0, 19) = "0で除算しました",                            "Divided by zero"
    ErrorMsg(0, 20) = "バッファオーバーフローが発生しました",       "Buffer Overflow"
    ErrorMsg(0, 21) = "サポートされない機能を選択しました",         "Unsupported function"
    ErrorMsg(0, 22) = "計算式のカッコが深すぎます",                 "Expression too complex"
    ErrorMsg(0, 23) = "変数名が指定されていません",                 "Variable required"
    ErrorMsg(0, 24) = "整数以外が指定されています",                 "Integer value required"
    ErrorMsg(0, 25) = "配列の要素書式が間違っています",             "Bad array expression"
    ErrorMsg(0, 26) = "メモリの確保ができませんでした",             "Out of memory"
    ErrorMsg(0, 27) = "タイプの初期化に失敗しました",               "Type initalization failed"
    ErrorMsg(0, 28) = "関数に引数が設定されていません",             "No Function parameters"
    ErrorMsg(0, 29) = "スタック領域のオーバーフローです",           "Stack overflow"
    ErrorMsg(0, 30) = "無効な名前がパラメーターに指定されています", "Invalid parameter name"
    ErrorMsg(0, 31) = "異なる型を持つ配列変数に代入しました",       "Invalid type of array"
    ErrorMsg(0, 32) = "関数のパラメーター記述が不正です",           "Invalid function parameter"
    ErrorMsg(0, 33) = "オブジェクト数が多すぎます",                 "Too many window objects"
    ErrorMsg(0, 34) = "配列・関数として使用できない型です",         "Invalid Array/Function"
    ErrorMsg(0, 35) = "モジュール変数が指定されていません",         "Structure required"
    ErrorMsg(0, 36) = "モジュール変数の指定が無効です",             "Illegal structure call"
    ErrorMsg(0, 37) = "変数型の変換に失敗しました",                 "Invalid type of variable"
    ErrorMsg(0, 38) = "外部DLLの呼び出しに失敗しました",            "DLL call failed"
    ErrorMsg(0, 39) = "外部オブジェクトの呼び出しに失敗しました",   "External COM call failed"
    ErrorMsg(0, 40) = "関数の戻り値が設定されていません。",         "No function result"
    ErrorMsg(0, 41) = "関数を命令として記述しています。",           "Invalid syntax for function"

    return

*exit_game
	if ( cfg_music == 1 ) {
		DMEND
	}
	if ( cfg_sound == 1 ) {
		DSEND
	}
	if ( ieopen ) {
		delcom ie_event
		delcom ie
	}
	if ( cfg_autonumlock ) {
		keybd_event 144
		keybd_event 144, 0, 2
	}
	if ( mutex_handle != 0 ) {
		CloseHandle mutex_handle
	}
	end

*exit_game_error
	if ( errorhack > 1 ) {
		goto *exit_game
	}
	else {
		errorhack++
	}
	buf = "HspError " + wparam + " WinError " + GetLastError() + " Line " + lparam + " Ver " + VERSION_NUMBER + " Mode " + mode + "\n"
	buf += "Message (JP): " + ErrorMsg(0, wparam) + "\n"
	buf += "Message (EN): " + ErrorMsg(1, wparam) + "\n"
	buf += "efId " + efid + " efP " + efp + " Area " + gdata(GDATA_AREA) + "/" + gdata(GDATA_LEVEL) + "\n"
	buf += "ci "
	if ( ci < SIZE_INV1 ) {
		buf += "0"
		if ( ci >= 0 ) {
			buf += "#" + inv(INV_ITEM_ID, ci)
		}
	}
	if ( ci >= RANGE_INV2 ) {
		buf += "-1"
		if ( ci < MAX_INV_DATA ) {
			buf += "#" + inv(INV_ITEM_ID, ci)
		}
	}
	if ( ci >= SIZE_INV1 ) {
		if ( ci < RANGE_INV2 ) {
			buf += "" + ((ci - SIZE_INV1) / SIZE_INV2 + 1)
			buf += "#" + inv(INV_ITEM_ID, ci)
		}
	}
	buf += " ti "
	if ( ti < SIZE_INV1 ) {
		buf += "0"
		if ( ti >= 0 ) {
			buf += "#" + inv(INV_ITEM_ID, ti)
		}
	}
	if ( ti >= RANGE_INV2 ) {
		buf += "-1"
		if ( ti < MAX_INV_DATA ) {
			buf += "#" + inv(INV_ITEM_ID, ti)
		}
	}
	if ( ti >= SIZE_INV1 ) {
		if ( ti < RANGE_INV2 ) {
			buf += "" + ((ti - SIZE_INV1) / SIZE_INV2 + 1)
			buf += "#" + inv(INV_ITEM_ID, ti)
		}
	}
	buf += " cc " + cc
	if ( cc >= CHARA_PLAYER & cc < MAX_CHARA_TOTAL ) {
		buf += "#" + cdata(CDATA_ID, cc)
	}
	buf += " tc " + tc
	if ( tc >= CHARA_PLAYER & tc < MAX_CHARA_TOTAL ) {
		buf += "#" + cdata(CDATA_ID, tc)
	}
	buf += " rc " + rc
	if ( rc >= CHARA_PLAYER & rc < MAX_CHARA_TOTAL ) {
		buf += "#" + cdata(CDATA_ID, rc)
	}
	buf += "\n"
	repeat 4
		buf += "" + (3 - cnt) + ". " + proclist((procid + cnt + 1) \ 4) + "\n"
	loop
	repeat MAX_CHARA_TOTAL
		if ( cdata(CDATA_EXIST, cnt) != CHAR_STATE_ALIVE ) {
			continue
		}
		if ( cdata(CDATA_X, cnt) < 0 | cdata(CDATA_X, cnt) >= mdata(MDATA_WIDTH) | cdata(CDATA_Y, cnt) < 0 | cdata(CDATA_Y, cnt) >= mdata(MDATA_HEIGHT) ) {
			buf += "* invalid chara position " + cnt + "#" + cdata(CDATA_ID, cnt) + "(" + cdata(CDATA_X, cnt) + "/" + cdata(CDATA_Y, cnt) + ") max(" + mdata(MDATA_WIDTH) + "/" + mdata(MDATA_HEIGHT) + ")\n"
		}
	loop
	repeat MAX_MAP_INV, RANGE_INV2
		if ( mode == MODELIST_SHOP ) {
			break
		}
		if ( inv(INV_ITEM_NUM, cnt) <= 0 ) {
			continue
		}
		if ( inv(INV_ITEM_X, cnt) < 0 | inv(INV_ITEM_X, cnt) >= mdata(MDATA_WIDTH) | inv(INV_ITEM_Y, cnt) < 0 | inv(INV_ITEM_Y, cnt) >= mdata(MDATA_HEIGHT) ) {
			buf += "* invalid item position " + cnt + "#" + inv(INV_ITEM_ID, cnt) + "(" + inv(INV_ITEM_X, cnt) + "/" + inv(INV_ITEM_Y, cnt) + ") max(" + mdata(MDATA_WIDTH) + "/" + mdata(MDATA_HEIGHT) + ")\n"
		}
	loop
	if ( characreatehack ) {
		buf += "* error in function:chara_create:#" + (characreatehack - 1) + "\n"
	}
	if ( itemcreatehack ) {
		buf += "* error in function:item_create:#" + (itemcreatehack - 1) + "\n"
	}
	if ( chararefreshhack ) {
		buf += "* error in function:charaRefresh\n"
	}
	if ( itemnamehack ) {
		buf += "* error in function:itemName:#" + (itemnamehack - 1) + "\n"
	}
	if ( screendrawhack ) {
		buf += "* error in function:screen_draw:" + screendrawhack + "\n"
	}
	if ( gdata(GDATA_AREA) == AREA_SHOW_HOUSE ) {
		buf += "* (possibly)invalid show room:#" + usermapid + "\n"
	}
	if ( ci < 0 ) {
		buf += "* ci is below 0\n"
	}
	if ( ci >= MAX_INV_DATA ) {
		buf += "* ci is above max\n"
	}
	if ( ti < 0 ) {
		buf += "* ti is below 0\n"
	}
	if ( ti >= MAX_INV_DATA ) {
		buf += "* ti is above max\n"
	}
	if ( cc < CHARA_PLAYER ) {
		buf += "* cc is below 0\n"
	}
	if ( cc >= MAX_CHARA_TOTAL ) {
		buf += "* cc is above max\n"
	}
	if ( tc < CHARA_PLAYER ) {
		buf += "* tc is below 0\n"
	}
	if ( tc >= MAX_CHARA_TOTAL ) {
		buf += "* tc is above max\n"
	}
	if ( rc < CHARA_PLAYER ) {
		buf += "* rc is below 0\n"
	}
	if ( rc >= MAX_CHARA_TOTAL ) {
		buf += "* rc is above max\n"
	}
	buf += lang("\n\nどのようなことをしてエラーが出たのか、再現性の有無、状況のわかるスクリーンショット、本家開発版との比較結果などの情報を確認・整理してください。そのうえでElona板の開発スレにバグ報告用テンプレに沿って報告して頂けると、原因の特定ができて助かります。起きたことを簡潔に述べる、エラー文のみを報告する、程度では解決する見込みはほとんどありません。", "\n\nPlease check and organize the information as to what kind of thing you were doing when the error occurred, if it is reproducible, screenshot showing the problem, comparison of the results from the vanilla version. In addition, if you can use the bug reporting template on the Elona board development thread, it would help identify the cause and will be saved for reference. There is little chance it will be solved if you provide very little information or just the error code.")
	notesel buf
	notesave exedir + "error.txt"
	exec exedir + "error.txt", 16
	goto *exit_game

