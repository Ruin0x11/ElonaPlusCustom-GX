*gene_itemfix
	inv_getheader -1
	repeat invrange, invhead
		if ( inv(INV_ITEM_ID, cnt) == ITEM_ID_CARD | inv(INV_ITEM_ID, cnt) == ITEM_ID_FIGURINE ) {
			inv(INV_ITEM_NUM, cnt) = 0
		}
	loop
	return

*fixOnMapEnter
	procid = (procid + 1) \ 4
	proclist(procid) = "fixOnMapEnter" + " ct:" + ct
	repeat MAX_CHARA_TOTAL
		if ( cdata(CDATA_EXIST, cnt) == CHAR_STATE_ALIVE ) {
			if ( cdata(CDATA_X, cnt) < 0 | cdata(CDATA_X, cnt) >= mdata(MDATA_WIDTH) | cdata(CDATA_Y, cnt) < 0 | cdata(CDATA_Y, cnt) >= mdata(MDATA_HEIGHT) ) {
				cdata(CDATA_X, cnt) = 0
				cdata(CDATA_Y, cnt) = 0
			}
		}
	loop
	if ( mdata(MDATA_TYPE) != MAP_TYPE_HOME ) {
		if ( mdata(MDATA_MAX_INV) != 0 ) {
			mdata(MDATA_MAX_INV) = 0
		}
	}
	if ( gdata(GDATA_AREA) == AREA_HOME ) {
		if ( gdata(GDATA_FLAG_INVITED_GOD) != 0 ) {
			evadd EVENT_SPAWN_EVENT_NPCS
		}
		adata(ADATA_MIN_LEVEL, gdata(GDATA_AREA)) = 0
		adata(ADATA_MAX_LEVEL, gdata(GDATA_AREA)) = 10
		adata(ADATA_RESTORE_POS, gdata(GDATA_AREA)) = 1
		mdata(MDATA_RESTORE_POS) = 1
		if ( gdata(GDATA_TEMPORARY_FLAGS2) == 0 ) {
			evadd EVENT_WELCOME
		}
		calccosthire
	}
	gdata(GDATA_TEMPORARY_FLAGS2) = 0
	return

*fixSave
	if ( gdata(GDATA_VERSION) != int(double("3.21") * 1000) ) {
		dialog lang("Ver." + gdata(GDATA_VERSION) + "のセーブデータをアップデートします。", "Updating your save data from Ver." + gdata(GDATA_VERSION) + " now.")
	}
	if ( gdata(GDATA_HEIR_DEED) < 0 ) {
		gdata(GDATA_HEIR_DEED) = 1
	}
	if ( gdata(GDATA_TRAVEL_TIME) == 0 ) {
		gdata(GDATA_TRAVEL_TIME) = gdata(GDATA_HOUR) + gdata(GDATA_DAY) * 24 + gdata(GDATA_MONTH) * 24 * 30 + gdata(GDATA_YEAR) * 24 * 30 * 12
	}
	if ( gdata(GDATA_VERSION) == 940 ) {
		if ( gdata(STARTING_GDATA_RANK + 4) != 0 ) {
			gdata(STARTING_GDATA_RANK + 2) = gdata(STARTING_GDATA_RANK + 4)
		}
	}
	repeat 20
		if ( gdata(STARTING_GDATA_RANK + cnt) == 0 ) {
			gdata(STARTING_GDATA_RANK + cnt) = 10000
		}
	loop
	itemmemory(2, 289) = 0
	itemmemory(2, 732) = 0
	if ( gdata(GDATA_VERSION) < 950 ) {
		itemcreate 0, ITEM_ID_PLAYBACK_DISC, -1, -1, 0
		itemcreate 0, ITEM_ID_FREEZER, -1, -1, 0
		inv(INV_ITEM_FILE, ci) = ITEM_ROLE_FILE_FREEZER
	}
	if ( gdata(GDATA_VERSION) < 952 ) {
		gdata(GDATA_WORLD_RENEW) = 1
	}
	if ( gdata(GDATA_VERSION) < 954 ) {
		repeat MAX_CHARA_FOLLOWER
			if ( cnt == CHARA_PLAYER | cdata(CDATA_EXIST, cnt) == CHAR_STATE_DEAD ) {
				continue
			}
			inv_getheader cnt
			cnt2 = cnt
			repeat invrange, invhead
				if ( inv(INV_ITEM_NUM, cnt) != 0 ) {
					if ( inv(INV_ITEM_ID, cnt) == ITEM_ID_GOLD_PIECE ) {
						inv(INV_ITEM_WEIGHT, cnt) = 0
					}
					item_stack cnt2, cnt
				}
			loop
		loop
		gdata(GDATA_LIGHT) = 90
	}
	if ( gdata(GDATA_VERSION) < 960 ) {
		gdata(GDATA_FLAG_HOLY_WELL) = 2
	}
	if ( gdata(GDATA_VERSION) < 973 ) {
		gdata(GDATA_CORRUPTION) = 0
		repeat MAX_TRAIT
			if ( trait(cnt) != 0 ) {
				if ( cnt > 37 ) {
					trait(cnt) = 0
				}
			}
		loop
		gosub *cm_putTrait
	}
	if ( gdata(GDATA_VERSION) < 975 ) {
		file = exedir + "tmp\\"
		existwrapper file + "mdata_5_103.s2"
		if ( strsize != (-1) ) {
			deletewrapper file + "mdata_5_103.s2"
		}
		if ( gdata(GDATA_AREA) == AREA_VERNIS ) {
			dialog "マップをアップデートするため、一度ヴェルニースに出入りしてください。"
		}
	}
	if ( gdata(GDATA_VERSION) < 1010 ) {
		gdata(GDATA_SISTER_KILLED) = 0
	}
	if ( gdata(GDATA_VERSION) < 1060 ) {
		repeat MAX_CHARA_SAVE
			cdata(CDATA_RELATION_ORG, cnt) = 10
		loop
	}
	if ( gdata(GDATA_VERSION) < 1070 ) {
		repeat MAX_CHARA_SAVE
			cdata(CDATA_LEVEL_ORG, cnt) = cdata(CDATA_LEVEL, cnt)
			if ( cnt >= MAX_CHARA_FOLLOWER ) {
				cdata(CDATA_RELATION, cnt) = 0
				cdata(CDATA_RELATION_ORG, cnt) = 0
			}
			else {
				cdata(CDATA_RELATION, cnt) = 10
				cdata(CDATA_RELATION_ORG, cnt) = 10
			}
		loop
	}
	if ( gdata(GDATA_VERSION) < 1100 ) {
		gdata(GDATA_WELL_WISH) = 0
		gosub *cm_putTrait
	}
	if ( gdata(GDATA_VERSION) < 1110 ) {
		gdata(GDATA_GUEST) = 0
		gdata(GDATA_WORLD_RENEW) = 1
		repeat MAX_CHARA_SAVE
			if ( cdata(CDATA_ROLE, cnt) == ROLE_ADVENTURER ) {
				cdata(CDATA_AI_INT, cnt) = 100
			}
		loop
	}
	if ( gdata(GDATA_VERSION) < 1111 ) {
		gdata(GDATA_WORLD_RENEW) = 1
		dialog lang("ユーザー物件の情報をアップデートするため、ゲーム開始後一度ワールドマップに出てください。", "Please exit the current area and enter the world map once to update game data.")
	}
	if ( gdata(GDATA_VERSION) < 1130 ) {
		cfg_net = 1
		valn = "net.", "1"
		gosub *cfg_write
		cfg_netwish = 1
		valn = "netWish.", "1"
		gosub *cfg_write
		cfg_netchat = 0
		valn = "netChat.", "0"
		gosub *cfg_write
	}
	if ( gdata(GDATA_VERSION) < 1140 ) {
		cfg_exanime = 1
		valn = "exAnime.", "1"
		gosub *cfg_write
		gdata(GDATA_WORLD_RENEW) = 1
		gosub *mapReset
	}
	if ( gdata(GDATA_VERSION) < 1150 ) {
		if ( gdata(GDATA_PLAY_TIME) < 0 ) {
			gdata(GDATA_PLAY_TIME) = 600 * 60 * 60
		}
		else {
			gdata(GDATA_PLAY_TIME) /= 1000
		}
	}
	if ( gdata(GDATA_VERSION) < 1170 ) {
		if ( adata(ADATA_TYPE, gdata(GDATA_AREA)) != MAP_TYPE_TOWN ) {
			dialog lang("アップデートを行うには、街中でセーブしたセーブデータが必要です。", "To update your game, please save your game in a town in the previous version then retry.")
			goto *exit_game
		}
		dialog lang("次のプロセスの完了までには、しばらく時間がかかることがあります。", "The next updating process may take a while to complete.")
		memcpy adata(ADATA_TYPE, STARTING_USER_AREA), adata(ADATA_TYPE, STARTING_USER_AREA_OLD), MAX_AREA_DATA * (STARTING_RANDOM_AREA_OLD - STARTING_USER_AREA_OLD) * 4
		memcpy adata(ADATA_TYPE, STARTING_RANDOM_AREA), adata(ADATA_TYPE, STARTING_RANDOM_AREA_OLD), MAX_AREA_DATA * (MAX_AREA_OLD - STARTING_RANDOM_AREA_OLD) * 4
		repeat MAX_AREA_OLD - STARTING_USER_AREA_OLD, STARTING_USER_AREA_OLD
			p = cnt
			sdim file_cnv
			repeat MAX_AREA_DATA
				adata(cnt, p) = 0
			loop
			folder = exedir + "tmp"
			dirlistwrapper buff, folder + "\\*_" + p + "_*.*"
			if ( stat != 0 ) {
				notesel buff
				repeat stat
					noteget file, cnt
					p1 = instr(file, 0, "_")
					p2 = instr(file, p1 + 1, "_")
					if ( p >= STARTING_RANDOM_AREA_OLD ) {
						p3 = p - STARTING_RANDOM_AREA_OLD + STARTING_RANDOM_AREA
					}
					else {
						p3 = p - STARTING_USER_AREA_OLD + STARTING_USER_AREA
					}
					file_cnv = folder + "\\" + strmid(file, 0, p1 + 1) + p3 + strmid(file, p1 + p2 + 1, 20)
					file = folder + "\\" + file
					bcopy file, file_cnv
					fileadd file_cnv
					delete file
					fileadd file, 1
				loop
			}
		loop
		repeat MAX_AREA_COUNT
			if ( adata(ADATA_ID, cnt) != AREA_NONE ) {
				if ( adata(ADATA_PARENT, cnt) == AREA_NONE ) {
					adata(ADATA_PARENT, cnt) = AREA_NORTH_TYRIS
				}
			}
		loop
		gdata(GDATA_WORLD) = AREA_NORTH_TYRIS
	}
	if ( gdata(GDATA_VERSION) < 2130 ) {
		if ( gdata(GDATA_QUEST) == QUEST_TYPE_THIEVES ) {
			gdata(GDATA_QUEST) = QUEST_TYPE_NONE
			dialog lang("盗賊団フラグ抹消。", "Death bug is corrected.")
		}
	}
	if ( gdata(GDATA_VERSION) < 2160 ) {
		repeat MAX_CHARA_SAVE
			aphantei = 0
			if ( cbit(CHARA_BIT_AWAKE_DIM_ATTACKER, cnt) ) {
				aphantei += 1
			}
			if ( cbit(CHARA_BIT_AWAKE_NEAR_DEATH_EVASION, cnt) ) {
				aphantei += 1
			}
			if ( cbit(CHARA_BIT_AWAKE_NEAR_DEATH_DAMAGE, cnt) ) {
				aphantei += 1
			}
			if ( cbit(CHARA_BIT_AWAKE_MP_BARRIER, cnt) ) {
				aphantei += 1
			}
			if ( aphantei == 3 ) {
				if ( cbit(CHARA_BIT_AWAKE_DIM_ATTACKER, cnt) != 1 ) {
					cbitmod CHARA_BIT_AWAKE_NEAR_DEATH_EVASION, cnt, 0
					cdata(CDATA_AP_CURRENT, cnt) += 1800
				}
				if ( cbit(CHARA_BIT_AWAKE_NEAR_DEATH_EVASION, cnt) != 1 ) {
					cbitmod CHARA_BIT_AWAKE_NEAR_DEATH_DAMAGE, cnt, 0
					cdata(CDATA_AP_CURRENT, cnt) += 2000
				}
				if ( cbit(CHARA_BIT_AWAKE_NEAR_DEATH_DAMAGE, cnt) != 1 ) {
					cbitmod CHARA_BIT_AWAKE_MP_BARRIER, cnt, 0
					cdata(CDATA_AP_CURRENT, cnt) += 2000
				}
				if ( cbit(CHARA_BIT_AWAKE_MP_BARRIER, cnt) != 1 ) {
					cbitmod CHARA_BIT_AWAKE_DIM_ATTACKER, cnt, 0
					cdata(CDATA_AP_CURRENT, cnt) += 1500
				}
			}
			if ( aphantei == 4 ) {
				cbitmod CHARA_BIT_AWAKE_DIM_ATTACKER, cnt, 0
				cbitmod CHARA_BIT_AWAKE_NEAR_DEATH_EVASION, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 3300
			}
			aphantei = 0
		loop
	}
	if ( gdata(GDATA_VERSION) < 2180 ) {
		repeat MAX_CHARA_SAVE
			if ( cdata(CDATA_ID, cnt) == CREATURE_ID_GALACTICA_PHANTOM | cdata(CDATA_ID, cnt) == CREATURE_ID_SHADOW | cdata(CDATA_ID, cnt) == CREATURE_ID_VOL_PHANTOM | cdata(CDATA_ID, cnt) == CREATURE_ID_LESSER_PHANTOM ) {
				cdatan(CDATAN_RACE, cnt) = "ghost"
			}
			if ( cdata(CDATA_ID, cnt) == CREATURE_ID_HELL_CRAB | cdata(CDATA_ID, cnt) == CREATURE_ID_FIRE_CRAB ) {
				cdatan(CDATAN_RACE, cnt) = "shell"
			}
			if ( cdata(CDATA_ID, cnt) == CREATURE_ID_BOMB_THROWER | cdata(CDATA_ID, cnt) == CREATURE_ID_MAD_SCIENTIST | cdata(CDATA_ID, cnt) == CREATURE_ID_WHOM_DWELL_IN_THE_VANITY | cdata(CDATA_ID, cnt) == CREATURE_ID_LOYTER_THE_CRIMSON_OF_ZANAN | cdata(CDATA_ID, cnt) == CREATURE_ID_NOBLE | cdata(CDATA_ID, cnt) == CREATURE_ID_GANGSTER | cdata(CDATA_ID, cnt) == CREATURE_ID_ROCK_THROWER | cdata(CDATA_ID, cnt) == CREATURE_ID_PUBLIC_PERFORMER | cdata(CDATA_ID, cnt) == CREATURE_ID_NURSE | cdata(CDATA_ID, cnt) == CREATURE_ID_RICH_PERSON | cdata(CDATA_ID, cnt) == CREATURE_ID_NOBLE_CHILD ) {
				cdatan(CDATAN_RACE, cnt) = "zanan"
			}
			if ( cdata(CDATA_ID, cnt) == CREATURE_ID_PART_TIME_WORKER2 | cdata(CDATA_ID, cnt) == CREATURE_ID_TRAVELER | cdata(CDATA_ID, cnt) == CREATURE_ID_SWIMMER | cdata(CDATA_ID, cnt) == CREATURE_ID_KARAM_THE_LONELY_WOLF_OF_KARUNE | cdata(CDATA_ID, cnt) == CREATURE_ID_MERCENARY | cdata(CDATA_ID, cnt) == CREATURE_ID_FARMER | cdata(CDATA_ID, cnt) == CREATURE_ID_MINER | cdata(CDATA_ID, cnt) == CREATURE_ID_PART_TIME_WORKER | cdata(CDATA_ID, cnt) == CREATURE_ID_PRISONER ) {
				cdatan(CDATAN_RACE, cnt) = "karune"
			}
		loop
	}
	if ( gdata(GDATA_VERSION) == 2170 ) {
		repeat MAX_CHARA_SAVE
			if ( cnt == CHARA_PLAYER ) {
				continue
			}
			if ( cbit(CHARA_BIT_AWAKE_NEAR_DEATH_EVASION, cnt) == 1 ) {
				cbitmod CHARA_BIT_AWAKE_NEAR_DEATH_EVASION, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 1800
			}
			if ( cbit(CHARA_BIT_AWAKE_NEAR_DEATH_DAMAGE, cnt) == 1 ) {
				cbitmod CHARA_BIT_AWAKE_NEAR_DEATH_DAMAGE, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 2000
			}
			if ( cbit(CHARA_BIT_AWAKE_MP_BARRIER, cnt) == 1 ) {
				cbitmod CHARA_BIT_AWAKE_MP_BARRIER, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 2000
			}
			if ( cbit(CHARA_BIT_AWAKE_DIM_ATTACKER, cnt) == 1 ) {
				cbitmod CHARA_BIT_AWAKE_DIM_ATTACKER, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 1500
			}
			if ( cbit(CHARA_BIT_AWAKE_INSULT, cnt) == 1 ) {
				cbitmod CHARA_BIT_AWAKE_INSULT, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 100
			}
			if ( cbit(CHARA_BIT_AWAKE_CRYSTAL_SPEAR, cnt) == 1 ) {
				cbitmod CHARA_BIT_AWAKE_CRYSTAL_SPEAR, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 600
			}
			if ( cbit(CHARA_BIT_AWAKE_TACTICAL_HEAL, cnt) == 1 ) {
				cbitmod CHARA_BIT_AWAKE_TACTICAL_HEAL, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 500
			}
			if ( cbit(CHARA_BIT_AWAKE_DIMENSIONAL_MOVE, cnt) == 1 ) {
				cbitmod CHARA_BIT_AWAKE_DIMENSIONAL_MOVE, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 100
			}
			if ( cbit(CHARA_BIT_AWAKE_TACTICAL_ATTACK, cnt) == 1 ) {
				cbitmod CHARA_BIT_AWAKE_TACTICAL_ATTACK, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 400
			}
			if ( cbit(CHARA_BIT_AWAKE_TACTICAL_MARTIAL_ARTS, cnt) == 1 ) {
				cbitmod CHARA_BIT_AWAKE_TACTICAL_MARTIAL_ARTS, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 600
			}
			if ( cbit(CHARA_BIT_AWAKE_CHARGE_ATTACK, cnt) == 1 ) {
				cbitmod CHARA_BIT_AWAKE_CHARGE_ATTACK, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 1000
			}
			if ( cbit(CHARA_BIT_AWAKE_PROVOKE, cnt) == 1 ) {
				cbitmod CHARA_BIT_AWAKE_PROVOKE, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 200
			}
			if ( cbit(CHARA_BIT_AWAKE_TACTICAL_CURSE, cnt) == 1 ) {
				cbitmod CHARA_BIT_AWAKE_TACTICAL_CURSE, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 500
			}
			if ( cbit(CHARA_BIT_AWAKE_VARIABLE_BREATH, cnt) == 1 ) {
				cbitmod CHARA_BIT_AWAKE_VARIABLE_BREATH, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 400
			}
			if ( cbit(CHARA_BIT_AWAKE_VARIABLE_STORM, cnt) == 1 ) {
				cbitmod CHARA_BIT_AWAKE_VARIABLE_STORM, cnt, 0
				cdata(CDATA_AP_CURRENT, cnt) += 800
			}
			if ( cdata(CDATA_AP_CURRENT, cnt) > 20000 ) {
				cdata(CDATA_AP_CURRENT, cnt) = rnd(500)
				cbitmod CHARA_BIT_UNKNOWN_1010, cnt, 1
			}
			if ( cdata(CDATA_AP_CURRENT, cnt) > 12000 ) {
				cdata(CDATA_AP_CURRENT, cnt) = 3000 + rnd(500)
			}
			if ( cdata(CDATA_AP_CURRENT, cnt) > 11000 ) {
				cdata(CDATA_AP_CURRENT, cnt) = 4000 + rnd(500)
			}
			if ( cdata(CDATA_AP_CURRENT, cnt) > 10000 ) {
				cdata(CDATA_AP_CURRENT, cnt) = 5000 + rnd(500)
			}
			if ( cdata(CDATA_AP_CURRENT, cnt) > 9000 ) {
				cdata(CDATA_AP_CURRENT, cnt) = 6000 + rnd(500)
			}
			if ( cdata(CDATA_AP_CURRENT, cnt) > 8000 ) {
				cdata(CDATA_AP_CURRENT, cnt) = 7000 + rnd(500)
			}
		loop
	}
	if ( gdata(GDATA_VERSION) == 2180 ) {
		dialog lang("アップデートを行うには、1.1555以外のセーブデータが必要です。", "To update your game, please save not 1.1555 version then retry.")
		goto *exit_game
	}
	if ( gdata(GDATA_VERSION) < 2210 ) {
		repeat MAX_INV_DATA
			inv(INV_ITEM_PARAM4, cnt) = 0
		loop
	}
	if ( gdata(GDATA_VERSION) == 2220 ) {
		dialog lang("1.18fix以外のセーブデータは使えません。", "To update your game, please save not 1.18fix version then retry.")
		goto *exit_game
	}
	if ( gdata(GDATA_VERSION) < 2260 ) {
		repeat MAX_CHARA_SAVE
			if ( cnt == CHARA_PLAYER ) {
				continue
			}
			if ( cdata(CDATA_DIRECTIVE_MODE, cnt) > DIRECTIVE_MODE_OFFENSIVE ) {
				cdata(CDATA_DIRECTIVE_MODE, cnt) = DIRECTIVE_MODE_DEFENSIVE
			}
		loop
	}
	if ( gdata(GDATA_VERSION) < 2280 ) {
		repeat MAX_CHARA_SAVE
			if ( cnt == CHARA_PLAYER ) {
				continue
			}
			if ( cdata(CDATA_SEX, cnt) == 0 ) {
				cdata(CDATA_TONE_SEX, cnt) = 1
			}
			else {
				cdata(CDATA_TONE_SEX, cnt) = 2
			}
		loop
		repeat MAX_INV_DATA
			saiseiseimode = 0
			ci = cnt
			if ( inv(INV_ITEM_ATTACK, ci) == 0 & inv(INV_ITEM_DAMAGE, ci) == 0 & inv(INV_ITEM_DV, ci) == 0 & inv(INV_ITEM_PV, ci) == 0 ) {
				continue
			}
			oldcol = inv(INV_ITEM_COL, ci)
			oldweight = inv(INV_ITEM_WEIGHT, ci)
			if ( inv(INV_ITEM_CHARA_PIC, ci) != 0 ) {
				inv(INV_ITEM_PV, ci) = inv(INV_ITEM_CHARA_PIC, ci)
			}
			if ( inv(INV_ITEM_NEED_SLEEP, ci) != 0 ) {
				inv(INV_ITEM_DV, ci) = inv(INV_ITEM_NEED_SLEEP, ci)
			}
			if ( inv(INV_ITEM_AMUR_CAGE, ci) != 0 ) {
				inv(INV_ITEM_DAMAGE, ci) = inv(INV_ITEM_AMUR_CAGE, ci)
			}
			if ( inv(INV_ITEM_SHOP_SAMPLE, ci) != 0 ) {
				inv(INV_ITEM_ATTACK, ci) = inv(INV_ITEM_SHOP_SAMPLE, ci)
			}
			if ( inv(INV_ITEM_QUALITY, ci) == FIX_QUALITY_UNIQUE ) {
				saiseiseimode = 50
			}
			else {
				saiseiseimode = 100
			}
			fixmaterial = inv(INV_ITEM_MATERIAL, ci)
			gosub *remake_material
			inv(INV_ITEM_WEIGHT, ci) = oldweight
			inv(INV_ITEM_COL, ci) = oldcol
			if ( ci >= RANGE_INV2 ) {
				cell_refresh inv(INV_ITEM_X, ci), inv(INV_ITEM_Y, ci)
			}
		loop
		saiseiseimode = 0
	}
	if ( gdata(GDATA_VERSION) < 2300 ) {
		gdata(GDATA_FLAG_PROSTITUTION_COUNTER) = 0
	}
	if ( gdata(GDATA_VERSION) < 2310 ) {
		gdata(GDATA_FLAG_HIGHEST_NORMAL_DAMAGE) = 0
	}
	if ( gdata(GDATA_VERSION) == 2310 ) {
		dialog lang("アップデートを行うには、1.25以外のセーブデータが必要です。", "To update your game, please save not 1.25 version then retry.")
		goto *exit_game
	}
	if ( gdata(GDATA_VERSION) <= 2390 ) {
		repeat 5
			p = gdata(GDATA_QUEST_POOL + cnt)
			qdata(QDATA_EXIST, p) = QUEST_TYPE_NONE
			qdata(QDATA_STATUS, p) = QUEST_STATE_NONE
		loop
		repeat MAX_CHARA_FOLLOWER
			cdata(CDATA_ALLIED, cnt) = 100
			if ( cnt != CHARA_PLAYER ) {
				if ( cbit(CHARA_BIT_BODYGUARD, cnt) == 1 ) {
					if ( qdata(QDATA_PARAM2, rq) == cdata(CDATA_ID, cnt) ) {
						tc = cnt
						cbitmod CHARA_BIT_BODYGUARD, cnt, 0
						if ( cdata(CDATA_EXIST, tc) == CHAR_STATE_ALIVE ) {
							s = lang("「おい、暗殺者が私の後ろにいるぞ」", cnvtalk("Hey, the assassins are killing me."))
							p = DAMAGE_FROM_UNSEEN
							txtef COLOR_SKY_BLUE
							txtmore
							txt s
							dmghp tc, 999999, p
						}
						cdata(CDATA_EXIST, tc) = CHAR_STATE_DEAD
						break
					}
				}
			}
		loop
		repeat 500
			qdata(QDATA_CLIENT, cnt) = 0
			qdata(QDATA_MAP, cnt) = 0
			gdata(GDATA_CLIENT) = 0
		loop
	}
	if ( gdata(GDATA_VERSION) < 2430 ) {
		repeat MAX_CHARA_TOTAL
			cdata(CDATA_CAN_REVIVE, cnt) = 1
		loop
	}
	if ( gdata(GDATA_VERSION) < 2440 ) {
		gdata(GDATA_FLAG_HIGHEST_NORMAL_DAMAGE) = 0
	}
	if ( gdata(GDATA_VERSION) < 2480 ) {
		repeat MAX_CHARA_TOTAL
			tc = cnt
			if ( cdata(CDATA_ID, tc) == CREATURE_ID_WASP | cdata(CDATA_ID, tc) == CREATURE_ID_RED_WASP | cdata(CDATA_ID, tc) == CREATURE_ID_BLACK_HORNET ) {
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) != 0 ) {
					resistmod tc, SKILL_RES_MAGIC, 50 * 10
				}
			}
			if ( cdata(CDATA_ID, tc) == CREATURE_ID_RAT ) {
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) != 0 ) {
					resistmod tc, SKILL_RES_FIRE, 50 * 10
				}
			}
		loop
	}
	if ( gdata(GDATA_VERSION) == 2500 ) {
		dialog lang("1.38のセーブデータはアップデートできません。", "To update your game, please save not 1.38 version then retry.")
		goto *exit_game
	}
	if ( gdata(GDATA_VERSION) < 2510 ) {
		repeat MAX_CHARA_SAVE
			if ( cdata(CDATA_AP_CURRENT, cnt) > 2000 ) {
				cdata(CDATA_AP_CURRENT, cnt) = 2000
			}
			cdata(CDATA_INIT_LIFEMANA, cnt) = limit(sorg(SKILL_ATTR_LIFE, cnt), 50, 200) * 2 + limit(sorg(SKILL_ATTR_MANA, cnt), 50, 200) / 2
			if ( cnt != 0 ) {
				cdata(CDATA_SKILLPOINT, cnt) = 0
			}
		loop
	}
	if ( gdata(GDATA_VERSION) < 2530 ) {
		kamen = 100
	}
	if ( gdata(GDATA_VERSION) < 2540 ) {
		if ( spact(SKILL_SPACT_GAUGE_RELEASE - STARTING_SKILL_SPACT) == 0 ) {
			spact(SKILL_SPACT_GAUGE_RELEASE - STARTING_SKILL_SPACT) = 1
			txtmore
			txtef COLOR_YELLOW
			txt lang("あなたは「" + skillname(SKILL_SPACT_GAUGE_RELEASE) + "」の能力を得た。", "You have learned a new ability, " + skillname(SKILL_SPACT_GAUGE_RELEASE) + ".")
		}
		repeat MAX_CHARA_SAVE
			if ( cbit(CHARA_BIT_AWAKE_NEAR_DEATH_DAMAGE, cnt) ) {
				cdata(CDATA_AP_CURRENT, cnt) += 500
			}
		loop
		if ( gdata(GDATA_DEEPEST_LEVEL) > gdata(GDATA_FLAG_MAIN) / 4 + 1 ) {
			gdata(GDATA_DEEPEST_LEVEL) = gdata(GDATA_FLAG_MAIN) / 4 + 1
		}
	}
	if ( gdata(GDATA_VERSION) <= 2550 & gdata(GDATA_VERSION) >= 2540 ) {
		repeat MAX_CHARA_SAVE
			if ( cdata(CDATA_ALLIED, cnt) == 0 ) {
				continue
			}
			tc = cnt
			repeat MAX_EQUIP_SLOT_TOTAL, CDATA_STARTING_EQUIP_SLOTS
				if ( cnt != 120 & cnt != 121 & cnt != 122 ) {
					continue
				}
				p = cdata(cnt, tc) \ EXT_EQUIP_SLOTS
				if ( p == 0 ) {
					continue
				}
				p--
				inv(INV_ITEM_EQUIP, p) = 0
				cdata(cnt, tc) = cdata(cnt, tc) / EXT_EQUIP_SLOTS * EXT_EQUIP_SLOTS
			loop
			cdata(CDATA_EQUIP_SLOT_21, tc) = 0
			cdata(CDATA_EQUIP_SLOT_22, tc) = 0
			cdata(CDATA_EQUIP_SLOT_23, tc) = 0
			r1 = tc
			gosub *charaRefresh
		loop
		tuikabui = 100
	}
	if ( gdata(GDATA_VERSION) <= 2570 & gdata(GDATA_VERSION) >= 2540 ) {
		repeat MAX_EQUIP_SLOT_TOTAL, CDATA_STARTING_EQUIP_SLOTS
			if ( cnt != 120 & cnt != 121 & cnt != 122 ) {
				continue
			}
			p = cdata(cnt, CHARA_PLAYER) \ EXT_EQUIP_SLOTS
			if ( p == 0 ) {
				continue
			}
			p--
			inv(INV_ITEM_EQUIP, p) = 0
			cdata(cnt, CHARA_PLAYER) = cdata(cnt, CHARA_PLAYER) / EXT_EQUIP_SLOTS * EXT_EQUIP_SLOTS
		loop
		cdata(CDATA_EQUIP_SLOT_21, CHARA_PLAYER) = 0
		cdata(CDATA_EQUIP_SLOT_22, CHARA_PLAYER) = 0
		cdata(CDATA_EQUIP_SLOT_23, CHARA_PLAYER) = 0
		r1 = CHARA_PLAYER
		gosub *charaRefresh
		tuikabui = 100
	}
	if ( gdata(GDATA_VERSION) < 2620 ) {
		kamen = 1000
	}
	if ( gdata(GDATA_VERSION) < 2670 ) {
		gdata(GDATA_FLAG_SUB_THE_TRUE_APPEARANCE) = 0
	}
	if ( gdata(GDATA_VERSION) == 2710 ) {
		if ( gdata(GDATA_FLAG_SUB_REGULUS_ZANAN) == 1002 ) {
			gdata(GDATA_FLAG_SUB_REGULUS_ZANAN) = 1003
		}
	}
	if ( gdata(GDATA_VERSION) < 2730 ) {
		kamen2 = 100
	}
	if ( gdata(GDATA_VERSION) < 2750 ) {
		gdata(GDATA_WORLD_RENEW) = 1
	}
	if ( gdata(GDATA_VERSION) < 2760 ) {
		adata(ADATA_ECONOMY, 85) = 0
		adata(ADATA_ECONOMY, 79) = 0
		adata(ADATA_ECONOMY, 75) = 0
		adata(ADATA_ECONOMY, 74) = 0
		adata(ADATA_ECONOMY, 73) = 0
		adata(ADATA_ECONOMY, 72) = 0
		adata(ADATA_ECONOMY, 71) = 0
		adata(ADATA_ECONOMY, 80) = 0
		adata(ADATA_ECONOMY, 81) = 0
		adata(ADATA_ECONOMY, 80) = 0
	}
	if ( gdata(GDATA_VERSION) < 2880 ) {
		gdata(STARTING_GDATA_FLAG + 327) = int(gettime(0))
	}
	if ( gdata(GDATA_VERSION) < 2990 ) {
		if ( int(gettime(1)) == 12 ) {
			if ( int(gettime(3)) <= 25 ) {
				kamen3 = 100
			}
		}
	}
	if ( gdata(GDATA_VERSION) < 3060 ) {
		repeat STARTING_RANDOM_AREA - STARTING_USER_AREA, STARTING_USER_AREA
			if ( adata(ADATA_ID, cnt) != AREA_SHOP ) {
				continue
			}
			adata(ADATA_SHOP_SALE_RESTRICTION, cnt) = 0
			adata(ADATA_SHOP_TYPE_CHANGE_COOLDOWN, cnt) = 0
		loop
	}
	if ( gdata(GDATA_VERSION) < 3080 ) {
		if ( gdata(GDATA_FLAG_GAME_MODE) == GAMEMODE_PURGE ) {
			kamen4 = 100
		}
	}
	if ( gdata(GDATA_VERSION) < 3120 ) {
		repeat MAX_CHARA_ADVENTURER, MAX_CHARA_FOLLOWER
			if ( cdata(CDATA_HIRE_DATE, cnt) != 0 ) {
				cdata(CDATA_AREA, cnt) = gdata(GDATA_AREA)
				cdata(CDATA_EXIST, cnt) = CHAR_STATE_ALIVE
			}
		loop
	}
	if ( gdata(GDATA_VERSION) < 3140 ) {
		if ( gdata(GDATA_DAY) > 31 ) {
			gdata(GDATA_DAY) = 30
		}
	}
	if ( gdata(GDATA_VERSION) < 3170 ) {
		kamen5 = 100
	}
	if ( gdata(GDATA_VERSION) < 3180 ) {
		kamen6 = 100
	}
	if ( gdata(GDATA_VERSION) != int(double("3.21") * 1000) ) {
		gdata(GDATA_WORLD_RENEW) = 1
	}
	del_chara MAX_CHARA_NC
	if ( gdata(GDATA_VERSION) > int(double("3.21") * 1000) ) {
		dialog "invalid version"
		goto *exit_game
	}
	if ( gdata(GDATA_PLAY_TIME) < 0 ) {
		gdata(GDATA_PLAY_TIME) = 0
	}
	if ( gdata(GDATA_FLAG_GAME_MODE) == GAMEMODE_LOSS ) {
		if ( gdata(GDATA_GAMEMODE_PENALTY) == 4 ) {
			dialog lang("その冒険者は蘇らない…。", "This adventurer can not be revived...")
			goto *exit_game
		}
	}
	ima = int(gettime(5)) + int(gettime(4)) * 60 + int(gettime(3)) * 24 * 60
	if ( int(gettime(1)) == gdata(STARTING_GDATA_FLAG + 350) & int(gettime(0)) == gdata(STARTING_GDATA_FLAG + 351) | gdata(STARTING_GDATA_FLAG + 349) == 0 ) {
		if ( ima >= gdata(STARTING_GDATA_FLAG + 349) + 10 ) {
			gdata(GDATA_FLAG_RARE_DROP) = 100
		}
		else {
			gdata(GDATA_FLAG_RARE_DROP) = 0
		}
	}
	else {
		if ( ima >= 1440 + 10 ) {
			gdata(GDATA_FLAG_RARE_DROP) = 100
		}
		else {
			gdata(GDATA_FLAG_RARE_DROP) = 0
		}
	}
	ima = 0
	gdata(STARTING_GDATA_FLAG + 349) = int(gettime(5)) + int(gettime(4)) * 60 + int(gettime(3)) * 24 * 60
	gdata(STARTING_GDATA_FLAG + 350) = int(gettime(1))
	gdata(STARTING_GDATA_FLAG + 351) = int(gettime(0))
	deru = 44

	/********** ORIGINAL - BEGINNING **********

	if ( gdata(GDATA_FLAG_GAME_MODE) == GAMEMODE_PURGE ) {
		gdata(GDATA_FLAG_RARE_DROP) = 100
		dbg_noautosave = 1
	}

	 ********** ORIGINAL - ENDING **********/

	/********** BLOODYSHADE CUSTOM - BEGINNING **********/ // Re-enable save-scumming.

	if ( TweakData(TWEAK_GAMEPLAY_ENABLE_SAVE_SCUMMING, TWEAK_CATEGORY_GAMEPLAY) == 1 | gdata(GDATA_FLAG_GAME_MODE) == GAMEMODE_PURGE ) {
		deru = 0
		dbg_noautosave = 1
		gdata(GDATA_FLAG_RARE_DROP) = 100
	}

	/********** BLOODYSHADE CUSTOM - ENDING **********/

	if ( gdata(GDATA_FLAG_GAME_MODE) == GAMEMODE_ABNORMAL | gdata(GDATA_FLAG_GAME_MODE) == GAMEMODE_LOSS | gdata(GDATA_FLAG_GAME_MODE) == GAMEMODE_NATURAL ) {
		if ( gdata(GDATA_GAMEMODE_PENALTY) == 0 ) {
			dialog lang("Escキーでセーブ後自動終了せずに、強制終了したセーブデータにはペナルティが与えられます。", "It is a nosave penalty.")
			modkarma CHARA_PLAYER, -100
			skillmod SKILL_ATTR_LIFE, CHARA_PLAYER, -5000
			skillmod SKILL_ATTR_MANA, CHARA_PLAYER, -5000
			cdata(CDATA_GOLD, CHARA_PLAYER) = cdata(CDATA_GOLD, CHARA_PLAYER) / 2
			cdata(CDATA_PLATINUM, CHARA_PLAYER) = cdata(CDATA_PLATINUM, CHARA_PLAYER) / 2
			addbuff 0, BUFF_PUNISHMENT, 100000, 100
		}
		if ( gdata(GDATA_GAMEMODE_PENALTY) == 1 ) {
			gdata(GDATA_GAMEMODE_PENALTY) = 0
			snd SOUNDLIST_ENC
		}
	}
	gdata(GDATA_VERSION) = int(double("3.21") * 1000)
	cbitmod CHARA_BIT_PCC, 0, 1
	gdata(GDATA_SPEEDSUM_RESET) = 1
	gosub *initial_recipe
	return

*mapReset
	gdata(GDATA_MAP_VERSION)++
	dim qdata, QDATA_MAX_SIZE, QDATA_MAX_CLIENT
	sdim qname, QNAME_MAX_SIZE, QDATA_MAX_CLIENT
	gdata(GDATA_CLIENT) = 0
	gosub *setArea
	return

*apply_gene
	file = "shop" + 3 + ".s2"
	fmode = 4
	gosub *game_ctrlFile
	pbigin = (pbigin - 250) / 7
	if ( pbigin < 5 ) {
		pbigin = 5
	}
	else {
		if ( pbigin > 50 ) {
			pbigin = 50
		}
	}
	ibigin = (ibigin - 250) / 8
	if ( ibigin < 5 ) {
		ibigin = 5
	}
	else {
		if ( ibigin > 40 ) {
			ibigin = 40
		}
	}
	cdata(CDATA_GOLD, CHARA_PLAYER) += goldbigin
	cdata(CDATA_PLATINUM, CHARA_PLAYER) += pbigin
	cdata(CDATA_SKILLPOINT, CHARA_PLAYER) += ibigin
	repeat MAX_MATERIAL_COUNT
		mat(cnt) = mat(cnt) / 3
	loop
	return

*load_gene
	fmode = 15
	gosub *game_ctrlFile
	dim spell, MAX_SPELL_COUNT
	dim spact, MAX_SPACT_COUNT
	pbigin = 0
	ibigin = 0
	repeat STARTING_SKILL_SPACT
		if ( cnt >= STARTING_SKILL_ATTR & cnt < MAX_SKILL_ATTR ) {
			pbigin += sorg(cnt, CHARA_PLAYER)
		}
		if ( cnt >= STARTING_SKILL_WEAPON & cnt < STARTING_SKILL_SPELL ) {
			ibigin += sorg(cnt, CHARA_PLAYER)
		}
	loop
	goldbigin += limit(cdata(CDATA_GOLD, CHARA_PLAYER) / 100, 1000, 100000)
	repeat MAX_CHARA_TOTAL
		cdata(CDATA_EXIST, cnt) = CHAR_STATE_DEAD
	loop
	repeat MAX_SKILL_DATA
		sdata(cnt, MAX_CHARA_NC) = sdata(cnt, CHARA_PLAYER)
		sdata(cnt, CHARA_PLAYER) = 0
	loop
	repeat MAX_CHARA_DATA
		cdata(cnt, MAX_CHARA_NC) = cdata(cnt, CHARA_PLAYER)
		cdata(cnt, CHARA_PLAYER) = 0
	loop
	inv_getheader -1
	repeat invrange, invhead
		inv(INV_ITEM_NUM, cnt) = 0
	loop
	inv_getheader 0
	repeat invrange, invhead
		if ( inv(INV_ITEM_NUM, cnt) == 0 ) {
			continue
		}
		if ( inv(INV_ITEM_ID, cnt) == ITEM_ID_SECRET_EXP_LOMIAS ) {
			lomiaseaster = 1
		}
		if ( inv(INV_ITEM_ID, cnt) == ITEM_ID_DEED_HEIRSHIP | refitem(inv(INV_ITEM_ID, cnt), DBSPEC_TYPE_MINOR) == FILTER_ITEM_DEED ) {
			continue
		}
		if ( inv(INV_ITEM_ID, cnt) == ITEM_ID_KITTY_BANK ) {
			continue
		}
		if ( inv(INV_ITEM_QUALITY, cnt) == FIX_QUALITY_UNIQUE ) {
			continue
		}
		if ( ibit(ITEM_BIT_PRECIOUS, cnt) ) {
			continue
		}
		if ( refitem(inv(INV_ITEM_ID, cnt), DBSPEC_TYPE) == FILTER_AMMO ) {
			inv(INV_ITEM_AMMO, cnt) = -1
		}
		inv(INV_ITEM_EQUIP, cnt) = 0
		item_copy cnt, inv_getfreeid(-1)
	loop
	gdata(STARTING_GDATA_FLAG + 301) = 1000
	repeat MAX_CHARA_TOTAL
		del_chara cnt
	loop
	gdata(STARTING_GDATA_FLAG + 301) = 0
	gdata(GDATA_PLAY_TIME) = genetemp(805)
	return

*generate_gene
	fmode = 14
	gosub *game_ctrlFile
	return

#deffunc zipadd str zipadd_arg1
	p = 12
	exist folder + zipadd_arg1
	len = strsize + p * 2
	lenhead = lensum
	lensum += len
	sdim ziptmp1, p
	ziptmp1 += zipadd_arg1
	sdim ziptmp2, p
	ziptmp2 += str(len)
	memexpand filebuff, lensum
	memcpy filebuff, ziptmp1, p, lenhead
	memcpy filebuff, ziptmp2, p, lenhead + p
	sdim filetemp, len - p * 2
	bload folder + zipadd_arg1, filetemp, , 0
	memcpy filebuff, filetemp, len - p * 2, lenhead + p * 2
	return

*unzip
	p = 12
	folder = exedir + "user\\"
	bload folder + file, headtemp, 1024
	gosub *dump_config_import
	exist folder + file
	zipsize = strsize
	sdim filebuff, zipsize
	bload folder + file, filebuff, zipsize
	lenhead = 1024
	repeat 10000
		sdim ziptmp1, p
		sdim ziptmp2, p
		memcpy ziptmp1, filebuff, p, 0, lenhead
		memcpy ziptmp2, filebuff, p, 0, lenhead + p
		len = int(ziptmp2)
		sdim filetemp, len - p * 2
		memcpy filetemp, filebuff, len - p * 2, 0, lenhead + p * 2
		bsave folder + ziptmp1, filetemp
		lenhead += len
		if ( lenhead >= zipsize ) {
			break
		}
	loop
	return

#deffunc zipinit2 str zipinit2_arg1, str zipinit2_arg2
	locvar_zipinit2_lensum = 0
	locvar_zipinit2_zipfolder = zipinit2_arg1
	locvar_zipinit2_zipfinalfile = zipinit2_arg2
	sdim locvar_zipinit2_filebuff
	return

#deffunc zipadd2 str zipadd2_arg1
	locvar_zipadd2_p = 50, 40, 10
	exist locvar_zipinit2_zipfolder + zipadd2_arg1
	locvar_zipadd2_len = strsize + locvar_zipadd2_p
	locvar_zipadd2_lenhead = locvar_zipinit2_lensum
	locvar_zipinit2_lensum += locvar_zipadd2_len
	sdim locvar_zipadd2_ziptmp1, locvar_zipadd2_p(1)
	locvar_zipadd2_ziptmp1 += zipadd2_arg1
	sdim locvar_zipadd2_ziptmp2, locvar_zipadd2_p(2)
	locvar_zipadd2_ziptmp2 += str(locvar_zipadd2_len)
	memexpand locvar_zipinit2_filebuff, locvar_zipinit2_lensum
	memcpy locvar_zipinit2_filebuff, locvar_zipadd2_ziptmp1, locvar_zipadd2_p(1), locvar_zipadd2_lenhead
	memcpy locvar_zipinit2_filebuff, locvar_zipadd2_ziptmp2, locvar_zipadd2_p(2), locvar_zipadd2_lenhead + locvar_zipadd2_p(1)
	sdim locvar_zipadd2_filetemp, locvar_zipadd2_len - locvar_zipadd2_p
	bload locvar_zipinit2_zipfolder + zipadd2_arg1, locvar_zipadd2_filetemp, , 0
	memcpy locvar_zipinit2_filebuff, locvar_zipadd2_filetemp, locvar_zipadd2_len - locvar_zipadd2_p, locvar_zipadd2_lenhead + locvar_zipadd2_p
	return

#deffunc zipend2
	bsave locvar_zipinit2_zipfolder + locvar_zipinit2_zipfinalfile, locvar_zipinit2_filebuff
	return

#deffunc unzip2 str unzip2_arg1, str unzip2_arg2
	locvar_zipadd2_p = 50, 40, 10
	exist unzip2_arg1 + unzip2_arg2
	locvar_unzip2_zipsize = strsize
	sdim locvar_zipinit2_filebuff, locvar_unzip2_zipsize
	bload unzip2_arg1 + unzip2_arg2, locvar_zipinit2_filebuff, locvar_unzip2_zipsize
	locvar_zipadd2_lenhead = 0
	repeat 10000
		sdim locvar_zipadd2_ziptmp1, locvar_zipadd2_p(1)
		sdim locvar_zipadd2_ziptmp2, locvar_zipadd2_p(2)
		memcpy locvar_zipadd2_ziptmp1, locvar_zipinit2_filebuff, locvar_zipadd2_p(1), 0, locvar_zipadd2_lenhead
		memcpy locvar_zipadd2_ziptmp2, locvar_zipinit2_filebuff, locvar_zipadd2_p(2), 0, locvar_zipadd2_lenhead + locvar_zipadd2_p(1)
		locvar_zipadd2_len = int(locvar_zipadd2_ziptmp2)
		if ( locvar_zipadd2_len == 0 ) {
			break
		}
		sdim locvar_zipadd2_filetemp, locvar_zipadd2_len - locvar_zipadd2_p
		memcpy locvar_zipadd2_filetemp, locvar_zipinit2_filebuff, locvar_zipadd2_len - locvar_zipadd2_p, 0, locvar_zipadd2_lenhead + locvar_zipadd2_p
		bsave unzip2_arg1 + locvar_zipadd2_ziptmp1, locvar_zipadd2_filetemp
		locvar_zipadd2_lenhead += locvar_zipadd2_len
		if ( locvar_zipadd2_lenhead >= locvar_unzip2_zipsize ) {
			break
		}
	loop
	return

#defcfunc getnpctxt str getnpctxt_arg1, str getnpctxt_arg2
	locvar_getnpctxt_p = instr(txtbuff, 0, getnpctxt_arg1)
	if ( locvar_getnpctxt_p == (-1) ) {
		return getnpctxt_arg2
	}
	locvar_getnpctxt_p += instr(txtbuff, locvar_getnpctxt_p, "\"")
	if ( locvar_getnpctxt_p == (-1) ) {
		return getnpctxt_arg2
	}
	return strmid(txtbuff, locvar_getnpctxt_p + 1, limit(instr(txtbuff, locvar_getnpctxt_p + 1, "\""), 0, 70))

#deffunc cnvvar var cnvvar_arg1, str cnvvar_arg2
	locvar_cnvvar_ref = cnvvar_arg2
	locvar_getnpctxt_p = 0
	repeat
		getstr cnvvar_arg1(cnt), locvar_cnvvar_ref, locvar_getnpctxt_p, 44
		if ( cnvvar_arg1 == "" ) {
			break
		}
		locvar_getnpctxt_p += strsize
	loop
	return

*set_userNpc
	if ( initunid ) {
		cdata(CDATA_USERNPC_ID, rc) = initunid - 1
		initunid = 0
	}
	cun = cdata(CDATA_USERNPC_ID, rc)
	cdata(CDATA_ID, rc) = CREATURE_ID_USER
	if ( initlv != 0 ) {
		cdata(CDATA_LEVEL, rc) = initlv
	}
	else {
		cdata(CDATA_LEVEL, rc) = limit(userdata(2, cun), 1, 350)
	}
	if ( cdata(CDATA_LEVEL, rc) > gdata(GDATA_DEEPEST_LEVEL) * 2 ) {
		cdata(CDATA_LEVEL, rc) = limit(gdata(GDATA_DEEPEST_LEVEL) * 2, 1, 350)
	}
	cdata(CDATA_PORTRAIT, rc) = -1
	creaturepack = FILTER_NOTHING
	cdata(CDATA_ACT_INDEX, rc) = 55
	cdata(CDATA_AI_SUB, rc) = unaiactsubfreq(cun)
	repeat 5
		cdata(STARTING_CDATA_ACT_MAIN + cnt, rc) = userdata(15 + cnt, cun)
		cdata(STARTING_CDATA_ACT_SUB + cnt, rc) = userdata(20 + cnt, cun)
	loop
	if ( userdatan(5, cun) != "" ) {
		sdim unres, 6, 32
		csvstr2 unres, userdatan(5, cun)
		repeat
			if ( cnt > 15 | unres(cnt) == "" ) {
				break
			}
			sdata(int(unres(cnt * 2)), rc) += int(unres(cnt * 2 + 1)) * 50
		loop
	}
	cdata(CDATA_TXT, rc) = 1
	cdata(CDATA_ALIGNMENT, rc) = -10000
	cdatan(CDATAN_NAME, rc) = userdatan(1, cun)
	cdatan(CDATAN_USER_NPC_TAG, rc) = userdatan(0, cun)
	cdata(CDATA_RELATION, rc) = limit(userdata(4, cun), -3, 10)
	cdata(CDATA_AI_CALM, rc) = limit(userdata(7, cun), 1, 4)
	cdata(CDATA_AI_MOVE_FREQ, rc) = limit(userdata(8, cun), 0, 100)
	cdata(CDATA_AI_DISTANCE, rc) = limit(userdata(9, cun), 1, 100)
	if ( userdata(11, cun) ) {
		cdata(CDATA_ELEMENT, rc) = limit(userdata(11, cun), 50 * 100000, 68 * 100000)
	}
	cdata(CDATA_ACT_HEAL, rc) = userdata(10, cun)
	dbidn = userdatan(2, cun)
	dbmode = DBMODE_SET
	gosub *db_race
	dbidn = userdatan(3, cun)
	dbmode = DBMODE_SET
	gosub *db_class
	cdata(CDATA_SEX, rc) = userdata(3, cun)
	if ( userdata(3, cun) != 0 ) {
		if ( userdata(3, cun) != 1 ) {
			cdata(CDATA_SEX, rc) = rnd(2)
		}
	}
	if ( userdata(5, cun) ) {
		fixlv = limit(userdata(5, cun), FIX_QUALITY_NONE, FIX_QUALITY_UNIQUE)
	}
	cspecialeq = 0
	cdata(CDATA_RELATION_ORG, rc) = cdata(CDATA_RELATION, rc)
	fixaiact rc
	setunid rc, cun
	return

*userNpc_update
	procid = (procid + 1) \ 4
	proclist(procid) = "userNpc_update" + " ct:" + ct
	dirlist buff, exedir + "user\\*.npc"
	notesel buff
	usernpcmax = noteinfo(0)
	if ( usernpcmax >= 240 ) {
		usernpcmax = 240
	}
	dim userdata, 70, usernpcmax + 1
	sdim userdatan, 40, 15, usernpcmax + 1
	sdim usertxt, 80 * 100, usernpcmax + 1
	sdim untaglist
	gdata(GDATA_USERNPC_COUNT) = 0
	buffer 5, 33 * 48, (34 + (usernpcmax / 33 + 1) * 2) * 48
	pos 0, 0
	picload exedir + "\\graphic\\character" + devfile + ".bmp", 1
	gmode 0
	fread = 1
	procid = (procid + 1) \ 4
	proclist(procid) = "userNpc_update:1" + " ct:" + ct
	sortnote buff, 1
	tg = 0
	repeat usernpcmax
		procid = (procid + 1) \ 4
		proclist(procid) = "userNpc_update:2" + " ct:" + ct
		noteget s, cnt
		cnt2 = tg
		unzip2 exedir + "user\\", s
		procid = (procid + 1) \ 4
		proclist(procid) = "userNpc_update:2a" + " ct:" + ct
		if ( fread == 0 ) {
			zOpen hgz, exedir + "user\\npc1.t", 1, 3
			zWrite userdata(0, tg), hgz, 70 * 4
			zClose hgz
		}
		else {
			zOpen hgz, exedir + "user\\npc1.t", 0
			zRead userdata(0, tg), hgz, 70 * 4
			zClose hgz
		}
		dim bmpbuff, userdata(0, tg)
		sdim txtbuff, userdata(1, tg)
		procid = (procid + 1) \ 4
		proclist(procid) = "userNpc_update:2c" + " ct:" + ct
		if ( fread == 0 ) {
			zOpen hgz, exedir + "user\\npc2.t", 1, 3
			zWrite bmpbuff, hgz, userdata(0, tg)
			zClose hgz
		}
		else {
			zOpen hgz, exedir + "user\\npc2.t", 0
			zRead bmpbuff, hgz, userdata(0, tg)
			zClose hgz
		}
		procid = (procid + 1) \ 4
		proclist(procid) = "userNpc_update:2d" + " ct:" + ct
		if ( fread == 0 ) {
			zOpen hgz, exedir + "user\\npc3.t", 1, 3
			zWrite txtbuff, hgz, userdata(1, tg)
			zClose hgz
		}
		else {
			zOpen hgz, exedir + "user\\npc3.t", 0
			zRead txtbuff, hgz, userdata(1, tg)
			zClose hgz
		}
		procid = (procid + 1) \ 4
		proclist(procid) = "userNpc_update:2e" + " ct:" + ct
		s = getnpctxt("name.", "unknown,unknown")
		csvstr2 s, s
		userdatan(0, tg) = s
		userdatan(1, tg) = s(jp)
		noteget s, cnt
		userdatan(6, tg) = s
		if ( instr(untaglist, 0, "/" + userdatan(0, tg) + "/") != (-1) ) {
			usernpcmax--
			if ( instr(s, 0, "_tmp_") == (-1) ) {
				msgtemp += lang("同名NPCは読み込まれない。", "A npc of the same name exists.") + "(skipped:" + userdatan(0, tg) + "," + s + ") "
			}
			continue
		}
		untaglist += "/" + userdatan(0, tg) + "/"
		if ( instr(s, 0, "_tmp_") != (-1) ) {
			gdata(GDATA_USERNPC_COUNT)++
		}
		procid = (procid + 1) \ 4
		proclist(procid) = "userNpc_update:set info" + " ct:" + ct
		userdatan(2, tg) = getnpctxt("race.", "slime")
		userdatan(3, tg) = getnpctxt("class.", "tourist")
		userdatan(4, tg) = getnpctxt("filter.", "")
		userdatan(5, tg) = getnpctxt("resist.", "")
		s = getnpctxt("meleeElem.", "0,0")
		csvstr2 s, s
		userdata(11, tg) = int(s) * 100000 + int(s(1))
		procid = (procid + 1) \ 4
		proclist(procid) = "userNpc_update:set bits" + " ct:" + ct
		s = getnpctxt("bitOn.", "0,0")
		csvstr2 s, s
		repeat
			p = int(s(cnt))
			if ( cnt > 20 | p == 0 ) {
				break
			}
			HMMBITON userdata(40 + p / 32, cnt2), p \ 32
		loop
		procid = (procid + 1) \ 4
		proclist(procid) = "userNpc_update:set actions" + " ct:" + ct
		s = getnpctxt("aiAct.", "0,0,0,0,0")
		csvstr2 s, s
		repeat 5
			userdata(15 + cnt, cnt2) = int(s(cnt))
		loop
		s = getnpctxt("aiActSub.", "0,0,0,0,0")
		csvstr2 s, s
		repeat 5
			userdata(20 + cnt, cnt2) = int(s(cnt))
		loop
		procid = (procid + 1) \ 4
		proclist(procid) = "userNpc_update:set ref" + " ct:" + ct
		userdata(12, tg) = int(getnpctxt("select.", "0"))
		userdata(2, tg) = int(getnpctxt("level.", "1"))
		userdata(3, tg) = int(getnpctxt("sex.", "-1"))
		userdata(4, tg) = int(getnpctxt("relation.", "-1"))
		userdata(5, tg) = int(getnpctxt("fixLv.", "0"))
		userdata(6, tg) = int(getnpctxt("rare.", "0"))
		userdata(7, tg) = int(getnpctxt("aiCalm.", "1"))
		userdata(8, tg) = int(getnpctxt("aiMove.", "50"))
		userdata(9, tg) = int(getnpctxt("aiDist.", "1"))
		userdata(10, tg) = int(getnpctxt("aiHeal.", "0"))
		unaiactsubfreq(tg) = int(getnpctxt("aiActSubFreq.", "0"))
		p = instr(txtbuff, 0, "%txt")
		txtbuff = strmid(txtbuff, p, instr(txtbuff, 0, "%endTxt") - p)
		usertxt(tg) = strmid(txtbuff, 0, 80 * 100 - 2)
		procid = (procid + 1) \ 4
		proclist(procid) = "userNpc_update:2.1" + " ct:" + ct
		gsel 9
		memfile bmpbuff
		picload "MEM:temp.bmp"
		if ( ginfo(13) > 50 ) {
			chipc(CHIPC_X, SPRITE_SHEET_COLS_CHARA * SPRITE_SHEET_ROWS_CHARA + tg) = tg \ SPRITE_SHEET_COLS_CHARA * inf_tiles, SPRITE_SHEET_ROWS_CHARA * inf_tiles + tg / SPRITE_SHEET_COLS_CHARA * inf_tiles * 2, inf_tiles, inf_tiles * 2, inf_tiles + 8
		}
		else {
			chipc(CHIPC_X, SPRITE_SHEET_COLS_CHARA * SPRITE_SHEET_ROWS_CHARA + tg) = tg \ SPRITE_SHEET_COLS_CHARA * inf_tiles, SPRITE_SHEET_ROWS_CHARA * inf_tiles + tg / SPRITE_SHEET_COLS_CHARA * inf_tiles * 2, inf_tiles, inf_tiles, 16
		}
		gsel 5
		pos tg \ SPRITE_SHEET_COLS_CHARA * 48, SPRITE_SHEET_ROWS_CHARA * 48 + tg / SPRITE_SHEET_COLS_CHARA * 96
		gcopy 9, 0, 0, 48, 96
		tg++
	loop
	procid = (procid + 1) \ 4
	proclist(procid) = "userNpc_update:3" + " ct:" + ct
	gosub *del_userTemp
	gosub *del_userNpc
	procid = (procid + 1) \ 4
	proclist(procid) = "userNpc_update:Replace bmp" + " ct:" + ct
	gsel 5
	folder = exedir + "user\\graphic\\"
	dirlist buff, folder + "chara_*.bmp"
	notesel buff
	repeat stat
		noteget file, cnt
		p = int(strmid(file, 6, instr(file, 6, ".")))
		pos p \ 33 * inf_tiles, p / 33 * inf_tiles
		picload folder + file, 1
	loop
	gsel 0
	gsel 5
	folder = exedir + "user\\graphic\\"
	dirlist buff, folder + "Pic_*.bmp"
	notesel buff
	repeat stat
		noteget file, cnt
		p = int(strmid(file, 4, instr(file, 4, "."))) + 692
		pos p \ 33 * inf_tiles, p / 33 * inf_tiles
		picload folder + file, 1
	loop
	gsel 0
	gsel 1
	folder = exedir + "user\\item\\"
	dirlist buff, folder + "plan*.bmp"
	notesel buff
	repeat stat
		noteget file, cnt
		p = int(strmid(file, 4, instr(file, 4, "."))) + 890
		pos p \ 33 * inf_tiles, p / 33 * inf_tiles
		picload folder + file, 1
	loop
	gsel 0
	gsel 1
	folder = exedir + "user\\graphic\\"
	dirlist buff, folder + "item_*.bmp"
	notesel buff
	repeat stat
		noteget file, cnt
		p = int(strmid(file, 5, instr(file, 5, ".")))
		pos p \ 33 * inf_tiles, p / 33 * inf_tiles
		picload folder + file, 1
	loop
	gsel 0
	return

*user_npc
	fread = 0
	cun = usernpcmax
	txt lang("どのファイルからNPCを作成する？", "Choose the original file.")
	redraw 1
	fileext = "txt"
	filedsc = "Custom Npc Text"
	_fdialog fileext, 16, filedsc, exedir + "user", ""
	if ( stat == 0 ) {
		return
	}
	txtfile = refstr
	exist txtfile
	userdata(1, cun) = strsize
	sdim txtbuff, strsize
	bload txtfile, txtbuff
	if ( instr(txtbuff, 0, "%Elona Custom Npc") == (-1) ) {
		txt "Invalid File. Aborting."
		return
	}
	txt lang("どの画像を埋め込む？", "Choose the graphic file.")
	redraw 1
	fileext = "bmp"
	filedsc = "Bit Map File"
	_fdialog fileext, 16, filedsc, exedir + "user", ""
	if ( stat == 0 ) {
		return
	}
	bmpfile = refstr
	exist bmpfile
	if ( strsize > 30000 ) {
		txt "The file size must be lower than 30KB. Aborting."
		return
	}
	userdata(0, cun) = strsize
	dim bmpbuff, strsize
	bload bmpfile, bmpbuff
	if ( fread == 0 ) {
		zOpen hgz, exedir + "user\\npc1.t", 1, 3
		zWrite userdata(0, cun), hgz, 70 * 4
		zClose hgz
	}
	else {
		zOpen hgz, exedir + "user\\npc1.t", 0
		zRead userdata(0, cun), hgz, 70 * 4
		zClose hgz
	}
	if ( fread == 0 ) {
		zOpen hgz, exedir + "user\\npc2.t", 1, 3
		zWrite bmpbuff, hgz, userdata(0, cun)
		zClose hgz
	}
	else {
		zOpen hgz, exedir + "user\\npc2.t", 0
		zRead bmpbuff, hgz, userdata(0, cun)
		zClose hgz
	}
	if ( fread == 0 ) {
		zOpen hgz, exedir + "user\\npc3.t", 1, 3
		zWrite txtbuff, hgz, userdata(1, cun)
		zClose hgz
	}
	else {
		zOpen hgz, exedir + "user\\npc3.t", 0
		zRead txtbuff, hgz, userdata(1, cun)
		zClose hgz
	}
	s = getnpctxt("name.", "unknown,unknown")
	csvstr2 s, s
	cnv_filestr s
	if ( instr(s, 0, "_tmp_") != (-1) ) {
		dialog "The name contains an invalid word \"_tmp_\""
		return
	}
	if ( peek(s) < 65 | peek(s) > 90 & (peek(s) < 97 | peek(s) > 122) ) {
		dialog "The first letter of the name must be alphabetic."
		return
	}
	if ( strlen(s) >= 32 | strlen(s(1)) >= 32 ) {
		dialog "The name is too long."
		return
	}
	zipinit2 exedir + "user\\", s + ".npc"
	zipadd2 "npc1.t"
	zipadd2 "npc2.t"
	zipadd2 "npc3.t"
	zipend2
	q = s
	gosub *userNpc_update
	initunid = findunid(q)
	txt lang("カスタムNPCを作成した！", "A custom NPC has been successfully generated!")
	if ( cdata(CDATA_X, CHARA_PLAYER) > 1 ) {
		sux = cdata(CDATA_X, CHARA_PLAYER) - 1
	}
	flt
	characreate -1, CREATURE_ID_USER, sux, cdata(CDATA_Y, CHARA_PLAYER)
	repeat MAX_CHARA_TOTAL
		if ( cdata(CDATA_ID, cnt) == CREATURE_ID_USER ) {
			getunid cnt
		}
	loop
	cdata(CDATA_RELATION, rc) = -3
	txt lang(name(rc) + "は興奮して襲い掛かってきた。", name(rc) + " is excited and attacks you.")
	folder = exedir + "user\\"
	gosub *del_userTemp
	return

*game_ctrlFile
	notesel filemod
	if ( timeGetTime() / 1000 - time_begin < 0 ) {
		time_begin = timeGetTime() / 1000
	}
	gdata(GDATA_PLAY_TIME) = gdata(GDATA_PLAY_TIME) + timeGetTime() / 1000 - time_begin
	time_begin = timeGetTime() / 1000
	if ( fmode == 8 | fmode == 7 ) {
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile:game" + fread + " ct:" + ct
		folder = exedir + "save\\" + playerid + "\\"
		if ( fmode == 8 ) {
			fread = 0
		}
		if ( fmode == 7 ) {
			fread = 1
		}
		if ( fmode == 8 ) {
			playerheader = "" + cdatan(CDATAN_NAME, CHARA_PLAYER) + " Lv:" + cdata(CDATA_LEVEL, CHARA_PLAYER) + " " + mdatan(MDATAN_NAME)
			bsave folder + "header.txt", playerheader
		}

		/********** ORIGINAL - BEGINNING **********

		repeat 16

		 ********** ORIGINAL - ENDING **********/

		/********** ANNA CUSTOM - BEGINNING **********/

		repeat 19

		/********** ANNA CUSTOM - ENDING **********/

			procid = (procid + 1) \ 4
			proclist(procid) = "ctrlFile:game" + fread + ":" + cnt + " ct:" + ct
			file = folder
			if ( cnt == 0 ) {
				file += "gdata.s1"
				fsize = 1000 * 4
			}
			if ( cnt == 1 ) {
				file += "cdata.s1"
				fsize = 114000
			}
			if ( cnt == 2 ) {
				file += "sdata.s1"
				fsize = 273600
			}
			if ( cnt == 3 ) {
				file += "spell.s1"
				fsize = 800
			}
			if ( cnt == 4 ) {
				file += "inv.s1"
				fsize = 369600
			}
			if ( cnt == 5 ) {
				file += "kitem.s1"
				fsize = 14388
			}
			if ( cnt == 6 ) {
				file += "knpc.s1"
				fsize = 9592
			}
			if ( cnt == 7 ) {
				file += "adata.s1"
				fsize = 80000
			}
			if ( cnt == 8 ) {
				file += "spact.s1"
				fsize = 2000
			}
			if ( cnt == 9 ) {
				file += "qdata.s1"
				fsize = 40000
			}
			if ( cnt == 10 ) {
				file += "mat.s1"
				fsize = 1600
			}
			if ( cnt == 11 ) {
				file += "trait.s1"
				fsize = 2000
			}
			if ( cnt == 12 ) {
				file += "pcc.s1"
				fsize = 2400
			}
			if ( cnt == 13 ) {
				file += "card.s1"
				fsize = 16000
			}
			if ( cnt == 14 ) {
				file += "krecipe.s1"
				fsize = 6396
			}
			if ( cnt == 15 ) {
				file += "spells.s1"
				fsize = 800
			}

			/********** ORIGINAL - BEGINNING **********

			if ( cnt != 14 | gdata(GDATA_VERSION) >= 1200 ) {
				if ( fread == 1 ) {
					exist file
					if ( strsize == (-1) ) {
						if ( cnt != 15 ) {
							dialog lang("セーブファイル：" + file + "が存在しません。ファイル移植ミスの可能性があるので該当フォルダ内を確認してください。", "Save file: " + file + " does not exist. Please check the appropriate folder.")
							goto *exit_game
						}
					}
				}
			}

			 ********** ORIGINAL - ENDING **********/

			/********** ANNA CUSTOM - BEGINNING **********/

			if ( cnt == 16 ) {
				file += "aidata.s1"
				fsize = 7500
			}
			if ( cnt == 17 ) {
				file += "tweaks.s1"
				fsize = 2000
			}
			if ( cnt == 18 ) {
				file += "customval.s1"
				fsize = 1200000
			}
			if ( (cnt != 14 | gdata(GDATA_VERSION) >= 1200) & cnt != 16 & cnt != 17 & cnt != 18 ) {
				if ( fread == 1 ) {
					exist file
					if ( strsize == (-1) ) {
						if ( cnt != 15 ) {
							dialog lang("セーブファイル：" + file + "が存在しません。ファイル移植ミスの可能性があるので該当フォルダ内を確認してください。", "Save file: " + file + " does not exist. Please check the appropriate folder.")
							goto *exit_game
						}
					}
				}
			} /********** ANNA CUSTOM - ENDING **********/
			else {
				if ( fread == 1 ) {
					exist file
					if ( strsize == (-1) ) {
						continue
					}
				}
			}
			if ( fread == 0 ) {
				zOpen hgz, file, 1, 3
			}
			if ( cnt != 14 | gdata(GDATA_VERSION) >= 1200 ) {
				if ( fread == 1 ) {
					zOpen hgz, file, 0
					if ( stat != 0 ) {
						if ( cnt != 15 ) {
							dialog lang("セーブファイル：" + file + "が読み込めませんでした。該当のファイルが破損している可能性があります。", "Save file: " + file + " could not be read. There is a possibility that the file in question is corrupted.")
							goto *exit_game
						}
					}
				}
			}
			else {
				if ( fread == 1 ) {
					zOpen hgz, file, 0
				}
			}
			if ( cnt == 0 ) {
				if ( fread == 0 ) {
					zWrite gdata, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead gdata, hgz, fsize
				}
			}
			if ( cnt == 1 ) {
				if ( fread == 0 ) {
					zWrite cdata, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead cdata, hgz, fsize
				}
			}
			if ( cnt == 2 ) {
				if ( fread == 0 ) {
					zWrite sdata, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead sdata, hgz, fsize
				}
			}
			if ( cnt == 3 ) {
				if ( fread == 0 ) {
					zWrite spell, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead spell, hgz, fsize
				}
			}
			if ( cnt == 4 ) {
				if ( fread == 0 ) {
					zWrite inv, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead inv, hgz, fsize
				}
			}
			if ( cnt == 5 ) {
				if ( fread == 0 ) {
					zWrite itemmemory, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead itemmemory, hgz, fsize
				}
			}
			if ( cnt == 6 ) {
				if ( fread == 0 ) {
					zWrite npcmemory, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead npcmemory, hgz, fsize
				}
			}
			if ( cnt == 7 ) {
				if ( fread == 0 ) {
					zWrite adata, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead adata, hgz, fsize
				}
			}
			if ( cnt == 8 ) {
				if ( fread == 0 ) {
					zWrite spact, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead spact, hgz, fsize
				}
			}
			if ( cnt == 9 ) {
				if ( fread == 0 ) {
					zWrite qdata, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead qdata, hgz, fsize
				}
			}
			if ( cnt == 10 ) {
				if ( fread == 0 ) {
					zWrite mat, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead mat, hgz, fsize
				}
			}
			if ( cnt == 11 ) {
				if ( fread == 0 ) {
					zWrite trait, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead trait, hgz, fsize
				}
			}
			if ( cnt == 12 ) {
				if ( fread == 0 ) {
					zWrite pcc, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead pcc, hgz, fsize
				}
			}
			if ( cnt == 13 ) {
				if ( fread == 0 ) {
					zWrite card, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead card, hgz, fsize
				}
			}
			if ( cnt == 14 ) {
				if ( fread == 0 ) {
					zWrite recipememory, hgz, fsize
				}
				if ( fread == 1 ) {
					if ( gdata(GDATA_VERSION) >= 1200 ) {
						zRead recipememory, hgz, fsize
					}
				}
			}
			if ( cnt == 15 ) {
				if ( fread == 0 ) {
					zWrite spells, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead spells, hgz, fsize
				}
			}

			/********** ANNA CUSTOM - BEGINNING **********/

			if ( cnt == 16 ) {
				if ( fread == 0 ) {
					zWrite AIData, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead AIData, hgz, fsize
				}
			}
			if ( cnt == 17 ) {
				if ( fread == 0 ) {
					zWrite TweakData, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead TweakData, hgz, fsize
				}
			}
			if ( cnt == 18 ) {
				if ( fread == 0 ) {
					zWrite CustomVal, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead CustomVal, hgz, fsize
				}
			}

			/********** ANNA CUSTOM - ENDING **********/

			zClose hgz
		loop
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile:game" + fread + ":logs" + " ct:" + ct
		file = folder + "art.log"
		notesel artifactlocation
		if ( fread == 0 ) {
			notesave file
		}
		if ( fread == 1 ) {
			noteload file
		}
		file = folder + "news.log"
		notesel newsbuff
		if ( fread == 0 ) {
			notesave file
		}
		if ( fread == 1 ) {
			noteload file
		}
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile:game" + fread + ":array" + " ct:" + ct
		file = folder + "cdatan.s1"
		fmode = "cdatan1"
		arrayfile
		file = folder + "qname.s1"
		fmode = "qname"
		arrayfile
		file = folder + "gdatan.s1"
		fmode = "gdatan"
		arrayfile
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile:game" + fread + ":evs" + " ct:" + ct
		if ( fread == 0 ) {
			bsave folder + "evnum.s1", evnum
			bsave folder + "evdata1.s1", evdata1
			bsave folder + "evdata2.s1", evdata2
			bsave folder + "evlist.s1", evlist
		}
		else {
			exist folder + "evnum.s1"
			if ( strsize != (-1) ) {
				bload folder + "evnum.s1", evnum
			}
			exist folder + "evdata1.s1"
			if ( strsize != (-1) ) {
				bload folder + "evdata1.s1", evdata1
			}
			exist folder + "evdata2.s1"
			if ( strsize != (-1) ) {
				bload folder + "evdata2.s1", evdata2
			}
			exist folder + "evlist.s1"
			if ( strsize != (-1) ) {
				bload folder + "evlist.s1", evlist
			}
		}
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile:game" + fread + ":end" + " ct:" + ct
	}
	if ( fmode == 14 | fmode == 15 ) {
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile" + fmode + " ct:" + ct
		if ( fmode == 14 ) {
			fread = 0
			folder = exedir + "tmp\\"
		}
		if ( fmode == 15 ) {
			fread = 1
			folder = exedir + "save\\" + geneuse + "\\"
		}
		if ( fmode == 14 ) {
			playerheader = "" + cdatan(CDATAN_NAME, CHARA_PLAYER) + "(Lv" + cdata(CDATA_LEVEL, CHARA_PLAYER) + ")" + lang("の遺伝子", "'s Gene")
			file = folder + "gene_header.txt"
			bsave file, playerheader
			fileadd file
		}
		repeat 9
			file = folder
			if ( cnt == 0 ) {
				file += "gene.s1"
				fsize = 100 * 4
			}
			if ( cnt == 1 ) {
				file += "g_cdata.s1"
				fsize = 114000
			}
			if ( cnt == 2 ) {
				file += "g_sdata.s1"
				fsize = 273600
			}
			if ( cnt == 3 ) {
				file += "g_spell.s1"
				fsize = 800
			}
			if ( cnt == 4 ) {
				file += "g_inv.s1"
				fsize = 369600
			}
			if ( cnt == 5 ) {
				file += "g_spact.s1"
				fsize = 2000
			}
			if ( cnt == 6 ) {
				file += "g_mat.s1"
				fsize = 1600
			}
			if ( cnt == 7 ) {
				file += "g_card.s1"
				fsize = 16000
			}
			if ( cnt == 8 ) {
				file += "g_genetemp.s1"
				fsize = 4000
			}
			if ( fread == 1 ) {
				exist file
				if ( strsize == (-1) ) {
					continue
				}
			}
			if ( fread == 0 ) {
				zOpen hgz, file, 1, 3
				fileadd "" + file
			}
			if ( fread == 1 ) {
				zOpen hgz, file, 0
			}
			if ( cnt == 1 ) {
				if ( fread == 0 ) {
					zWrite cdata, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead cdata, hgz, fsize
				}
			}
			if ( cnt == 2 ) {
				if ( fread == 0 ) {
					zWrite sdata, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead sdata, hgz, fsize
				}
			}
			if ( cnt == 3 ) {
				if ( fread == 0 ) {
					zWrite spell, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead spell, hgz, fsize
				}
			}
			if ( cnt == 4 ) {
				if ( fread == 0 ) {
					zWrite inv, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead inv, hgz, fsize
				}
			}
			if ( cnt == 5 ) {
				if ( fread == 0 ) {
					zWrite spact, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead spact, hgz, fsize
				}
			}
			if ( cnt == 6 ) {
				if ( fread == 0 ) {
					zWrite mat, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead mat, hgz, fsize
				}
			}
			if ( cnt == 7 ) {
				if ( fread == 0 ) {
					zWrite card, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead card, hgz, fsize
				}
			}
			if ( cnt == 8 ) {
				if ( fread == 0 ) {
					zWrite gdata, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead genetemp, hgz, fsize
				}
			}
			zClose hgz
		loop
	}
	if ( fmode == 2 | fmode == 1 ) {
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile" + fmode + " ct:" + ct
		folder = exedir + "tmp\\"
		if ( fmode == 2 ) {
			fread = 0
		}
		if ( fmode == 1 ) {
			fread = 1
		}
		repeat 5
			file = folder
			if ( cnt == 0 ) {
				file += "mdata_" + mid + ".s2"
				fsize = 400
			}
			if ( cnt == 1 ) {
				if ( fread == 1 ) {
					dim map, mdata(MDATA_WIDTH), mdata(MDATA_HEIGHT), 10
					dim mapsync, mdata(MDATA_WIDTH), mdata(MDATA_HEIGHT)
					dim mef, 9, 200
				}
				file += "map_" + mid + ".s2"
				fsize = mdata(MDATA_WIDTH) * mdata(MDATA_HEIGHT) * 10 * 4
			}
			if ( cnt == 2 ) {
				file += "cdata_" + mid + ".s2"
				fsize = 376000
			}
			if ( cnt == 3 ) {
				file += "sdata_" + mid + ".s2"
				fsize = 902400
			}
			if ( cnt == 4 ) {
				if ( fread ) {
					if ( mdata(MDATA_VERSION_FIX1) == 0 ) {
						repeat mdata(MDATA_HEIGHT)
							cnt2 = cnt
							repeat mdata(MDATA_WIDTH)
								map(cnt, cnt2, 8) = 0
							loop
						loop
						mdata(MDATA_VERSION_FIX1) = 1
						continue
					}
				}
				file += "mef_" + mid + ".s2"
				fsize = 7200
			}
			if ( fread == 0 ) {
				zOpen hgz, file, 1, 3
				fileadd "" + file
			}
			if ( fread == 1 ) {
				zopenwrapper hgz, file, 0
			}
			if ( cnt == 0 ) {
				if ( fread == 0 ) {
					zWrite mdata, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead mdata, hgz, fsize
				}
			}
			if ( cnt == 1 ) {
				if ( fread == 0 ) {
					zWrite map, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead map, hgz, fsize
				}
			}
			if ( cnt == 2 ) {
				if ( fread == 0 ) {
					zWrite cdata(CDATA_EXIST, MAX_CHARA_SAVE), hgz, fsize
				}
				if ( fread == 1 ) {
					zRead cdata(CDATA_EXIST, MAX_CHARA_SAVE), hgz, fsize
				}
			}
			if ( cnt == 3 ) {
				if ( fread == 0 ) {
					zWrite sdata(SKILL_NONE, MAX_CHARA_SAVE), hgz, fsize
				}
				if ( fread == 1 ) {
					zRead sdata(SKILL_NONE, MAX_CHARA_SAVE), hgz, fsize
				}
			}
			if ( cnt == 4 ) {
				if ( fread == 0 ) {
					zWrite mef, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead mef, hgz, fsize
				}
			}
			zClose hgz
		loop
		file = folder + "cdatan_" + mid + ".s2"
		fmode = "cdatan2"
		arrayfilewrapper
		file = folder + "mdatan_" + mid + ".s2"
		fmode = "mdatan"
		arrayfilewrapper
	}
	if ( fmode == 20 | fmode == 19 ) {
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile" + fmode + " ct:" + ct
		folder = exedir + "user\\"
		if ( fmode == 20 ) {
			fread = 0
		}
		if ( fmode == 19 ) {
			fread = 1
		}
		repeat 3
			file = folder
			if ( cnt == 0 ) {
				file += "m1_" + id + ".t"
				fsize = 400
			}
			if ( cnt == 1 ) {
				if ( fread == 1 ) {
					dim map, mdata(MDATA_WIDTH), mdata(MDATA_HEIGHT), 10
					dim mapsync, mdata(MDATA_WIDTH), mdata(MDATA_HEIGHT)
					dim mef, 9, 200
				}
				file += "m2_" + id + ".t"
				fsize = mdata(MDATA_WIDTH) * mdata(MDATA_HEIGHT) * 10 * 4
			}
			if ( cnt == 2 ) {
				file += "m3_" + id + ".t"
				fsize = 1164800
			}
			if ( fread == 0 ) {
				zOpen hgz, file, 1, 3
			}
			if ( fread == 1 ) {
				zOpen hgz, file, 0
			}
			if ( cnt == 0 ) {
				if ( fread == 0 ) {
					zWrite mdata, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead mdata, hgz, fsize
				}
			}
			if ( cnt == 1 ) {
				if ( fread == 0 ) {
					zWrite map, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead map, hgz, fsize
				}
			}
			if ( cnt == 2 ) {
				if ( fread == 0 ) {
					zWrite inv(INV_ITEM_NUM, RANGE_INV1), hgz, fsize
				}
				if ( fread == 1 ) {
					zRead inv(INV_ITEM_NUM, RANGE_INV1), hgz, fsize
				}
			}
			zClose hgz
		loop
		file = folder + "m4_" + id + ".t"
		fmode = "mdatan"
		export = 1
		arrayfile
		if ( fread == 0 ) {
			zipadd "m1_" + id + ".t"
			zipadd "m2_" + id + ".t"
			zipadd "m3_" + id + ".t"
			zipadd "m4_" + id + ".t"
		}
	}
	if ( fmode == 22 | fmode == 21 ) {
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile" + fmode + " ct:" + ct
		folder = exedir + "user\\"
		if ( fmode == 22 ) {
			fread = 0
			tg = 1
		}
		if ( fmode == 21 ) {
			fread = 1
			tg = 0
		}
		enemyteam = -1
		gdata(GDATA_USERNPC_COUNT) = 0
		sdim untaglist
		repeat MAX_CHARA_TOTAL
			if ( fread == 0 ) {
				if ( list(0, cnt) == 0 ) {
					continue
				}
				tg = cnt
			}
			else {
				exist folder + "c1_" + id + ".t"
				if ( strsize == (-1) ) {
					break
				}
				tg = 0
				repeat MAX_CHARA_TOTAL - MAX_CHARA_SAVE, MAX_CHARA_SAVE
					if ( cdata(CDATA_EXIST, cnt) == CHAR_STATE_DEAD ) {
						tg = cnt
						break
					}
				loop
				if ( tg == 0 ) {
					break
				}
			}
			repeat 3
				file = folder
				if ( cnt == 0 ) {
					file += "c1_" + id + ".t"
					fsize = 2000
				}
				if ( cnt == 1 ) {
					file += "c2_" + id + ".t"
					fsize = 4800
				}
				if ( cnt == 2 ) {
					file += "c3_" + id + ".t"
					inv_getheader tg
					fsize = 70 * 4 * invrange
				}
				if ( fread == 0 ) {
					zOpen hgz, file, 1, 3
				}
				if ( fread == 1 ) {
					zOpen hgz, file, 0
				}
				if ( cnt == 0 ) {
					if ( fread == 0 ) {
						zWrite cdata(CDATA_EXIST, tg), hgz, fsize
					}
					if ( fread == 1 ) {
						zRead cdata(CDATA_EXIST, tg), hgz, fsize
					}
				}
				if ( cnt == 1 ) {
					if ( fread == 0 ) {
						zWrite sdata(SKILL_NONE, tg), hgz, fsize
					}
					if ( fread == 1 ) {
						zRead sdata(SKILL_NONE, tg), hgz, fsize
					}
				}
				if ( cnt == 2 ) {
					if ( fread == 0 ) {
						zWrite inv(INV_ITEM_NUM, invhead), hgz, fsize
					}
					if ( fread == 1 ) {
						zRead inv(INV_ITEM_NUM, invhead), hgz, fsize
					}
				}
				zClose hgz
			loop
			file = folder + "c4_" + id + ".t"
			fmode = "cdatan3"
			export = 1
			arrayfile
			if ( fread == 0 ) {
				zipadd "c1_" + id + ".t"
				zipadd "c2_" + id + ".t"
				zipadd "c3_" + id + ".t"
				zipadd "c4_" + id + ".t"
				if ( cdata(CDATA_ID, tg) == CREATURE_ID_USER ) {
					exist folder + userdatan(6, cdata(CDATA_USERNPC_ID, tg))
					if ( strsize != (-1) ) {
						if ( cdata(CDATA_USERNPC_ID, tg) != usernpcmax ) {
							if ( instr(untaglist, 0, "/" + userdatan(0, cdata(CDATA_USERNPC_ID, tg)) + "/") == (-1) ) {
								if ( gdata(GDATA_USERNPC_COUNT) < 10 ) {
									bcopy folder + userdatan(6, cdata(CDATA_USERNPC_ID, tg)), folder + "_tmp_" + gdata(GDATA_USERNPC_COUNT) + ".npc"
									zipadd "_tmp_" + gdata(GDATA_USERNPC_COUNT) + ".npc"
									untaglist += "/" + userdatan(0, cdata(CDATA_USERNPC_ID, tg)) + "/"
									gdata(GDATA_USERNPC_COUNT)++
								}
							}
						}
					}
				}
			}
			else {
				inv_getheader tg
				repeat invrange, invhead
					inv(INV_ITEM_EQUIP, cnt) = 0
				loop
				repeat MAX_EQUIP_SLOT_TOTAL, CDATA_STARTING_EQUIP_SLOTS
					cdata(cnt, tg) = cdata(cnt, tg) / EXT_EQUIP_SLOTS * EXT_EQUIP_SLOTS
				loop
				rc = tg
				gosub *chara_equipFull
				cdata(CDATA_AI_ITEM, rc) = 0
				rowactend rc
				cbitmod CHARA_BIT_PCC, rc, 0
				cbitmod CHARA_BIT_LEASHED, rc, 0
				cdata(CDATA_HP, rc) = cdata(CDATA_MAX_HP, rc)
				cdata(CDATA_MP, rc) = cdata(CDATA_MAX_MP, rc)
				cbitmod CHARA_BIT_LIVESTOCK, rc, 0
				cbitmod CHARA_BIT_MSG_FILE, rc, 0
				if ( importmode == 0 ) {
					cdata(CDATA_ROLE, tg) = ROLE_USER
					cdata(CDATA_GOLD, tg) = 0
					if ( cdata(CDATA_RELATION, tg) >= 10 ) {
						if ( userrelation == 0 ) {
							cdata(CDATA_RELATION, tg) = 0
							cdata(CDATA_RELATION_ORG, tg) = 0
						}
						else {
							cdata(CDATA_RELATION, tg) = -3
							cdata(CDATA_RELATION_ORG, tg) = -3
						}
					}
					cxinit = cdata(CDATA_X, tg)
					cyinit = cdata(CDATA_Y, tg)
					gosub *place_chara
				}
				if ( importmode == 1 ) {
					if ( enemyteam == (-1) ) {
						enemyteam = rc
					}
					cdata(CDATA_RELATION, rc) = -3
					cdata(CDATA_RELATION_ORG, rc) = -3
					map_placearena rc, 1
				}
			}
			id++
		loop
	}
	if ( fmode == 16 ) {
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile" + fmode + " ct:" + ct
		dim cmapdata, 5, 400
		repeat 2
			if ( cnt == 0 ) {
				file = fmapfile + ".map"
				fsize = mdata(MDATA_WIDTH) * mdata(MDATA_HEIGHT) * 3 * 4
			}
			if ( cnt == 1 ) {
				file = fmapfile + ".obj"
				fsize = 8000
			}
			if ( cnt == 1 ) {
				exist file
				if ( strsize == (-1) ) {
					continue
				}
			}
			zOpen hgz, file, 0
			if ( cnt == 0 ) {
				zRead map, hgz, fsize
			}
			if ( cnt == 1 ) {
				zRead cmapdata, hgz, fsize
			}
			zClose hgz
		loop
	}
	if ( fmode == 6 | fmode == 5 ) {
		if ( fmode == 6 ) {
			fread = 0
		}
		if ( fmode == 5 ) {
			fread = 1
			dim cmapdata, 5, 400
		}
		repeat 3
			if ( cnt == 0 ) {
				file = fmapfile + ".idx"
				fsize = 400
			}
			if ( cnt == 1 ) {
				if ( fread == 1 ) {
					dim map, mdata(MDATA_WIDTH), mdata(MDATA_HEIGHT), 10
					dim mapsync, mdata(MDATA_WIDTH), mdata(MDATA_HEIGHT)
					dim mef, 9, 200
				}
				file = fmapfile + ".map"
				fsize = mdata(MDATA_WIDTH) * mdata(MDATA_HEIGHT) * 10 * 4
			}
			if ( cnt == 2 ) {
				file = fmapfile + ".obj"
				fsize = 8000
			}
			if ( cnt == 2 & fread == 1 ) {
				exist file
				if ( strsize == (-1) ) {
					continue
				}
			}
			if ( fread == 0 ) {
				zOpen hgz, file, 1, 3
			}
			if ( fread == 1 ) {
				zOpen hgz, file, 0
			}
			if ( cnt == 0 ) {
				if ( fread == 0 ) {
					zWrite mdata, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead mdatatmp, hgz, fsize
					repeat 5
						mdata(cnt) = mdatatmp(cnt)
					loop
				}
			}
			if ( cnt == 1 ) {
				if ( fread == 0 ) {
					zWrite map, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead map, hgz, fsize
				}
			}
			if ( cnt == 2 ) {
				if ( fread == 0 ) {
					zWrite cmapdata, hgz, fsize
				}
				if ( fread == 1 ) {
					zRead cmapdata, hgz, fsize
				}
			}
			zClose hgz
		loop
	}
	if ( fmode == 4 | fmode == 3 ) {
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile" + fmode + " ct:" + ct
		folder = exedir + "tmp\\"
		if ( fmode == 4 ) {
			fread = 0
		}
		if ( fmode == 3 ) {
			fread = 1
		}
		file = folder + file
		fsize = 1164800
		if ( fread == 0 ) {
			zOpen hgz, file, 1, 3
			fileadd file
		}
		if ( fread == 1 ) {
			zopenwrapper hgz, file, 0
		}
		if ( fread == 0 ) {
			zWrite inv(INV_ITEM_NUM, RANGE_INV1), hgz, fsize
		}
		if ( fread == 1 ) {
			zRead inv(INV_ITEM_NUM, RANGE_INV1), hgz, fsize
		}
		zClose hgz
	}
	if ( fmode == 23 | fmode == 24 ) {
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile" + fmode + " ct:" + ct
		if ( fmode == 23 ) {
			fread = 0
		}
		if ( fmode == 24 ) {
			fread = 1
		}
		fsize = 4000
		if ( fread == 0 ) {
			zOpen hgz, file, 1, 3
			fileadd "" + file
		}
		if ( fread == 1 ) {
			zOpen hgz, file, 0
		}
		if ( fread == 0 ) {
			zWrite deck, hgz, fsize
		}
		if ( fread == 1 ) {
			zRead deck, hgz, fsize
		}
		zClose hgz
	}
	if ( fmode == 18 | fmode == 17 ) {
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile" + fmode + " ct:" + ct
		folder = exedir + "tmp\\"
		if ( fmode == 18 ) {
			fread = 0
		}
		if ( fmode == 17 ) {
			fread = 1
		}
		existwrapper folder + "cdata_" + mid + ".s2"
		if ( strsize == (-1) ) {
			return
		}
		repeat 5
			file = folder
			if ( cnt == 0 ) {
				file += "cdata_" + mid + ".s2"
				fsize = 376000
			}
			if ( cnt == 1 ) {
				file += "sdata_" + mid + ".s2"
				fsize = 902400
			}
			if ( fread == 0 ) {
				zOpen hgz, file, 1, 3
				fileadd "" + file
			}
			if ( fread == 1 ) {
				zopenwrapper hgz, file, 0
			}
			if ( cnt == 0 ) {
				if ( fread == 0 ) {
					zWrite cdata(CDATA_EXIST, MAX_CHARA_SAVE), hgz, fsize
				}
				if ( fread == 1 ) {
					zRead cdata(CDATA_EXIST, MAX_CHARA_SAVE), hgz, fsize
				}
			}
			if ( cnt == 1 ) {
				if ( fread == 0 ) {
					zWrite sdata(SKILL_NONE, MAX_CHARA_SAVE), hgz, fsize
				}
				if ( fread == 1 ) {
					zRead sdata(SKILL_NONE, MAX_CHARA_SAVE), hgz, fsize
				}
			}
			zClose hgz
		loop
		file = folder + "cdatan_" + mid + ".s2"
		fmode = "cdatan2"
		arrayfilewrapper
	}
	if ( fmode == 10 ) {
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile" + fmode + " ct:" + ct
		dirlist buff, exedir + "tmp\\*.*"
		if ( stat == 0 ) {
			return stat
		}
		notesel buff
		repeat stat
			noteget file, cnt
			file = exedir + "tmp\\" + file
			exist file
			if ( strsize != (-1) ) {
				delete file
			}
		loop
	}
	if ( fmode == 9 ) {
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile" + fmode + " ct:" + ct
		folder = exedir + "save\\" + playerid
		dirlist buff, folder + "\\*.*"
		if ( stat != 0 ) {
			notesel buff
			repeat stat
				noteget file, cnt
				delete folder + "\\" + file
			loop
		}
		RemoveDirectoryA folder
	}
	if ( fmode == 11 | fmode == 12 ) {
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile" + fmode + " ct:" + ct
		if ( fmode == 12 ) {
			existwrapper exedir + "tmp\\mdata_" + mid + ".s2"
			if ( strsize == (-1) ) {
				return
			}
		}
		file = exedir + "tmp\\map_" + mid + ".s2"
		existwrapper file
		if ( strsize == (-1) ) {
			return
		}
		deletewrapper file
		fileadd file, 1
		if ( fmode == 11 ) {
			file = exedir + "tmp\\cdata_" + mid + ".s2"
			deletewrapper file
			fileadd file, 1
			file = exedir + "tmp\\sdata_" + mid + ".s2"
			deletewrapper file
			fileadd file, 1
			file = exedir + "tmp\\cdatan_" + mid + ".s2"
			deletewrapper file
			fileadd file, 1
			file = exedir + "tmp\\inv_" + mid + ".s2"
			deletewrapper file
			fileadd file, 1
		}
		file = exedir + "tmp\\mdata_" + mid + ".s2"
		deletewrapper file
		fileadd file, 1
		file = exedir + "tmp\\mdatan_" + mid + ".s2"
		deletewrapper file
		fileadd file, 1
		file = exedir + "tmp\\mef_" + mid + ".s2"
		deletewrapper file
		fileadd file, 1
	}
	if ( fmode == 13 ) {
		procid = (procid + 1) \ 4
		proclist(procid) = "ctrlFile" + fmode + " ct:" + ct
		repeat 40
			adata(cnt, area) = 0
		loop
		fmode13replacer area
	}
	procid = (procid + 1) \ 4
	proclist(procid) = "ctrlFile" + fmode + "/end" + " ct:" + ct
	return

*export_map
	sdim headtemp, 1024
	id = 0
	lensum = 1024
	sdim filebuff, lensum
	if ( usertitle != "" ) {
		headtemp = lang("[＋製]【", "[Made by][") + usertitle + lang("】", "]") + "\n"
	}
	else {
		headtemp = lang("[＋製]【", "[Made by][") + mdatan(MDATAN_NAME) + lang("】", "]") + "\n"
	}
	headtemp += "" + cdatan(CDATAN_AKA, CHARA_PLAYER) + cdatan(CDATAN_NAME, CHARA_PLAYER) + "\n"
	headtemp += "\n"
	headtemp += "\n"
	headtemp += "" + 100002 + "\n"
	headtemp += lang("[＋製]", "[Made by]") + usermsg + "\n"
	headtemp += "" + userrelation + "\n"
	memcpy filebuff, headtemp, 1024, 0
	fmode = 20
	gosub *game_ctrlFile
	repeat MAX_CHARA_TOTAL
		list(0, cnt) = 0
		if ( cnt != 0 ) {
			if ( cdata(CDATA_IN_TAGTEAM, cnt) != 1 ) {
				if ( cdata(CDATA_ROLE, cnt) != ROLE_ADVENTURER ) {
					if ( cdata(CDATA_EXIST, cnt) == CHAR_STATE_ALIVE ) {
						if ( cbit(CHARA_BIT_RIDE, cnt) == 0 ) {
							list(0, cnt) = 1
						}
					}
				}
			}
		}
	loop
	fmode = 22
	gosub *game_ctrlFile
	bsave userfile, filebuff
	gosub *del_userTemp
	return

/********** ANNA CUSTOM - BEGINNING **********/

*AnnaCustomAI
	if ( AIData(6, cc-1) >= 1 ) {
		cdata(CDATA_AI_DISTANCE, cc) = AIData(6, cc-1)
	}
	else {
		cdata(CDATA_AI_DISTANCE, cc) = 1
	}
	act = -10
	ActionTarget = -10
	LoopCount = 0
	ContinueTactic = 0
	TrueTarget = 0
	PreservedTarget = -1
	TriedLearnedSkill = 0
	gosub *IncrementFatigue
	repeat MAX_CHARA_FOLLOWER - 1
		PassTactic = 0
		if ( ContinueTactic == 2 ) {
			if ( AIData(70+cnt, cc-1) != 5 ) {
				ContinueTactic = 0
			}
			continue
		}
		if ( ContinueTactic == 0 ) {
			HoldTarget = 0
			PreservedTarget = -1
		}
		if ( AIData(10+cnt, cc-1) \ 1000 != 0 & AIData(25+cnt, cc-1) != 0 & AIData(40+cnt, cc-1) != 0 & AIData(55+cnt, cc-1) != 0 & AIData(70+cnt, cc-1) != 0 ) { ; Check that tactic has no "not set" parts
			if ( AIData(70+cnt, cc-1) == 5 ) { ; Processed
				ContinueTactic = 2
			}
			else {
				ContinueTactic = 0
			}

			; Switch to set target based on AIData value
			switch AIData(10+cnt, cc-1) \ 1000
				case 1 ; Self
					ActionTarget = cc
					swbreak
				case 2 ; Target
					ActionTarget = tc
					swbreak
				case 3 ; Ally - Has to be handled separately in each section
					if ( HoldTarget != 1 ) {
						ActionTarget = -2
					}
					swbreak
				case 4 ; Player
					ActionTarget = 0
					swbreak
			swend

			if ( ActionTarget != (-2) & AIData(70 + cnt, cc - 1) != 3 & AIData(70 + cnt, cc - 1) != 4 ) {
				dx = cdata(CDATA_X, ActionTarget)
				dy = cdata(CDATA_Y, ActionTarget)
				if ( fov_los(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), dx, dy) == 0 ) {
					continue
				}
			}
			HoldTarget = AIData(10+cnt, cc-1) / 1000

			; HP Condition Handling
			if ( AIData(25+cnt, cc-1) == 1 ) { ; If condition is equal to "HP"
				if ( AIData(55+cnt, cc-1) > 99 & AIData(55+cnt, cc-1) - 100 < 100 ) { ; If value is a percentage
					if ( ActionTarget == -2 ) {
						LoopCount = 0

						while ( LoopCount < MAX_CHARA_FOLLOWER )
							if ( cdata(CDATA_EXIST, LoopCount) != CHAR_STATE_ALIVE ) {
								LoopCount++
								_continue
							}
							if ( LoopCount == cc ) {
								LoopCount++
								_continue
							}
							dx = cdata(CDATA_X, LoopCount)
							dy = cdata(CDATA_Y, LoopCount)
							if ( fov_los(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), dx, dy) == 0 & (AIData(70 + cnt, cc - 1) != 3 & AIData(70 + cnt, cc - 1) != 4) ) {
								LoopCount++
								_continue
							}
							if ( (((cdata(CDATA_HP, LoopCount) * 100) / cdata(CDATA_MAX_HP, LoopCount)) == AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 3 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 6) ) {
								ActionTarget = LoopCount
								_break
							}
							if ( (((cdata(CDATA_HP, LoopCount) * 100) / cdata(CDATA_MAX_HP, LoopCount)) > AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 2 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 4) ) {
								ActionTarget = LoopCount
								_break
							}
							if ( (((cdata(CDATA_HP, LoopCount) * 100) / cdata(CDATA_MAX_HP, LoopCount)) < AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 1 | AIData(40+cnt, cc-1) == 6 | AIData(40+cnt, cc-1) == 4) ) {
								ActionTarget = LoopCount
								_break
							}
							LoopCount++
						wend
					}
					if ( ActionTarget == -2 ) {
						continue
					}
					if ( (((cdata(CDATA_HP, ActionTarget) * 100) / cdata(CDATA_MAX_HP, ActionTarget)) == AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 3 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 6) ) {
						act = AIData(70+cnt, cc-1)
						gosub *ProcessTactic
						if ( ContinueTactic == 1 | PassTactic == 1 ) {
							continue
						}
						else {
							break
						}
					}
					if ( (((cdata(CDATA_HP, ActionTarget) * 100) / cdata(CDATA_MAX_HP, ActionTarget)) > AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 2 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 4) ) {
						act = AIData(70+cnt, cc-1)
						gosub *ProcessTactic
						if ( ContinueTactic == 1 | PassTactic == 1 ) {
							continue
						}
						else {
							break
						}
					}
					if ( (((cdata(CDATA_HP, ActionTarget) * 100) / cdata(CDATA_MAX_HP, ActionTarget)) < AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 1 | AIData(40+cnt, cc-1) == 6 | AIData(40+cnt, cc-1) == 4) ) {
						act = AIData(70+cnt, cc-1)
						gosub *ProcessTactic
						if ( ContinueTactic == 1 | PassTactic == 1 ) {
							continue
						}
						else {
							break
						}
					}
				} ; End check for valid percentage
			} ; End HP Handling

			; MP Condition Handling
			if ( AIData(25+cnt, cc-1) == 2 ) { ; If condition is equal to "MP"
				if ( AIData(55+cnt, cc-1) > 99 & AIData(55+cnt, cc-1) - 100 < 100 ) { ; If value is a percentage
					if ( ActionTarget == -2 ) {
						LoopCount = 0

						while ( LoopCount < MAX_CHARA_FOLLOWER )
							if ( cdata(CDATA_EXIST, LoopCount) != CHAR_STATE_ALIVE ) {
								LoopCount++
								_continue
							}
							dx = cdata(CDATA_X, LoopCount)
							dy = cdata(CDATA_Y, LoopCount)
							if ( fov_los(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), dx, dy) == 0 & (AIData(70 + cnt, cc - 1) != 3 & AIData(70 + cnt, cc - 1) != 4) ) {
								LoopCount++
								_continue
							}
							if ( LoopCount == cc ) {
								LoopCount++
								_continue
							}
							if ( (((cdata(CDATA_MP, LoopCount)*100) / cdata(CDATA_MAX_MP, LoopCount)) == AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 3 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 6) ) {
								ActionTarget = LoopCount
								_break
							}
							if ( (((cdata(CDATA_MP, LoopCount)*100) / cdata(CDATA_MAX_MP, LoopCount)) > AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 2 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 4) ) {
								ActionTarget = LoopCount
								_break
							}
							if ( (((cdata(CDATA_MP, LoopCount)*100) / cdata(CDATA_MAX_MP, LoopCount)) < AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 1 | AIData(40+cnt, cc-1) == 6 | AIData(40+cnt, cc-1) == 4) ) {
								ActionTarget = LoopCount
								_break
							}
							LoopCount++
						wend
					}
					if ( ActionTarget == -2 ) {
						continue
					}
					if ( (((cdata(CDATA_MP, ActionTarget) * 100) / cdata(CDATA_MAX_MP, ActionTarget)) == AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 3 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 6) ) {
						act = AIData(70+cnt, cc-1)
						gosub *ProcessTactic
						if ( ContinueTactic == 1 | PassTactic == 1 ) {
							continue
						}
						else {
							break
						}
					}
					if ( (((cdata(CDATA_MP, ActionTarget) * 100) / cdata(CDATA_MAX_MP, ActionTarget)) > AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 2 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 4) ) {
						act = AIData(70+cnt, cc-1)
						gosub *ProcessTactic
						if ( ContinueTactic == 1 | PassTactic == 1 ) {
							continue
						}
						else {
							break
						}
					}
					if ( (((cdata(CDATA_MP, ActionTarget) * 100) / cdata(CDATA_MAX_MP, ActionTarget)) < AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 1 | AIData(40+cnt, cc-1) == 6 | AIData(40+cnt, cc-1) == 4) ) {
						act = AIData(70+cnt, cc-1)
						gosub *ProcessTactic
						if ( ContinueTactic == 1 | PassTactic == 1 ) {
							continue
						}
						else {
							break
						}
					}
				} ; End check for valid percentage
			} ; End MP Handling

			; Distance Condition Handling
			if ( AIData(25+cnt, cc-1) == 3 ) { ; If condition is equal to "distance"
				if ( AIData(55+cnt, cc-1) > 99 & AIData(55+cnt, cc-1) - 200 < 100 & AIData(55+cnt, cc-1) - 200 >= 0 ) { ; If value is a distance
					if ( ActionTarget == -2 ) {
						LoopCount = 0

						while ( LoopCount < MAX_CHARA_FOLLOWER )
							if ( cdata(CDATA_EXIST, LoopCount) != CHAR_STATE_ALIVE ) {
								LoopCount++
								_continue
							}
							if ( LoopCount == cc ) {
								LoopCount++
								_continue
							}
							dx = cdata(CDATA_X, LoopCount)
							dy = cdata(CDATA_Y, LoopCount)
							if ( fov_los(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), dx, dy) == 0 & (AIData(70 + cnt, cc - 1) != 3 & AIData(70 + cnt, cc - 1) != 4) ) {
								LoopCount++
								_continue
							}
							if ( (dist(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), dx, dy) == AITextData(AIData(55+cnt, cc-1) - 200, 5)) & (AIData(40+cnt, cc-1) == 3 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 6) ) {
								ActionTarget = LoopCount
								_break
							}
							if ( (dist(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), dx, dy) > AITextData(AIData(55+cnt, cc-1) - 200, 5)) & (AIData(40+cnt, cc-1) == 2 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 4) ) {
								ActionTarget = LoopCount
								_break
							}
							if ( (dist(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), dx, dy) < AITextData(AIData(55+cnt, cc-1) - 200, 5)) & (AIData(40+cnt, cc-1) == 1 | AIData(40+cnt, cc-1) == 6 | AIData(40+cnt, cc-1) == 4) ) {
								ActionTarget = LoopCount
								_break
							}
							LoopCount++
						wend
					}
					if ( ActionTarget == -2 ) {
						continue
					}
					dx = cdata(CDATA_X, ActionTarget)
					dy = cdata(CDATA_Y, ActionTarget)
					if ( (dist(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), dx, dy) == AITextData(AIData(55+cnt, cc-1) - 200, 5)) & (AIData(40+cnt, cc-1) == 3 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 6) ) {
						act = AIData(70+cnt, cc-1)
						gosub *ProcessTactic
						if ( ContinueTactic == 1 | PassTactic == 1 ) {
							continue
						}
						else {
							break
						}
					}
					if ( (dist(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), dx, dy) > AITextData(AIData(55+cnt, cc-1) - 200, 5)) & (AIData(40+cnt, cc-1) == 2 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 4) ) {
						act = AIData(70+cnt, cc-1)
						gosub *ProcessTactic
						if ( ContinueTactic == 1 | PassTactic == 1 ) {
							continue
						}
						else {
							break
						}
					}
					if ( (dist(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), dx, dy) < AITextData(AIData(55+cnt, cc-1) - 200, 5)) & (AIData(40+cnt, cc-1) == 1 | AIData(40+cnt, cc-1) == 6 | AIData(40+cnt, cc-1) == 4) ) {
						act = AIData(70+cnt, cc-1)
						gosub *ProcessTactic
						if ( ContinueTactic == 1 | PassTactic == 1 ) {
							continue
						}
						else {
							break
						}
					}
				} ; End check for valid distance
			} ; End Distance Handling

			; Buff Condition Handling
			if ( AIData(25+cnt, cc-1) == 4 ) { ; If condition is equal to "buff"
				if ( AIData(55+cnt, cc-1) < MAX_BUFF ) { ; If value is a valid buff ID
					if ( ActionTarget == -2 ) {
						LoopCount = 0

						while ( LoopCount < MAX_CHARA_FOLLOWER )
							if ( cdata(CDATA_EXIST, LoopCount) != CHAR_STATE_ALIVE ) {
								LoopCount++
								_continue
							}
							if ( LoopCount == cc ) {
								LoopCount++
								_continue
							}
							dx = cdata(CDATA_X, LoopCount)
							dy = cdata(CDATA_Y, LoopCount)
							if ( fov_los(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), dx, dy) == 0 & (AIData(70 + cnt, cc - 1) != 3 & AIData(70 + cnt, cc - 1) != 4) ) {
								LoopCount++
								_continue
							}
							if ( (findbuff(LoopCount, AIData(55+cnt, cc-1)) == (-1) & AIData(40+cnt, cc-1) == (4)) | (findbuff(LoopCount, AIData(55+cnt, cc-1)) != (-1) & AIData(40+cnt, cc-1) == (3)) ) {
								ActionTarget = LoopCount
								_break
							}
							LoopCount++
						wend
					}
					if ( ActionTarget == -2 ) {
						continue
					}
					if ( (findbuff(ActionTarget, AIData(55+cnt, cc-1)) == (-1) & AIData(40+cnt, cc-1) == (4)) | (findbuff(ActionTarget, AIData(55+cnt, cc-1)) != (-1) & AIData(40+cnt, cc-1) == (3)) ) {
						act = AIData(70+cnt, cc-1)
						gosub *ProcessTactic
						if ( ContinueTactic == 1 | PassTactic == 1 ) {
							continue
						}
						else {
							break
						}
					}
				} ; End check for valid buff ID
			} ; End Buff Handling

			; Gauge Condition Handling
			if ( AIData(25+cnt, cc-1) == 5 ) { ; If condition is equal to "Gauge"
				if ( AIData(55+cnt, cc-1) > 99 & AIData(55+cnt, cc-1) - 100 < 100 ) { ; If value is a percentage
					if ( ActionTarget == -2 ) {
						LoopCount = 0

						while ( LoopCount < MAX_CHARA_FOLLOWER )
						if ( cdata(CDATA_EXIST, LoopCount) != CHAR_STATE_ALIVE ) {
							LoopCount++
							_continue
						}
						dx = cdata(CDATA_X, LoopCount)
						dy = cdata(CDATA_Y, LoopCount)
						if ( fov_los(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), dx, dy) == 0 & (AIData(70 + cnt, cc - 1) != 3 & AIData(70 + cnt, cc - 1) != 4) ) {
							LoopCount++
							_continue
						}
						if ( LoopCount == cc ) {
							LoopCount++
							_continue
						}
						if ( (cdata(CDATA_POWER_GAUGE, LoopCount) == AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 3 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 6) ) {
							ActionTarget = LoopCount
							_break
						}
						if ( (cdata(CDATA_POWER_GAUGE, LoopCount) > AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 2 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 4) ) {
							ActionTarget = LoopCount
							_break
						}
						if ( (cdata(CDATA_POWER_GAUGE, LoopCount) < AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 1 | AIData(40+cnt, cc-1) == 6 | AIData(40+cnt, cc-1) == 4) ) {
							ActionTarget = LoopCount
							_break
						}
						LoopCount++
						wend
					}
					if ( ActionTarget == -2 ) {
						continue
					}
					if ( (cdata(CDATA_POWER_GAUGE, ActionTarget) == AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 3 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 6) ) {
						act = AIData(70+cnt, cc-1)
						gosub *ProcessTactic
						if ( ContinueTactic == 1 | PassTactic == 1 ) {
							continue
						}
						else {
							break
						}
					}
					if ( (cdata(CDATA_POWER_GAUGE, ActionTarget) > AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 2 | AIData(40+cnt, cc-1) == 5 | AIData(40+cnt, cc-1) == 4) ) {
						act = AIData(70+cnt, cc-1)
						gosub *ProcessTactic
						if ( ContinueTactic == 1 | PassTactic == 1 ) {
							continue
						}
						else {
							break
						}
					}
					if ( (cdata(CDATA_POWER_GAUGE, ActionTarget) < AITextData(AIData(55+cnt, cc-1) - 100, 4)) & (AIData(40+cnt, cc-1) == 1 | AIData(40+cnt, cc-1) == 6 | AIData(40+cnt, cc-1) == 4) ) {
						act = AIData(70+cnt, cc-1)
						gosub *ProcessTactic
						if ( ContinueTactic == 1 | PassTactic == 1 ) {
							continue
						}
						else {
							break
						}
					}
				} ; End check for percentage
			} ; End Gauge Handling

			; Class Handling
			if ( AIData(25+cnt, cc-1) == 6 ) { ; If condition is equal to "Class"
				if ( AIData(55+cnt, cc-1) > 99 & AIData(55+cnt, cc-1) - 300 < 100 & AIData(55+cnt, cc-1) - 300 >= 0 ) { ; If value is a percentage
					if ( ActionTarget == -2 ) {
						LoopCount = 0

						while ( LoopCount < MAX_CHARA_FOLLOWER )
							if ( cdata(CDATA_EXIST, LoopCount) != CHAR_STATE_ALIVE ) {
								LoopCount++
								_continue
							}
							dx = cdata(CDATA_X, LoopCount)
							dy = cdata(CDATA_Y, LoopCount)
							if ( fov_los(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), dx, dy) == 0 & (AIData(70 + cnt, cc - 1) != 3 & AIData(70 + cnt, cc - 1) != 4) ) {
								LoopCount++
								_continue
							}
							if ( LoopCount == cc ) {
								LoopCount++
								_continue
							}
							if ( (cdatan(CDATAN_CLASS, LoopCount) == AITextData(AIData(55+cnt, cc-1) - 300, 6) & AIData(40+cnt, cc-1) == (3)) | (cdatan(CDATAN_CLASS, LoopCount) != AITextData(AIData(55+cnt, cc-1) - 300, 6) & AIData(40+cnt, cc-1) == (4)) ) {
								ActionTarget = LoopCount
								_break
							}
							LoopCount++
						wend
					}
					if ( ActionTarget == -2 ) {
						continue
					}
					if ( (cdatan(CDATAN_CLASS, ActionTarget) == AITextData(AIData(55+cnt, cc-1) - 300, 6) & AIData(40+cnt, cc-1) == (3)) | (cdatan(CDATAN_CLASS, ActionTarget) != AITextData(AIData(55+cnt, cc-1) - 300, 6) & AIData(40+cnt, cc-1) == (4)) ) {
						act = AIData(70+cnt, cc-1)
						gosub *ProcessTactic
						if ( ContinueTactic == 1 | PassTactic == 1 ) {
							continue
						}
						else {
							break
						}
					}
				} ; End check for class
			} ; End Class Handling

			; Status Handling
			if ( AIData(25 + cnt, cc - 1) == 7 ) {; If condition is equal to "Status"
				if ( AIData(55 + cnt, cc - 1) > 99 & AIData(55 + cnt, cc - 1) - 400 < 100 & AIData(55 + cnt, cc - 1) - 400 >= 0 ) { ; Ensure value is a status
					if ( ActionTarget == -2 ) {
						LoopCount = 0
						while ( LoopCount < MAX_CHARA_FOLLOWER )
							if ( cdata(CDATA_EXIST, LoopCount) != CHAR_STATE_ALIVE ) {
								LoopCount++
								_continue
							}
							dx = cdata(CDATA_X, LoopCount)
							dy = cdata(CDATA_Y, LoopCount)
							if ( fov_los(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), dx, dy) == 0 & (AIData(70 + cnt, cc - 1) != 3 & AIData(70 + cnt, cc - 1) != 4) ) {
								LoopCount++
								_continue
							}
							if ( LoopCount == cc ) {
								LoopCount++
								_continue
							}
							if ( (cdata(StatusOffsets(AIData(55 + cnt, cc - 1) \ 100), LoopCount) > 0 & AIData(40 + cnt, cc - 1) == (3)) | (cdata(StatusOffsets(AIData(55 + cnt, cc - 1) \ 100), LoopCount) == 0 & AIData(40 + cnt, cc - 1) == (4)) ) {
								ActionTarget = LoopCount
								_break
							}
							LoopCount++
						wend
					}
					if ( ActionTarget == -2 ) {
						continue
					}
					if ( (cdata(StatusOffsets(AIData(55 + cnt, cc - 1) \ 100), ActionTarget) > 0 & AIData(40 + cnt, cc - 1) == (3)) | (cdata(StatusOffsets(AIData(55 + cnt, cc - 1) \ 100), ActionTarget) == 0 & AIData(40 + cnt, cc - 1) == (4)) ) {
						act = AIData(70 + cnt, cc - 1)
						gosub *ProcessTactic
						if ( ContinueTactic == 1 | PassTactic == 1 ) {
							continue
						}
						else {
							break
						}
					}
				}; End value verification
			}; End Status Handling
		}
	loop

	TrueTarget = tc
	if ( act != (-10) & PreservedTarget != (-1) ) {
		tc = PreservedTarget
	}
	if ( act == SKILL_SPACT_VARIABLE_BREATH ) { ; Variable Breath Handling
		act = SKILL_SPACT_POWER_BREATH
		bvar = sdata(SKILL_RES_MAGIC, cc)
		if ( sdata(SKILL_RES_FIRE, cc) > bvar ) {
			act = SKILL_SPACT_FIRE_BREATH
			bvar = sdata(SKILL_RES_FIRE, cc)
		}
		if ( sdata(SKILL_RES_COLD, cc) > bvar ) {
			act = SKILL_SPACT_COLD_BREATH
			bvar = sdata(SKILL_RES_COLD, cc)
		}
		if ( sdata(SKILL_RES_LIGHTNING, cc) > bvar ) {
			act = SKILL_SPACT_LIGHTNING_BREATH
			bvar = sdata(SKILL_RES_LIGHTNING, cc)
		}
		if ( sdata(SKILL_RES_DARKNESS, cc) > bvar ) {
			act = SKILL_SPACT_DARKNESS_BREATH
			bvar = sdata(SKILL_RES_DARKNESS, cc)
		}
		if ( sdata(SKILL_RES_MIND, cc) > bvar ) {
			act = SKILL_SPACT_MIND_BREATH
			bvar = sdata(SKILL_RES_MIND, cc)
		}
		if ( sdata(SKILL_RES_POISON, cc) > bvar ) {
			act = SKILL_SPACT_POISON_BREATH
			bvar = sdata(SKILL_RES_POISON, cc)
		}
		if ( sdata(SKILL_RES_NETHER, cc) > bvar ) {
			act = SKILL_SPACT_NETHER_BREATH
			bvar = sdata(SKILL_RES_NETHER, cc)
		}
		if ( sdata(SKILL_RES_SOUND, cc) > bvar ) {
			act = SKILL_SPACT_SOUND_BREATH
			bvar = sdata(SKILL_RES_SOUND, cc)
		}
		if ( sdata(SKILL_RES_NERVE, cc) > bvar ) {
			act = SKILL_SPACT_NERVE_BREATH
			bvar = sdata(SKILL_RES_NERVE, cc)
		}
		if ( sdata(SKILL_RES_CHAOS, cc) > bvar ) {
			act = SKILL_SPACT_CHAOS_BREATH
			bvar = sdata(SKILL_RES_CHAOS, cc)
		}
		if ( sdata(SKILL_RES_MAGIC, cc) >= bvar ) {
			act = SKILL_SPACT_POWER_BREATH
		}
		bvar = 0
	}

	; Melee Attacks
	if ( act == 1 ) {
		distance = dist(cdata(CDATA_X, tc), cdata(CDATA_Y, tc), cdata(CDATA_X, cc), cdata(CDATA_Y, cc))
		if ( distance == 1 ) {
			gosub *act_melee
			goto *turn_end
		}
	}

	; Ranged Attacks
	if ( act == 2 ) {
		distance = dist(cdata(CDATA_X, tc), cdata(CDATA_Y, tc), cdata(CDATA_X, cc), cdata(CDATA_Y, cc))
		if ( distance < 6 ) {
			if ( fov_los(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), cdata(CDATA_X, tc), cdata(CDATA_Y, tc)) ) {
				gosub *FindRangeWeapon
				if ( stat == 1 ) {
					gosub *act_fire
					goto *turn_end
				}
			}
		}
	}

	; Movement
	if ( act == 3 | act == 4 ) {
		AIData(6, cc-1) = cdata(CDATA_AI_DISTANCE, cc)
		distance = dist(cdata(CDATA_X, tc), cdata(CDATA_Y, tc), cdata(CDATA_X, cc), cdata(CDATA_Y, cc))
		if ( act == 3 ) {
			cdata(CDATA_AI_DISTANCE, cc) = distance+1
		}
		if ( act == 4 & distance != 1 ) {
			cdata(CDATA_AI_DISTANCE, cc) = distance-1
		}
		goto *ai_followMove
	}

	; Spells
	if ( act >= STARTING_SKILL_SPELL & act < MAX_SPELL ) {
		if ( cdata(CDATA_SEALED_MAGIC, cc) == 0 ) { ; Magic not sealed
			efid = act
			npccostmp = 1
			gosub *cast
			if ( stat == 1 ) {
				goto *turn_end
			}
		}
	}

	; Abilities
	if ( act >= STARTING_SKILL_SPACT ) {
		if ( act == SKILL_SPACT_DISTURBANCE | cdata(CDATA_SEALED_ABILITY, cc) == 0 ) {
			efid = act
			gosub *action
			if ( stat == 1 ) {
				gosub *ProcessFatigue
				goto *turn_end
			}
		}
	}

	; Throwing Things
	if ( act >= ACTION_THROW & act < MAX_ACTION_THROW ) {
		distance = dist(cdata(CDATA_X, tc), cdata(CDATA_Y, tc), cdata(CDATA_X, cc), cdata(CDATA_Y, cc))
		if ( distance < 8 ) {
			if ( fov_los(cdata(CDATA_X, cc), cdata(CDATA_Y, cc), cdata(CDATA_X, tc), cdata(CDATA_Y, tc)) ) {
				tlocx = cdata(CDATA_X, tc)
				tlocy = cdata(CDATA_Y, tc)
				if ( act == ACTION_THROW_POTION_MINOR ) {
					flt
					flttypemajor = FILTER_ITEM_POTION
					itemcreate cc, isetthrowpotionminor(rnd(length(isetthrowpotionminor))), -1, -1, 0
				}
				if ( act == ACTION_THROW_POTION_MAJOR ) {
					flt
					flttypemajor = FILTER_ITEM_POTION
					itemcreate cc, isetthrowpotionmajor(rnd(length(isetthrowpotionmajor))), -1, -1, 0
				}
				if ( act == ACTION_THROW_POTION_GREATER ) {
					flt
					flttypemajor = FILTER_ITEM_POTION
					itemcreate cc, isetthrowpotiongreater(rnd(length(isetthrowpotiongreater))), -1, -1, 0
				}
				if ( act == ACTION_THROW_POTION_SALT ) {
					flt
					itemcreate cc, ITEM_ID_POTION_SALT_SOLUTION, -1, -1, 0
				}
				if ( stat == 1 ) {
					gosub *ProcessFatigue
					goto *act_throw
				}
				goto *turn_end
			}
		}
	}

	; Failure
	if ( AIData(7, cc-1) == 0 ) {
		txt "" + name(cc) + " doesn't know how to respond to the situation based on the instructions you've given " + him(cc) + "!"
	}
	goto *turn_end
	return

*GetFatigue
	LoopCount = 0
	while( LoopCount < 20 )
	if ( AIData(85+LoopCount, cc-1) == act ) {
		FatigueLevel = AIData(105+LoopCount, cc-1)
		_break
	}
	LoopCount++
	wend

	return

*IncrementFatigue
	LoopCount = 0
	while( LoopCount < 20 )
		if ( AIData(85+LoopCount, cc-1) < MAX_ACTION_THROW & AIData(85+LoopCount, cc-1) >= ACTION_THROW ) {
			if ( AIData(105+LoopCount, cc-1) < 15 ) {
				AIData(105+LoopCount, cc-1)++
			}
		}
		if ( AIData(85+LoopCount, cc-1) >= STARTING_SKILL_SPACT ) {
			if ( AIData(105+LoopCount, cc-1) < ((sdataref(SKILL_DATAREF_COST, AIData(85+LoopCount, cc-1))/10) * 5) & AIData(105+LoopCount, cc-1) < 20 ) {
				AIData(105+LoopCount, cc-1)++
			}
		}
		LoopCount++
	wend

	return

*ProcessFatigue
	LoopCount = 0
	while( LoopCount < 20 )
		if ( AIData(85+LoopCount, cc-1) == act ) {
			if ( act < MAX_ACTION_THROW & act >= ACTION_THROW ) {
				AIData(105+LoopCount, cc-1) -= 4
			}
			else {
				AIData(105+LoopCount, cc-1) -= (limit(sdataref(SKILL_DATAREF_COST, act)/10, 1, 20) + 1)
			}
			_break
		}
		LoopCount++
	wend

	return

*AILearnAbility
	ActionToFind = act
	FoundAction = 0
	LoopCount = 0

	while( LoopCount < 20 )
		if ( AIData(85+LoopCount, cc-1) == ActionToFind ) {
			FoundAction = 1
			_break
		}
		LoopCount++
	wend

	if ( FoundAction == 0 ) {
		LoopCount = 0

		while( LoopCount < 20 )
			if ( AIData(85+LoopCount, cc-1) == 0 ) {
				AIData(85+LoopCount, cc-1) = act
				AIData(3, cc-1) = 0
				AIData(4, cc-1) = 0
				_break
			}
			LoopCount++
		wend
	}
	else {
		AIData(3, cc-1) = 0
		AIData(4, cc-1) = 0
	}
	return

*ProcessTactic
	if ( act == AIData(3, cc-1) ) {
		if ( rnd(100) > limit(AIData(4, cc-1)/2, 1, 20) | TriedLearnedSkill == 1 ) {
			PassTactic = 1
			act = -10
		}
		else {
			if ( rnd(4) == 0 & cbit(CHARA_BIT_SANDBAG, tc) != 1 ) {
				AIData(4, cc-1)++
				if ( AIData(4, cc-1) > 100 ) {
					AIData(4, cc-1) = 100
				}
				if ( AIData(4, cc-1) == 100 ) {
					gosub *AILearnAbility
				}
			}
		}
		TriedLearnedSkill = 1
	}
	if ( act < MAX_ACTION_THROW & act >= ACTION_THROW ) {
		gosub *GetFatigue
		if ( FatigueLevel < 3 ) {
			PassTactic = 1
			act = -10
		}
	}
	if ( act >= STARTING_SKILL_SPACT & act != AIData(3, cc-1) ) {
		gosub *GetFatigue
		if ( FatigueLevel < sdataref(SKILL_DATAREF_COST, act)/10 ) {
			PassTactic = 1
			act = -10
		}
	}
	if ( PassTactic == 1 ) {
		return
	}
	if ( act == 5 ) {
		ContinueTactic = 1
	}
	if ( HoldTarget == 1 ) {
		PreservedTarget = ActionTarget
	}
	return

*PrintAIInfo
	if ( AIData(0, tc-1) == 1 ) {
		s = "Currently using custom AI."
	}
	else {
		s = "Currently using default AI."
	}
	pos wx + 400, wy + 378
	mes s
	s = "Currently Available Slots: " + AIData(1, tc-1)
	pos wx + 400, wy + 397
	mes s
	if ( AIData(3, tc-1) < 400 ) {
		AIData(3, tc-1) = 0
	}
	ActionToGet = AIData(3, tc-1)
	gosub *GetActionName
	if ( AIData(3, tc-1) == 0 ) {
		s = "Currently Learning: N/A"
	}
	else {
		s = "Currently Learning: " + ActionName
	}
	pos wx + 400, wy + 416
	mes s
	if ( AIData(3, tc-1) == 0 ) {
		s = "Current Progress: N/A"
	}
	else {
		s = "Current Progress: " + AIData(4, tc-1) + "%"
	}
	pos wx + 400, wy + 435
	mes s
	return

*AIMainMenu
	HeldTactic = -1
	pagesize = 0
	redraw 0
	AIData(1, tc-1) = sdata(SKILL_ATTR_LER, CHARA_PLAYER) / 5
	if ( AIData(1, tc-1) > sdata(SKILL_ATTR_LER, tc) /5 ) {
		AIData(1, tc-1) = sdata(SKILL_ATTR_LER, tc) / 5
	}
	AIData(1, tc-1) = limit(AIData(1, tc-1), 3, 15)
	if ( AIData(2, tc-1) == 0 ) {
		gosub *AIInitActions
	}
	s = "Tactical Instructions", strhint3b
	display_window (windoww - 680) / 2 + inf_screenx, winposy(500, 1) + 20, 680, 500
	display_topic "Entity", wx + 28, wy + 30
	display_topic "Condition", wx + 128, wy + 30
	display_topic "Comparator", wx + 253, wy + 30
	display_topic "Value", wx + 388, wy + 30
	display_topic "Action", wx + 488, wy + 30
	s = "Teach Your Pet"
	gosub *screen_drawMsg2
	listn(0, 0) = "Configure"
	listn(0, 1) = "Teach a spell or ability."
	listn(0, 2) = "Exit"
	font lang(cfg_font1, cfg_font2), 14 - en * 2, 0

	repeat 3
		key_list(cnt) = key_select(cnt)
		keyrange = cnt + 1
		pos wx + 38, wy + 385 + cnt * 19 - 2
		gcopy 3, cnt * 24 + 72, 30, 24, 18
		cs_list listn(0, cnt), wx + 64, wy + 385 + cnt * 19 - 1, 19
	loop

	font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
	gosub *PrintAIInfo
	repeat AIData(1, tc-1)
	s = AITextData(AIData(10+cnt, tc-1) \ 1000, 1)
	pos wx + 48, wy + 60 + cnt * 19 + 2
	mes s
	s = AITextData(AIData(25+cnt, tc-1), 2)
	pos wx + 148, wy + 60 + cnt * 19 + 2
	mes s
	s = AITextData(AIData(40+cnt, tc-1), 3)
	pos wx + 273, wy + 60 + cnt * 19 + 2
	mes s
	SlotID = cnt
	gosub *GetValueName
	s = ValueName
	pos wx + 408, wy + 60 + cnt * 19 + 2
	mes s
	ActionToGet = AIData(70+SlotID, tc-1)
	gosub *GetActionName
	s = ActionName
	pos wx + 508, wy + 60 + cnt * 19 + 2
	mes s
	s = "" + (cnt+1)
	pos wx + 18, wy + 60 + cnt * 19 + 2
	mes s
	loop
	if ( listn(0, cs) == listn(0, 0) ) {
		s = "Change your pet's AI."
		pos wx + 38, wy + 359
		mes s
	}
	if ( listn(0, cs) == listn(0, 1) ) {
		s = "Teach your pet a new ability or spell."
		pos wx + 38, wy + 359
		mes s
	}
	if ( listn(0, cs) == listn(0, 2) ) {
		s = "Exit the menu."
		pos wx + 38, wy + 359
		mes s
	}
	cs_bk = cs
	redraw 1
	await cfg_wait1
	key_check
	cursor_check
	if ( key == key_select(0) ) {
		cs = 0
		goto *AIConfigMenu
	}
	if ( key == key_select(1) ) {
		goto *AITeachConfigMenu
	}
	if ( key == key_select(2) ) {
		goto *chat_end
	}
	if ( key == key_cancel ) {
		goto *chat_end
	}
	goto *AIMainMenu
	return

*AITeachConfigMenu
	redraw 0
	s = "Tactical Instructions", strhint3b
	display_window (windoww - 680) / 2 + inf_screenx, winposy(500, 1) + 20, 680, 500
	s = "Teach Your Pet"
	gosub *screen_drawMsg2
	listn(0, 0) = "Teach a spell."
	listn(0, 1) = "Teach an ability."
	listn(0, 2) = "Make " + him(tc) + " forget a spell/ability."
	listn(0, 3) = "Back"
	font lang(cfg_font1, cfg_font2), 14 - en * 2, 0

	repeat 4
		key_list(cnt) = key_select(cnt)
		keyrange = cnt + 1
		pos wx + 38, wy + 60 + cnt * 19 - 2
		gcopy 3, cnt * 24 + 72, 30, 24, 18
		cs_list listn(0, cnt), wx + 64, wy + 60 + cnt * 19 - 1, 19
	loop

	font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
	gosub *PrintAIInfo
	cs_bk = cs
	redraw 1
	await cfg_wait1
	key_check
	cursor_check
	if ( key == key_select(0) ) {
		goto *AISpellLearnMenu
	}
	if ( key == key_select(1) ) {
		goto *AIAbilityLearnMenu
	}
	if ( key == key_select(2) ) {
		goto *AIDeleteAbilityMenu
	}
	if ( key == key_cancel | key == key_select(3) ) {
		goto *AIMainMenu
	}
	goto *AITeachConfigMenu
	return

*AIDeleteAbilityMenu
	redraw 0
	s = "Tactical Instructions", strhint3b
	display_window (windoww - 680) / 2 + inf_screenx, winposy(500, 1) + 20, 680, 500
	s = "Teach Your Pet"
	gosub *screen_drawMsg2

	repeat 20
		if ( AIData(85+cnt, tc-1) == 0 ) {
			listn(0, cnt) = "Blank"
		}
		else {
			ActionToGet = AIData(85+cnt, tc-1)
			gosub *GetActionName
			listn(0, cnt) = ActionName
		}
	loop

	listn(0, 20) = "Back"
	font lang(cfg_font1, cfg_font2), 14 - en * 2, 0

	repeat 21
		key_list(cnt) = cnt
		keyrange = cnt + 1
		pos wx + 18 + (150 * (cnt/15)), (wy + 60 + cnt * 19 - 2) - (283 * (cnt/15))
		;gcopy 3, cnt * 24 + 72, 30, 24, 18
		cs_list listn(0, cnt), wx + 44 + (150 * (cnt/15)), (wy + 60 + cnt * 19 - 1) - (284 * (cnt/15)), 19
	loop

	font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
	gosub *PrintAIInfo
	cs_bk = cs
	redraw 1
	await cfg_wait1
	key_check
	cursor_check

	repeat 20
		if ( key == cnt ) {
			LoopCount = 0

			while( LoopCount < 15 )
				if ( AIData(70+LoopCount, tc-1) == AIData(85+cnt, tc-1) ) {
					AIData(70+LoopCount, tc-1) = 0
				}
				LoopCount++
			wend

			if ( AIData(85+cnt, tc-1) != 0 ) {
				AIData(85+cnt, tc-1) = 0
				AIData(5, tc-1)--
			}
			key = key_cancel
		}
	loop

	if ( key == key_cancel | key == 20 ) {
		goto *AITeachConfigMenu
	}
	goto *AIDeleteAbilityMenu
	return

*AISpellLearnMenu
	redraw 0
	s = "Tactical Instructions", strhint3b
	display_window (windoww - 680) / 2 + inf_screenx, winposy(500, 1) + 20, 680, 500
	s = "Teach Your Pet"
	gosub *screen_drawMsg2
	NumActions = 0

	; Spells
	repeat (MAX_SPELL - STARTING_SKILL_SPELL) - 1, STARTING_SKILL_SPELL
		if ( cnt == SKILL_SPELL_TELEPORT_OTHER | cnt == SKILL_SPELL_IDENTIFY | cnt == SKILL_SPELL_UNCURSE | cnt == SKILL_SPELL_ORACLE | cnt == SKILL_SPELL_SUMMON_MONSTERS | cnt == SKILL_SPELL_SUMMON_WILD | cnt == SKILL_SPELL_RETURN | cnt == SKILL_SPELL_MAGIC_MAP | cnt == SKILL_SPELL_SENSE_OBJECT | cnt == SKILL_SPELL_DOMINATE | cnt == SKILL_SPELL_WALL_CREATION | cnt == SKILL_SPELL_WISH | cnt == SKILL_SPELL_MUTATION | cnt == SKILL_SPELL_FIRE_WALL | cnt == SKILL_SPELL_DOOR_CREATION | cnt == SKILL_SPELL_INCOGNITO | cnt == SKILL_SPELL_RESURRECTION | cnt == SKILL_SPELL_4DIM_POCKET | cnt == SKILL_SPELL_WIZARDS_HARVEST | cnt == SKILL_SPELL_SUMMON_SPIRIT | cnt == SKILL_SPELL_METEOR ) {
			continue // Forbidden
		}
		if ( sdata(cnt, CHARA_PLAYER) >= 50 & (sdata(SKILL_NORMAL_CASTING, tc) >= (sdataref(SKILL_DATAREF_DIFF, cnt) / 15) | (cnt == SKILL_SPELL_HEAL_LIGHT | cnt == SKILL_SPELL_MAGIC_DART)) ) {
			ActionToGet = cnt
			gosub *GetActionName
			listn(0, NumActions) = ActionName
			key_list(NumActions) = cnt
			NumActions++
		}
	loop

	listn(0, NumActions) = "Back"
	key_list(NumActions) = 999
	font lang(cfg_font1, cfg_font2), 14 - en * 2, 0
	repeat NumActions+1
	keyrange = cnt + 1
	pos wx + 18 + (150 * (cnt/15)), (wy + 60 + cnt * 19 - 2) - (283 * (cnt/15))
	cs_list listn(0, cnt), wx + 44 + (150 * (cnt/15)), (wy + 60 + cnt * 19 - 1) - (284 * (cnt/15)), 19
	loop
	font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
	gosub *PrintAIInfo
	cs_bk = cs
	redraw 1
	await cfg_wait1
	key_check
	cursor_check
	repeat (MAX_SPELL - STARTING_SKILL_SPELL) - 1, STARTING_SKILL_SPELL
	if ( key == cnt ) {
		LoopCount = 0

		while ( LoopCount < 20 )
			if ( AIData(85+LoopCount, tc-1) == key ) {
				txt "" + name(tc) + " already knows that spell."
				p = 0
				break
			}
			LoopCount++
		wend

		LoopCount = 0

		while ( LoopCount < 15 )
			if ( AIData(70+LoopCount, tc-1) == AIData(3, tc-1) ) {
				AIData(70+LoopCount, tc-1) = 0
			}
			LoopCount++
		wend

		AIData(3, tc-1) = key
		AIData(4, tc-1) = 0

		break
	}
	loop
	if ( key == key_cancel | key == 999 ) {
		cs = 0
		goto *AITeachConfigMenu
	}
	goto *AISpellLearnMenu
	return

*AIAbilityLearnMenu
	redraw 0
	s = "Tactical Instructions", strhint3b
	display_window (windoww - 680) / 2 + inf_screenx, winposy(500, 1) + 20, 680, 500
	s = "Teach Your Pet"
	gosub *screen_drawMsg2
	NumActions = 0

	repeat (MAX_SKILL - STARTING_SKILL_SPACT), STARTING_SKILL_SPACT
		if ( cnt == SKILL_SPACT_DRAIN_BLOOD | cnt == SKILL_SPACT_FIRE_BREATH | cnt == SKILL_SPACT_COLD_BREATH | cnt == SKILL_SPACT_LIGHTNING_BREATH | cnt == SKILL_SPACT_DARKNESS_BREATH | cnt == SKILL_SPACT_CHAOS_BREATH | cnt == SKILL_SPACT_SOUND_BREATH | cnt == SKILL_SPACT_NETHER_BREATH | cnt == SKILL_SPACT_NERVE_BREATH | cnt == SKILL_SPACT_POISON_BREATH | cnt == SKILL_SPACT_MIND_BREATH | cnt == SKILL_SPACT_POWER_BREATH | cnt == SKILL_SPACT_TOUCH_OF_WEAKNESS | cnt == SKILL_SPACT_TOUCH_OF_HUNGER | cnt == SKILL_SPACT_TOUCH_OF_POISON | cnt == SKILL_SPACT_TOUCH_OF_NERVE | cnt == SKILL_SPACT_TOUCH_OF_FEAR | cnt == SKILL_SPACT_TOUCH_OF_SLEEP | cnt == SKILL_SPACT_SHADOW_STEP | cnt == SKILL_SPACT_DRAW_SHADOW | cnt == SKILL_SPACT_HARVEST_MANA | cnt == SKILL_SPACT_PUNISHMENT | cnt == SKILL_SPACT_DIMENSIONAL_MOVE | cnt == SKILL_SPACT_SWARM | cnt == SKILL_SPACT_EYE_OF_MUTATION | cnt == SKILL_SPACT_EYE_OF_ETHER | cnt == SKILL_SPACT_ETHER_GROUND | cnt == SKILL_SPACT_EYE_OF_INSANITY | cnt == SKILL_SPACT_RAIN_OF_SANITY | cnt == SKILL_SPACT_EYE_OF_DIMNESS | cnt == SKILL_SPACT_CURSE | cnt == SKILL_SPACT_DEATH_WORD | cnt == SKILL_SPACT_BOOST | cnt == SKILL_SPACT_INSULT | cnt == SKILL_SPACT_SHINING_WAVE | cnt == SKILL_SPACT_DISTANT_ATTACK7 | cnt == SKILL_SPACT_EYE_OF_MANA | cnt == SKILL_SPACT_PREGNANT | cnt == SKILL_SPACT_CHEER | cnt == SKILL_SPACT_RAMPAGE | cnt == SKILL_SPACT_SYNCHRO_HEARTS | cnt == SKILL_SPACT_MAGIC_KISS | cnt == SKILL_SPACT_CLEAR_MIND | cnt == SKILL_SPACT_PRESSURE | cnt == SKILL_SPACT_SUPER_REGEN | cnt == SKILL_SPACT_PLATINUM_SONG | cnt == SKILL_SPACT_PROVOKE | cnt == SKILL_SPACT_BIND | cnt == SKILL_SPACT_BROWBEAT | cnt == SKILL_SPACT_EYE_OF_BRAINWASHING | cnt == SKILL_SPACT_EXPLOSIVE_FIST | cnt == SKILL_SPACT_CHARGE | cnt == SKILL_SPACT_EMERGENCY_EVASION | cnt == SKILL_SPACT_MAGIC_EQUIP | cnt == SKILL_SPACT_SUPER_ARMOR | cnt == SKILL_SPACT_GRAVITY_SPHERE | cnt == SKILL_SPACT_ATTRIBUTE | cnt == SKILL_SPACT_FIRE_A_VOLLEY | cnt == SKILL_SPACT_MEGID_FLAME | cnt == SKILL_SPACT_CONTINUOUS_ATTACKS | cnt == SKILL_SPACT_VARIABLE_BREATH | cnt == SKILL_SPACT_DIVINE_STREAM | cnt == SKILL_SPACT_ZERO_SHOOT | cnt == SKILL_SPACT_SQUEEZE | cnt == SKILL_SPACT_DISTURBANCE | cnt == SKILL_SPACT_UNCONTROL | cnt == SKILL_SPACT_SPACE_RETENTION | cnt == SKILL_SPACT_DISTANT_ATTACK | cnt == SKILL_SPACT_SPINNING_THROW | cnt == SKILL_SPACT_METAL_GUARD | cnt == SKILL_SPACT_THUNDERCLAP_KICK | cnt == SKILL_SPACT_STRUCK_OUT | cnt == SKILL_SPACT_BEWITCH | cnt == SKILL_SPACT_SHADOW_RUSH | cnt == SKILL_SPACT_BODY_BLOW | cnt == SKILL_SPACT_KNOCKOUT | cnt == SKILL_SPACT_OVERRAY | cnt == SKILL_SPACT_SMASH_GROUND | cnt == SKILL_SPACT_MULTIPLE_GATHER | cnt == SKILL_SPACT_MANA_BURST | cnt == SKILL_SPACT_VINDALIAN_JIUJITSU | cnt == SKILL_SPACT_CLASH_RUSH | cnt == SKILL_SPACT_BLADE_TURBULENCE | cnt == SKILL_SPACT_DEATH_SONG | cnt == SKILL_SPACT_HOMING_LASER | cnt == SKILL_SPACT_MP_BREATH | cnt == SKILL_SPACT_BOUND_IN_BLOOD | cnt == SKILL_SPACT_SILENT_OCEAN | cnt == SKILL_SPACT_DIMENSION_FISHING | cnt == SKILL_SPACT_FASCINATION_DANCE ) {
			if ( spact(cnt - STARTING_SKILL_SPACT) == 1 ) {
				if ( sdata(sdataref(SKILL_DATAREF_USE, cnt), tc) > sdataref(SKILL_DATAREF_COST, cnt) * 2 ) {
					ActionToGet = cnt
					gosub *GetActionName

					listn(0, NumActions) = ActionName
					key_list(NumActions) = cnt
					NumActions++
				}
			}
		}
	loop

	listn(0, NumActions) = "Back"
	key_list(NumActions) = 999
	font lang(cfg_font1, cfg_font2), 14 - en * 2, 0

	repeat NumActions+1
		keyrange = cnt + 1
		pos wx + 18 + (150 * (cnt/15)), (wy + 60 + cnt * 19 - 2) - (283 * (cnt/15))
		cs_list listn(0, cnt), wx + 44 + (150 * (cnt/15)), (wy + 60 + cnt * 19 - 1) - (284 * (cnt/15)), 19
	loop

	font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
	gosub *PrintAIInfo
	cs_bk = cs
	redraw 1
	await cfg_wait1
	key_check
	cursor_check

	repeat (MAX_SKILL - STARTING_SKILL_SPACT), STARTING_SKILL_SPACT
		if ( key == cnt ) {
			LoopCount = 0
			while ( LoopCount < 20 )
				if ( AIData(85+LoopCount, tc-1) == key ) {
					txt "" + name(tc) + " already knows that ability."
					p = 0
					break
				}
				LoopCount++
			wend

			LoopCount = 0

			while ( LoopCount < 15 )
				if ( AIData(70+LoopCount, tc-1) == AIData(3, tc-1) ) {
					AIData(70+LoopCount, tc-1) = 0
				}
				LoopCount++
			wend

			AIData(3, tc-1) = key
			AIData(4, tc-1) = 0

			break
		}
	loop

	if ( key == key_cancel | key == 999 ) {
		cs = 0
		goto *AITeachConfigMenu
	}
	goto *AIAbilityLearnMenu
	return

*AIConfigMenu
	GoConfig = 0
	redraw 0
	s = "Tactical Instructions", strhint3b
	display_window (windoww - 680) / 2 + inf_screenx, winposy(500, 1) + 20, 680, 500
	display_topic "Entity", wx + 28, wy + 30
	display_topic "Condition", wx + 128, wy + 30
	display_topic "Comparator", wx + 253, wy + 30
	display_topic "Value", wx + 388, wy + 30
	display_topic "Action", wx + 488, wy + 30
	s = "Teach Your Pet"
	gosub *screen_drawMsg2

	repeat AIData(1, tc-1)
		listn(0, cnt) = "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\t\t\t\t\t\t\t\t\t\t\t\t\t\\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"
	loop

	listn(0, AIData(1, tc-1)) = "Toggle AI"
	listn(0, AIData(1, tc-1)+1) = "Re-Initialize Actions"
	if ( AIData(7, tc-1) == 0 ) {
		listn(0, AIData(1, tc-1)+2) = "Be quiet."
	}
	else {
		listn(0, AIData(1, tc-1)+2) = "Tell me when you're confused."
	}
	listn(0, AIData(1, tc-1)+3) = "Back"
	font lang(cfg_font1, cfg_font2), 14 - en * 2, 0

	repeat AIData(1, tc-1) + 4
		key_list(cnt) = key_select(cnt)
		keyrange = cnt + 1
		pos wx + 18, wy + 60 + cnt * 19 - 2
		gcopy 3, cnt * 24 + 72, 30, 24, 18
		cs_list listn(0, cnt), wx + 44, wy + 60 + cnt * 19 - 1, 19
	loop

	font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
	gosub *PrintAIInfo

	repeat AIData(1, tc-1)
		s = AITextData(AIData(10+cnt, tc-1) \ 1000, 1)
		pos wx + 48, wy + 60 + cnt * 19 + 2
		mes s
		s = AITextData(AIData(25+cnt, tc-1), 2)
		pos wx + 148, wy + 60 + cnt * 19 + 2
		mes s
		s = AITextData(AIData(40+cnt, tc-1), 3)
		pos wx + 273, wy + 60 + cnt * 19 + 2
		mes s
		SlotID = cnt
		gosub *GetValueName
		s = ValueName
		pos wx + 408, wy + 60 + cnt * 19 + 2
		mes s
		ActionToGet = AIData(70+SlotID, tc-1)
		gosub *GetActionName
		s = ActionName
		pos wx + 508, wy + 60 + cnt * 19 + 2
		mes s
	loop

	cs_bk = cs
	redraw 1
	await cfg_wait1
	key_check
	cursor_check
	if ( key == key_mode2 ) {
		if ( HeldTactic == -1 ) {
			HeldTactic = cs
		}
		else {
			TempSwap = AIData(10+cs, tc-1)
			AIData(10+cs, tc - 1) = AIData(10+HeldTactic, tc-1)
			AIData(10+HeldTactic, tc-1) = TempSwap
			TempSwap = AIData(25+cs, tc-1)
			AIData(25+cs, tc - 1) = AIData(25+HeldTactic, tc-1)
			AIData(25+HeldTactic, tc-1) = TempSwap
			TempSwap = AIData(40+cs, tc-1)
			AIData(40+cs, tc - 1) = AIData(40+HeldTactic, tc-1)
			AIData(40+HeldTactic, tc-1) = TempSwap
			TempSwap = AIData(55+cs, tc-1)
			AIData(55+cs, tc - 1) = AIData(55+HeldTactic, tc-1)
			AIData(55+HeldTactic, tc-1) = TempSwap
			TempSwap = AIData(70+cs, tc-1)
			AIData(70+cs, tc - 1) = AIData(70+HeldTactic, tc-1)
			AIData(70+HeldTactic, tc-1) = TempSwap
			HeldTactic = -1
		}
	}

	repeat AIData(1, tc-1)
		if ( key == key_select(cnt) ) {
			CurrentTactic = cnt
			cs = 0
			GoConfig = 1
			HeldTactic = -1
		}
	loop

	if ( GoConfig == 1 ) {
		goto *AITacticConfigMenu
	}
	if ( key == key_select(AIData(1, tc-1)) ) {
		if ( AIData(0, tc-1) == 1 ) {
			cdata(CDATA_AI_DISTANCE, tc) = AIData(6, tc-1)
			AIData(6, tc-1) = 0
			AIData(0, tc-1) = 0
		}
		else {
			AIData(0, tc-1) = 1
			AIData(6, tc-1) = cdata(CDATA_AI_DISTANCE, tc)
		}
	}
	if ( key == key_select(AIData(1, tc-1)+1) ) {
		dialog "Re-Initialize this pet's spells and abilities?", 3
		if ( stat == 6 ) {
			gosub *AIInitActions
		}
	}
	if ( key == key_select(AIData(1, tc-1)+2) ) {
		if ( AIData(7, tc-1) == 0 ) {
			AIData(7, tc-1) = 1
		}
		else {
			AIData(7, tc-1) = 0
		}
	}
	if ( key == key_cancel | key == key_select(AIData(1, tc-1)+3) ) {
		goto *AIMainMenu
	}
	goto *AIConfigMenu
	return

*AITacticConfigMenu
	redraw 0
	s = "Tactical Instructions", strhint3b
	display_window (windoww - 680) / 2 + inf_screenx, winposy(500, 1) + 20, 680, 500
	s = "Teach Your Pet"
	gosub *screen_drawMsg2
	listn(0, 0) = "Modify Entity. (Current: " + AITextData(AIData(10+CurrentTactic, tc-1) \ 1000, 1) + ")"
	listn(0, 1) = "Modify Condition. (Current: " + AITextData(AIData(25+CurrentTactic, tc-1), 2) + ")"
	listn(0, 2) = "Modify Comparator. (Current: " + AITextData(AIData(40+CurrentTactic, tc-1), 3) + ")"
	SlotID = CurrentTactic
	gosub *GetValueName
	listn(0, 3) = "Modify Value. (Current: " + ValueName + ")"
	SlotID = CurrentTactic
	ActionToGet = AIData(70+SlotID, tc-1)
	gosub *GetActionName
	listn(0, 4) = "Modify Action. (Current: " + ActionName + ")"
	if ( AIData(10+CurrentTactic, tc-1) / 1000 == 1 ) {
		listn(0, 5) = "Toggle Preserve Entity As Target. (Currently: On)"
	}
	else {
		listn(0, 5) = "Toggle Preserve Entity As Target. (Currently: Off)"
	}
	listn(0, 6) = "Back"
	font lang(cfg_font1, cfg_font2), 14 - en * 2, 0

	repeat 7
		key_list(cnt) = key_select(cnt)
		keyrange = cnt + 1
		pos wx + 18, wy + 60 + cnt * 19 - 2
		gcopy 3, cnt * 24 + 72, 30, 24, 18
		cs_list listn(0, cnt), wx + 44, wy + 60 + cnt * 19 - 1, 19
	loop

	font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
	gosub *PrintAIInfo
	cs_bk = cs
	redraw 1
	await cfg_wait1
	key_check
	cursor_check
	if ( key == key_select(0) ) {
		cs = 0
		goto *AIEntitySetMenu
	}
	if ( key == key_select(1) ) {
		cs = 0
		goto *AIConditionSetMenu
	}
	if ( key == key_select(2) ) {
		cs = 0
		goto *AIComparatorSetMenu
	}
	if ( key == key_select(3) ) {
		cs = 0
		goto *AIValueSetMenu
	}
	if ( key == key_select(4) ) {
		cs = 0
		goto *AIActionSetMenu
	}
	if ( key == key_select(5) ) {
		if ( AIData(10+CurrentTactic, tc-1) / 1000 == 1 ) {
			AIData(10+CurrentTactic, tc-1) -= 1000
		}
		else {
			AIData(10+CurrentTactic, tc-1) += 1000
		}
	}
	if ( key == key_cancel | key == key_select(6) ) {
		cs = 0
		goto *AIConfigMenu
	}
	goto *AITacticConfigMenu
	return

*AIActionSetMenu
	redraw 0
	s = "Tactical Instructions", strhint3b
	display_window (windoww - 680) / 2 + inf_screenx, winposy(500, 1) + 20, 680, 500
	s = "Teach Your Pet"
	gosub *screen_drawMsg2
	NumActions = 0

	repeat MAX_CHARA_FOLLOWER - 1
		if ( AITextData(cnt, 0) != "NULL" ) {
			listn(0, NumActions) = AITextData(cnt, 0)
			key_list(NumActions) = NumActions + 100
			NumActions++
		}
		else {
			break
		}
	loop

	if ( AIData(3, tc-1) != 0 ) {
		ActionToGet = AIData(3, tc - 1)
		gosub *GetActionName
		listn(0, NumActions) = ActionName
		key_list(NumActions) = NumActions + 100
		NumActions++
	}

	repeat 20
		if ( AIData(85+cnt, tc-1) != 0 ) {
			ActionToGet = AIData(85+cnt, tc-1)
			gosub *GetActionName
			listn(0, NumActions) = ActionName
			key_list(NumActions) = cnt
			NumActions++
		}
	loop

	listn(0, NumActions) = "Back"
	key_list(NumActions) = 999
	font lang(cfg_font1, cfg_font2), 14 - en * 2, 0

	repeat NumActions+1
		keyrange = cnt + 1
		pos wx + 18 + (150 * (cnt/15)), (wy + 60 + cnt * 19 - 2) - (283 * (cnt/15))
		cs_list listn(0, cnt), wx + 44 + (150 * (cnt/15)), (wy + 60 + cnt * 19 - 1) - (284 * (cnt/15)), 19
	loop

	font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
	gosub *PrintAIInfo
	cs_bk = cs
	redraw 1
	await cfg_wait1
	key_check
	cursor_check

	repeat 115
		if ( key == cnt ) {
			if ( cnt < 100 ) {
				AIData(70+CurrentTactic, tc-1) = AIData(85+cnt, tc-1)
				key = key_cancel
				break
			}
			if ( cnt == 106 ) {
				AIData(70+CurrentTactic, tc-1) = AIData(3, tc-1)
				key = key_cancel
				break
			}
			if ( cnt >= 100 ) {
				AIData(70+CurrentTactic, tc-1) = cnt - 100
				key = key_cancel
				break
			}
		}
	loop

	if ( key == key_cancel | key == 999 ) {
		cs = 0
		goto *AITacticConfigMenu
	}
	goto *AIActionSetMenu
	return

*AIFindAction
	FoundAction = 0
	LoopCount = 0

	while( LoopCount < 20 )
		if ( AIData(85+LoopCount, tc-1) == ActionToFind ) {
			FoundAction = 1
			_break
		}
		LoopCount++
	wend

	return

*AIInitActions
	if ( AIData(2, tc-1) == 1 ) {
		repeat 20
			PlaceholderMoveList(cnt) = AIData(85+cnt, tc-1)
			AIData(70+cnt, tc-1) = 0
			AIData(85+cnt, tc-1) = 0
			AIData(105+cnt, tc-1) = 0
		loop

		AIData(5, tc-1) = 0
		ReInitActions = 1
	}
	gosub *AIGetEvolveActions

	repeat 10
		if ( (cdata(STARTING_CDATA_ACT_MAIN+cnt, tc) > STARTING_SKILL_SPELL & cdata(STARTING_CDATA_ACT_MAIN+cnt, tc) != SKILL_SPELL_METEOR) | (cdata(STARTING_CDATA_ACT_MAIN+cnt, tc) < MAX_ACTION_THROW & cdata(STARTING_CDATA_ACT_MAIN+cnt, tc) >= ACTION_THROW) ) {
			AIData(85+AIData(5, tc-1), tc-1) = cdata(STARTING_CDATA_ACT_MAIN+cnt, tc)
			AIData(5, tc-1)++
		}
	loop

	if ( (cdata(CDATA_ACT_HEAL, tc) > STARTING_SKILL_SPELL & cdata(CDATA_ACT_HEAL, tc) != SKILL_SPELL_METEOR) | (cdata(CDATA_ACT_HEAL, tc) < MAX_ACTION_THROW & cdata(CDATA_ACT_HEAL, tc) >= ACTION_THROW) ) {
		AIData(85+AIData(5, tc-1), tc-1) = cdata(CDATA_ACT_HEAL, tc)
		AIData(5, tc-1)++
	}
	if ( cbit(CHARA_BIT_AWAKE_INSULT, tc) == 1 ) {
		ActionToFind = SKILL_SPACT_INSULT
		gosub *AIFindAction
		gosub *AIAddAction
	}
	if ( cbit(CHARA_BIT_AWAKE_CRYSTAL_SPEAR, tc) == 1 ) {
		ActionToFind = SKILL_SPELL_CRYSTAL_SPEAR
		gosub *AIFindAction
		gosub *AIAddAction
	}
	if ( cbit(CHARA_BIT_AWAKE_DIMENSIONAL_MOVE, tc) == 1 ) {
		ActionToFind = SKILL_SPACT_DIMENSIONAL_MOVE
		gosub *AIFindAction
		gosub *AIAddAction
	}
	if ( cbit(CHARA_BIT_AWAKE_TACTICAL_HEAL, tc) == 1 ) {
		ActionToFind = SKILL_SPELL_REGENERATION
		gosub *AIFindAction
		gosub *AIAddAction
		ActionToFind = SKILL_SPELL_HEAL_CRITICAL
		gosub *AIFindAction
		gosub *AIAddAction
		ActionToFind = SKILL_SPELL_HEALING_RAIN
		gosub *AIFindAction
		gosub *AIAddAction
		ActionToFind = SKILL_SPACT_HARVEST_MANA
		gosub *AIFindAction
		gosub *AIAddAction
	}
	if ( cbit(CHARA_BIT_AWAKE_TACTICAL_ATTACK, tc) == 1 ) {
		ActionToFind = SKILL_SPACT_DECAPITATION
		gosub *AIFindAction
		gosub *AIAddAction
		ActionToFind = SKILL_SPACT_SHADOW_STEP
		gosub *AIFindAction
		gosub *AIAddAction
	}
	if ( cbit(CHARA_BIT_AWAKE_TACTICAL_MARTIAL_ARTS, tc) == 1 ) {
		ActionToFind = SKILL_SPACT_EXPLOSIVE_FIST
		gosub *AIFindAction
		gosub *AIAddAction
		ActionToFind = SKILL_SPACT_BODY_BLOW
		gosub *AIFindAction
		gosub *AIAddAction
		ActionToFind = SKILL_SPACT_ATTRIBUTE
		gosub *AIFindAction
		gosub *AIAddAction
		ActionToFind = SKILL_SPACT_CLEAR_MIND
		gosub *AIFindAction
		gosub *AIAddAction
	}
	if ( cbit(CHARA_BIT_AWAKE_TACTICAL_CURSE, tc) == 1 ) {
		ActionToFind = SKILL_SPELL_MIST_OF_FRAILNESS
		gosub *AIFindAction
		gosub *AIAddAction
		ActionToFind = SKILL_SPELL_NIGHTMARE
		gosub *AIFindAction
		gosub *AIAddAction
		ActionToFind = SKILL_SPELL_ELEMENT_SCAR
		gosub *AIFindAction
		gosub *AIAddAction
		ActionToFind = SKILL_SPELL_MIST_OF_SILENCE
		gosub *AIFindAction
		gosub *AIAddAction
		ActionToFind = SKILL_SPELL_SLOW
		gosub *AIFindAction
		gosub *AIAddAction
	}
	if ( cbit(CHARA_BIT_AWAKE_CHARGE_ATTACK, tc) == 1 ) {
		ActionToFind = SKILL_SPACT_CHARGE
		gosub *AIFindAction
		gosub *AIAddAction
	}
	if ( cbit(CHARA_BIT_AWAKE_PROVOKE, tc) == 1 ) {
		ActionToFind = SKILL_SPACT_PROVOKE
		gosub *AIFindAction
		gosub *AIAddAction
	}
	if ( cbit(CHARA_BIT_AWAKE_ZERO_SHOOT, tc) == 1 ) {
		ActionToFind = SKILL_SPACT_ZERO_SHOOT
		gosub *AIFindAction
		gosub *AIAddAction
	}
	if ( cbit(CHARA_BIT_AWAKE_STRUCK_OUT, tc) == 1 ) {
		ActionToFind = SKILL_SPACT_STRUCK_OUT
		gosub *AIFindAction
		gosub *AIAddAction
	}
	if ( cbit(CHARA_BIT_AWAKE_VARIABLE_BREATH, tc) == 1 ) {
		ActionToFind = SKILL_SPACT_VARIABLE_BREATH
		gosub *AIFindAction
		gosub *AIAddAction
	}
	if ( cbit(CHARA_BIT_AWAKE_VARIABLE_STORM, tc) == 1 ) {
		ActionToFind = SKILL_SPELL_MAGIC_STORM
		gosub *AIFindAction
		gosub *AIAddAction
		ActionToFind = SKILL_SPELL_ICE_BALL
		gosub *AIFindAction
		gosub *AIAddAction
		ActionToFind = SKILL_SPELL_FIRE_BALL
		gosub *AIFindAction
		gosub *AIAddAction
		ActionToFind = SKILL_SPELL_CHAOS_BALL
		gosub *AIFindAction
		gosub *AIAddAction
		ActionToFind = SKILL_SPELL_RAGING_ROAR
		gosub *AIFindAction
		gosub *AIAddAction
	}
	if ( ReInitActions == 1 ) {
		ReInitActions = 0

		repeat 20
			if ( PlaceholderMoveList(cnt) != 0 ) {
				ActionToFind = PlaceholderMoveList(cnt)
				gosub *AIFindAction
				gosub *AIAddAction
			}
		loop
	}
	AIData(2, tc-1) = 1
	return

*AIAddAction
	if ( FoundAction == 0 & AIData(5, tc-1) < 20 ) {
		AIData(85+AIData(5, tc-1), tc-1) = ActionToFind
		AIData(5, tc-1)++
	}
	return

*AIGetEvolveActions
	if ( cdata(CDATA_EVOLUTION_STAGE, tc) != 0 ) {
		switch cdata(CDATA_ID, tc)
			case CREATURE_ID_PUTIT
				ActionToFind = SKILL_SPACT_CHEER
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_RED_PUTIT
				ActionToFind = SKILL_SPACT_CHEER
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_WILD_RABBIT
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) == 1 ) { ; sylbunny
					ActionToFind = SKILL_SPACT_TIME_STOP
					gosub *AIFindAction
					gosub *AIAddAction
				}
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) == 2 ) { ; red-eyes w.rabbit
					ActionToFind = SKILL_SPACT_CHEER
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_SNAIL
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPACT_EMERGENCY_EVASION
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_FALLEN_SOLDIER
				ActionToFind = SKILL_SPACT_SUPER_ARMOR
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_WILD_SHEEP
				ActionToFind = SKILL_SPACT_CURSE
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_FLYING_FROG
				ActionToFind = SKILL_SPACT_PLATINUM_SONG
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_KOBOLD
				ActionToFind = SKILL_SPACT_BROWBEAT
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_WARRIOR_OF_ELEA
				ActionToFind = SKILL_SPACT_EMERGENCY_EVASION
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_MANDRAKE
				ActionToFind = SKILL_SPACT_SHINING_WAVE
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_BEETLE
				ActionToFind = SKILL_SPACT_SUPER_ARMOR
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_WIZARD_OF_ELEA
				ActionToFind = SKILL_SPELL_MAGIC_STORM
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_GIANT_SQUIRREL
				ActionToFind = SKILL_SPACT_INSULT
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_KILLER_SQUIRREL
				ActionToFind = SKILL_SPACT_INSULT
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_GRUDGE
				ActionToFind = ACTION_THROW_POTION_GREATER
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_HUNGRY_DEMON
				ActionToFind = ACTION_THROW_POTION_GREATER
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_ELECTRIC_CLOUD
				ActionToFind = SKILL_SPELL_DARKNESS_BOLT
				gosub *AIFindAction
				gosub *AIAddAction
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPELL_HEALING_RAIN
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_CHAOS_CLOUD
				ActionToFind = SKILL_SPELL_DARKNESS_BOLT
				gosub *AIFindAction
				gosub *AIAddAction
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPELL_HEALING_RAIN
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_PUPPET
				ActionToFind = SKILL_SPACT_CONTINUOUS_ATTACKS
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_WASP
				ActionToFind = SKILL_SPACT_FASCINATION_DANCE
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_RED_WASP
				ActionToFind = SKILL_SPACT_FASCINATION_DANCE
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_CYCLOPS
				ActionToFind = SKILL_SPACT_COLD_BREATH
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_TITAN
				ActionToFind = SKILL_SPACT_COLD_BREATH
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_IMP
				ActionToFind = SKILL_SPACT_MAGIC_EQUIP
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_NETHER_IMP
				ActionToFind = SKILL_SPACT_MAGIC_EQUIP
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_CHAOS_IMP
				ActionToFind = SKILL_SPACT_MAGIC_EQUIP
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_GHOST
				ActionToFind = SKILL_SPACT_CHEER
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_NYMPH
				ActionToFind = SKILL_SPACT_PLATINUM_SONG
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_MAN_EATER_FLOWER
				ActionToFind = SKILL_SPACT_SQUEEZE
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_CHAOS_FLOWER
				ActionToFind = SKILL_SPACT_SQUEEZE
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_COBRA
				ActionToFind = SKILL_SPACT_SQUEEZE
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_KING_COBRA
				ActionToFind = SKILL_SPACT_SQUEEZE
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_CUPID_OF_LOVE
				ActionToFind = SKILL_SPACT_FIRE_A_VOLLEY
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_LESSER_PHANTOM
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPACT_GRAVITY_SPHERE
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_HARPY
				ActionToFind = SKILL_SPACT_SUPER_REGEN
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_SPIDER
				ActionToFind = SKILL_SPACT_BROWBEAT
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_BLACK_WIDOW
				ActionToFind = SKILL_SPACT_BROWBEAT
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_PARALYZER
				ActionToFind = SKILL_SPACT_BROWBEAT
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_TARANTULA
				ActionToFind = SKILL_SPACT_BROWBEAT
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_BLOOD_SPIDER
				ActionToFind = SKILL_SPACT_BROWBEAT
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_WOODEN_GOLEM
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) == 2 ) {
					ActionToFind = SKILL_SPACT_SHINING_WAVE
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_STONE_GOLEM
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) == 2 ) {
					ActionToFind = SKILL_SPACT_SHINING_WAVE
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_STEEL_GOLEM
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) == 2 ) {
					ActionToFind = SKILL_SPACT_SHINING_WAVE
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_FIRE_CRAB
				ActionToFind = SKILL_SPACT_SYNCHRO_HEARTS
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_DOG
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) >= 10 ) {
					ActionToFind = SKILL_SPACT_FLAME_OF_RAGE
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_LITTLE_GIRL
				ActionToFind = SKILL_SPACT_CHEER
				gosub *AIFindAction
				gosub *AIAddAction
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) == 2 ) {
					ActionToFind = SKILL_SPELL_CRYSTAL_SPEAR
					gosub *AIFindAction
					gosub *AIAddAction
					ActionToFind = SKILL_SPACT_RAIN_OF_SANITY
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_RAT
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPACT_LIGHTNING_BREATH
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_SLIME
				ActionToFind = SKILL_SPACT_MELT_CLINCH
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_YOUNGER_SISTER
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) >= 10 ) {
					ActionToFind = SKILL_SPACT_FLAME_OF_RAGE
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_NURSE
				ActionToFind = SKILL_SPACT_RAIN_OF_SANITY
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_BLADE
				ActionToFind = SKILL_SPACT_SHADOW_STEP
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_BLADE_ALPHA
				ActionToFind = SKILL_SPACT_SHADOW_STEP
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_WISP
				ActionToFind = SKILL_SPELL_DARKNESS_BOLT
				gosub *AIFindAction
				gosub *AIAddAction
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPELL_NETHER_WAVE
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_ACID_SLIME
				ActionToFind = SKILL_SPACT_MELT_CLINCH
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_PUMPKIN
				ActionToFind = SKILL_SPACT_BIND
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_GREATER_PUMPKIN
				ActionToFind = SKILL_SPACT_BIND
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_HALLOWEEN_NIGHTMARE
				ActionToFind = SKILL_SPACT_BIND
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_PUPPY
				ActionToFind = SKILL_SPACT_BIND
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_YOUNGER_CAT_SISTER
				ActionToFind = SKILL_SPACT_EMERGENCY_EVASION
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_YOUNG_LADY
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPACT_DRAIN_BLOOD
					gosub *AIFindAction
					gosub *AIAddAction
				}
				ActionToFind = ACTION_THROW_POTION_GREATER
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_THIEF
				ActionToFind = SKILL_SPACT_GOLDEN_STORM
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_ROBBER
				ActionToFind = SKILL_SPACT_GOLDEN_STORM
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_YEEK
				ActionToFind = SKILL_SPACT_CHEER
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_KAMIKAZE_YEEK
				ActionToFind = SKILL_SPACT_CHEER
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_YEEK_WARRIOR
				ActionToFind = SKILL_SPACT_CHEER
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_MASTER_YEEK
				ActionToFind = SKILL_SPACT_CHEER
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_YEEK_ARCHER
				ActionToFind = SKILL_SPACT_CHEER
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_BOMB_ROCK
				ActionToFind = SKILL_SPACT_SHADOW_STEP
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_FAIRY
				ActionToFind = SKILL_SPACT_MAGIC_EQUIP
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_SCORPION
				ActionToFind = SKILL_SPACT_BROWBEAT
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_KING_SCORPION
				ActionToFind = SKILL_SPACT_BROWBEAT
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_BLACK_CAT
				ActionToFind = SKILL_SPACT_BROWBEAT
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_CUTE_FAIRY
				ActionToFind = SKILL_SPACT_BIND
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_ANDROID
				ActionToFind = SKILL_SPACT_FIRE_A_VOLLEY
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_BLACK_ANGEL
				ActionToFind = SKILL_SPACT_LULWYS_TRICK
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_EXILE
				ActionToFind = SKILL_SPELL_ECLIPSE
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_GOLDEN_KNIGHT
				ActionToFind = SKILL_SPACT_SUPER_ARMOR
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_DEFENDER
				ActionToFind = SKILL_SPACT_ABSOLUTE_PROTECT
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_LAME_HORSE
				ActionToFind = SKILL_SPACT_HYPER_DASH
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_YOWYN_HORSE
				ActionToFind = SKILL_SPACT_HYPER_DASH
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_NOYEL_HORSE
				ActionToFind = SKILL_SPACT_HYPER_DASH
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_WILD_HORSE
				ActionToFind = SKILL_SPACT_HYPER_DASH
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_THOROUGHBRED
				ActionToFind = SKILL_SPACT_HYPER_DASH
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_LIZARD_MAN
				ActionToFind = SKILL_SPACT_SHADOW_RUSH
				gosub *AIFindAction
				gosub *AIAddAction
				ActionToFind = SKILL_SPACT_LIGHTNING_BREATH
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_MINOTAUR
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPACT_BOOST
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_MINOTAUR_MAGICIAN
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPACT_BOOST
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_MINOTAUR_BOXER
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPACT_BOOST
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_MINOTAUR_KING
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPACT_BOOST
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_LITTLE_SISTER
				ActionToFind = SKILL_SPACT_SHADOW_STEP
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_GOOSE
				ActionToFind = SKILL_SPACT_PLATINUM_SONG
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_OLDER_SISTER
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) >= 10 ) {
					ActionToFind = SKILL_SPACT_FLAME_OF_RAGE
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_OLDER_DOG_SISTER
				ActionToFind = SKILL_SPACT_CHARGE
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_GIRAFFE
				ActionToFind = SKILL_SPACT_PUNISHMENT
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_ELECTRIC_SHEEP
				ActionToFind = SKILL_SPELL_THUNDER_VORTEX
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_FIRE_DRAGON_CHILD
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPACT_BOOST
					gosub *AIFindAction
					gosub *AIAddAction
				}
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 2 ) {
					ActionToFind = SKILL_SPACT_MEGID_FLAME
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_BLACK_HORNET
				ActionToFind = SKILL_SPACT_FASCINATION_DANCE
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_FOX_BROTHER
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPACT_MEGID_FLAME
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_MOAI
				ActionToFind = SKILL_SPACT_FIRE_A_VOLLEY
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_HAMSTER
				ActionToFind = SKILL_SPACT_SWARM
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_SMALL_STONE_GOLEM
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) == 2 ) {
					ActionToFind = SKILL_SPACT_SHINING_WAVE
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_SMALL_WOODEN_GOLEM
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) == 2 ) {
					ActionToFind = SKILL_SPACT_SHINING_WAVE
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_WANDERING_PENGUIN
				ActionToFind = SKILL_SPACT_BROWBEAT
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_ZOMBIE_GIRL
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) == 1 ) {
					ActionToFind = SKILL_SPACT_ABSOLUTE_PROTECT
					gosub *AIFindAction
					gosub *AIAddAction
					ActionToFind = SKILL_SPELL_REGENERATION
					gosub *AIFindAction
					gosub *AIAddAction
				}
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) == 2 ) {
					ActionToFind = SKILL_SPACT_EMERGENCY_EVASION
					gosub *AIFindAction
					gosub *AIAddAction
					ActionToFind = SKILL_SPACT_RUBBING
					gosub *AIFindAction
					gosub *AIAddAction
					ActionToFind = SKILL_SPACT_KILLING_DANCE
					gosub *AIFindAction
					gosub *AIAddAction
				}
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) == 3 ) {
					ActionToFind = SKILL_SPACT_SWARM
					gosub *AIFindAction
					gosub *AIAddAction
					ActionToFind = SKILL_SPELL_NETHER_WAVE
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_KENTAURS
				ActionToFind = SKILL_SPACT_BOOST
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_CATTLE
				ActionToFind = SKILL_SPACT_PUNISHMENT
				gosub *AIFindAction
				gosub *AIAddAction
				ActionToFind = SKILL_SPACT_HYPER_DASH
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_POISON_ARROW_FROG
				ActionToFind = SKILL_SPACT_PLATINUM_SONG
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_APPRENTICE_ANGEL
				ActionToFind = SKILL_SPACT_OVERRAY
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_LIZARD_MAGE
				ActionToFind = SKILL_SPACT_SHADOW_RUSH
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_GUNFISH
				ActionToFind = SKILL_SPACT_FIRE_A_VOLLEY
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_LARGE_BIKE
				ActionToFind = SKILL_SPACT_HYPER_DASH
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_XEREN_AUTO_TANK
				ActionToFind = SKILL_SPACT_FIRE_A_VOLLEY
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_CHAOS_SEED
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPACT_EXTERMINATION_BREATH
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_CATERPILLAR_SNIPER
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPACT_DRAW_SHADOW
					gosub *AIFindAction
					gosub *AIAddAction
					ActionToFind = SKILL_SPACT_PUNISHMENT
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_LITTLE_BOY
				if ( cdata(CDATA_EVOLUTION_STAGE, tc) > 1 ) {
					ActionToFind = SKILL_SPACT_KILLING_DANCE
					gosub *AIFindAction
					gosub *AIAddAction
				}
				swbreak
			case CREATURE_ID_BUTLER
				ActionToFind = SKILL_SPACT_GROUP_HYPNOSIS
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_BISQUE_DOLL
				ActionToFind = SKILL_SPACT_SHADOW_RUSH
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_ORC
				ActionToFind = SKILL_SPACT_CHEER
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_ORC_WARRIOR
				ActionToFind = SKILL_SPACT_CHEER
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			case CREATURE_ID_PORC
				ActionToFind = SKILL_SPACT_BOOST
				gosub *AIFindAction
				gosub *AIAddAction
				ActionToFind = SKILL_SPACT_HYPER_DASH
				gosub *AIFindAction
				gosub *AIAddAction
				swbreak
			default
				swbreak
		swend
	}
	switch cdata(CDATA_ID, tc)
		case CREATURE_ID_SPIRAL_KING
			ActionToFind = SKILL_SPELL_DARK_EYE
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_BLUE_BUBBLE
			ActionToFind = SKILL_SPELL_BUBBLE_STORM
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_BUBBLE
			ActionToFind = SKILL_SPELL_BUBBLE_STORM
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_SNAIL_THE_ANDROID_RIDER
			ActionToFind = SKILL_SPACT_SHINE_SNAIL
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_CAMOUFLAGED_IMP
			ActionToFind = SKILL_SPACT_GROUP_HYPNOSIS
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_EXOSSIL_THE_CHAOS_WING
			ActionToFind = SKILL_SPACT_GROUP_HYPNOSIS
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_TITANIA
			ActionToFind = SKILL_SPACT_GROUP_HYPNOSIS
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_H_SISTER2
			ActionToFind = SKILL_SPACT_BLOOD_STREAM
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_ARMA_THE_TOUR_GUIDE
			ActionToFind = SKILL_SPACT_VINDALIAN_JIUJITSU
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_ALCHEMIST_NAPLUS
			ActionToFind = ACTION_THROW_POTION_GREATER
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_GETUEI_THE_NINJA_MASTER
			ActionToFind = SKILL_SPACT_SHADOW_RUSH
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_EILA_THE_FUGITIVE_KUNOICHI
			ActionToFind = SKILL_SPACT_CURTAIN_OF_SMOKE
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_RED_NINJA
			ActionToFind = SKILL_SPACT_CURTAIN_OF_SMOKE
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_NEW_CITIZEN
			ActionToFind = SKILL_SPACT_CURTAIN_OF_SMOKE
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_BLOOD_GOLEM
			ActionToFind = SKILL_SPACT_BLOOD_STREAM
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_ULTIMATE_GOLEM
			ActionToFind = SKILL_SPACT_VINDALIAN_JIUJITSU
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_KALI
			ActionToFind = SKILL_SPACT_BLOOD_STREAM
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_MARY_THE_INSECT_MASTER
			ActionToFind = SKILL_SPACT_ATTRIBUTE
			gosub *AIFindAction
			gosub *AIAddAction
			ActionToFind = SKILL_SPACT_VINDALIAN_JIUJITSU
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_RAIZEL_THE_OLD_WIZARD
			ActionToFind = SKILL_SPELL_HOLY_VEIL
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_DEATH_HAMSTER
			ActionToFind = SKILL_SPELL_CONTINGENCY
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_YELLOW_FIRE_DRAGON
			ActionToFind = SKILL_SPACT_ATTRIBUTE
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_VANSESDA_THE_ANCIENT_FIRE
			ActionToFind = SKILL_SPACT_ATTRIBUTE
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_PHANTOM_OF_END
			ActionToFind = SKILL_SPACT_MP_BREATH
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_URCAGUARY
			ActionToFind = SKILL_SPACT_SUPER_ARMOR
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_SMALL_STONE_GOLEM
			ActionToFind = SKILL_SPELL_HOLY_SHIELD
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_SMALL_WOODEN_GOLEM
			ActionToFind = SKILL_SPELL_REGENERATION
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_NERES_THE_AMNESIAC
			ActionToFind = SKILL_SPACT_SMASH_GROUND
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_LAZASYE_THE_DESTROY
			ActionToFind = SKILL_SPACT_MP_BREATH
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_NIGHTMARE_SHEEP
			ActionToFind = SKILL_SPACT_GROUP_HYPNOSIS
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_CONDUCTOR_KOALA
			ActionToFind = SKILL_SPACT_SHADOW_RUSH
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_GRIM_REAPER
			ActionToFind = SKILL_SPACT_KILLING_DANCE
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_DREAD_RABBIT
			ActionToFind = SKILL_SPACT_MULTIPLE_GATHER
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_FALLEN_ANGEL
			ActionToFind = SKILL_SPACT_GROUP_HYPNOSIS
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_DHWTY
			ActionToFind = SKILL_SPACT_MP_BREATH
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_PERFORMAID_BLOODRESS
			ActionToFind = SKILL_SPACT_BLOOD_STREAM
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_PERFORMAID_DESWEEPER
			ActionToFind = SKILL_SPACT_OVERRAY
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_PERFORMAID_COCRUEL
			ActionToFind = SKILL_SPACT_SHADOW_RUSH
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_PERFORMAID_BITCHIACK
			ActionToFind = SKILL_SPACT_MP_BREATH
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_LANKATA_THE_LIGHTNING_OF_BLUE
			ActionToFind = SKILL_SPACT_FIRE_A_VOLLEY
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_ZANAN_OLD_SOLDIER
			ActionToFind = SKILL_SPACT_PRESSURE
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_STORMBLING
			ActionToFind = SKILL_SPACT_BLADE_TURBULENCE
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_HELLSTLING
			ActionToFind = SKILL_SPACT_BLADE_STRINGS
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_RIANNA_THE_DAYDREAMER
			ActionToFind = SKILL_SPACT_TAG_FORCE
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_UNITDEAD_JOKER
			ActionToFind = SKILL_SPACT_OVERRAY
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_ALFRED_THE_CANGNAN_WIND
			ActionToFind = SKILL_SPACT_SHIELD_PARRY
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_CHAOS_SERPENT
			ActionToFind = SKILL_SPACT_ABYSS_IN_THE_EYE
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_AJETALIO_THE_SEMINAR_LECTURER
			ActionToFind = SKILL_SPACT_VINDALIAN_JIUJITSU
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_TEZCATLIPOCA
			ActionToFind = SKILL_SPACT_SMOKE_MIRROR
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_SILVER_FOX_BROTHER
			ActionToFind = SKILL_SPACT_RESOLUTION_HAND
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_SICKFULL_OLDER_BROTHER
			ActionToFind = SKILL_SPACT_BLOOD_STREAM
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_ALSAPIA_THE_MURDERER_MASK
			ActionToFind = SKILL_SPACT_KILLING_DANCE
			gosub *AIFindAction
			gosub *AIAddAction
			ActionToFind = SKILL_SPACT_EMERGENCY_EVASION
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_LAST_DANCER
		//	ActionToFind = SKILL_SPACT_GRAND_FINALE
		//	gosub *AIFindAction
		//	gosub *AIAddAction
			ActionToFind = SKILL_SPACT_KILLING_DANCE
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_BYSYMLHA_THE_AMBER_EYES
			ActionToFind = SKILL_SPACT_ABYSS_IN_THE_EYE
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		case CREATURE_ID_BUTLER
			ActionToFind = SKILL_SPACT_PRESSURE
			gosub *AIFindAction
			gosub *AIAddAction
			swbreak
		default
			swbreak
	swend
	return

*GetActionName
	ActionName = ""
	if ( ActionToGet >= STARTING_SKILL_SPELL ) {
		ActionName = skillname(ActionToGet)
	}
	if ( ActionToGet >= 0 & ActionToGet < STARTING_SKILL_SPELL ) {
		ActionName = AITextData(ActionToGet,0)
	}
	if ( ActionToGet == ACTION_THROW_POTION_SALT ) {
		ActionName = "Throw Salt"
	}
	if ( ActionToGet == ACTION_THROW_POTION_GREATER ) {
		ActionName = "Throw Greater Potion"
	}
	if ( ActionToGet == ACTION_THROW_POTION_MAJOR ) {
		ActionName = "Throw Major Potion"
	}
	if ( ActionToGet == ACTION_THROW_POTION_MINOR ) {
		ActionName = "Throw Potion"
	}
	return

*AIValueSetMenu
	redraw 0
	s = "Tactical Instructions", strhint3b
	display_window (windoww - 680) / 2 + inf_screenx, winposy(500, 1) + 20, 680, 500
	s = "Teach Your Pet"
	gosub *screen_drawMsg2
	NumActions = 0
	listn(0, NumActions) = "Not Set"
	key_list(NumActions) = 0
	NumActions++
	if ( AIData(25+CurrentTactic, tc-1) == 1 | AIData(25+CurrentTactic, tc-1) == 2 | AIData(25+CurrentTactic, tc-1) == 5 ) {
		repeat MAX_CHARA_FOLLOWER - 1
			if ( AITextData(cnt,4) != "NULL" ) {
				listn(0, NumActions) = AITextData(cnt, 4) + "%"
				key_list(NumActions) = 100+cnt
				NumActions++
			}
			else {
				break
			}
		loop
	}
	if ( AIData(25+CurrentTactic, tc-1) == 3 ) {
		repeat MAX_CHARA_FOLLOWER - 1
			if ( AITextData(cnt, 5) != "NULL" ) {
				listn(0, NumActions) = AITextData(cnt, 5)
				key_list(NumActions) = 200+cnt
				NumActions++
			}
			else {
				break
			}
		loop
	}
	if ( AIData(25+CurrentTactic, tc-1) == 6 ) {
		repeat MAX_CHARA_FOLLOWER - 1
			if ( AITextData(cnt, 6) != "NULL" ) {
				listn(0, NumActions) = AITextData(cnt, 6)
				key_list(NumActions) = 300+cnt
				NumActions++
			}
			else {
				break
			}
		loop
	}
	if ( AIData(25+CurrentTactic, tc-1) == 4 ) {
		repeat MAX_BUFF-1, 1
			listn(0, NumActions) = buffname(cnt)
			key_list(NumActions) = cnt
			NumActions++
		loop
	}
	if ( AIData(25+CurrentTactic, tc-1) == 7 ) {
		repeat 25
			if ( AIStatusNames(cnt, 0) != "NULL" ) {
				listn(0, NumActions) = AIStatusNames(cnt, 0)
				key_list(NumActions) = 400+cnt
				NumActions++
			}
			else {
				break
			}
		loop
	}
	listn(0, NumActions) = "Back"
	key_list(NumActions) = 999
	font lang(cfg_font1, cfg_font2), 14 - en * 2, 0

	repeat NumActions+1
		keyrange = cnt + 1
		pos wx + 18 + (145 * (cnt/22)), (wy + 25 + cnt * 19 - 2) - (416 * (cnt/22))
		cs_list listn(0, cnt), wx + 18 + (145 * (cnt/22)), (wy + 25 + cnt * 19 - 1) - (417 * (cnt/22)), 19
	loop

	font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
	gosub *PrintAIInfo
	cs_bk = cs
	redraw 1
	await cfg_wait1
	key_check
	cursor_check

	repeat 500
		if ( key == cnt ) {
			AIData(55+CurrentTactic, tc-1) = key
			cs = 0
			key = key_cancel
		}
	loop

	if ( key == key_cancel | key == 999 ) {
		cs = 0
		goto *AITacticConfigMenu
	}
	goto *AIValueSetMenu
	return

*GetValueName
	ValueName = ""
	if ( AIData(55+SlotID, tc-1) == 0 ) {
		ValueName = "Not Set"
		return
	}
	if ( AIData(55+SlotID, tc-1) < 100 ) {
		ValueName = buffname(AIData(55+SlotID, tc-1))
	}
	if ( AIData(55+SlotID, tc-1) >= 100 & AIData(55+SlotID, tc-1) < 200 ) {
		ValueName = AITextData(AIData(55+SlotID, tc-1) \ 100, 4) + "%"
	}
	if ( AIData(55+SlotID, tc-1) >= 200 & AIData(55+SlotID, tc-1) < 300 ) {
		ValueName = AITextData(AIData(55+SlotID, tc-1) \ 200, 5)
	}
	if ( AIData(55+SlotID, tc-1) >= 300 & AIData(55+SlotID, tc-1) < 400 ) {
		ValueName = AITextData(AIData(55+SlotID, tc-1) \ 300, 6)
	}
	if ( AIData(55+SlotID, tc-1) >= 400 & AIData(55+SlotID, tc-1) < 500 ) {
		ValueName = AIStatusNames(AIData(55+SlotID, tc-1) \ 400, 0)
	}
	return

*AIEntitySetMenu
	redraw 0
	s = "Tactical Instructions", strhint3b
	display_window (windoww - 680) / 2 + inf_screenx, winposy(500, 1) + 20, 680, 500
	s = "Teach Your Pet"
	gosub *screen_drawMsg2
	NumActions = 0

	repeat MAX_CHARA_FOLLOWER - 1
		if ( AITextData(cnt, 1) != "NULL" ) {
			listn(0, cnt) = AITextData(cnt, 1)
			NumActions++
		}
		else {
			break
		}
	loop

	listn(0, NumActions) = "Back"
	font lang(cfg_font1, cfg_font2), 14 - en * 2, 0

	repeat NumActions+1
		key_list(cnt) = key_select(cnt)
		keyrange = cnt + 1
		pos wx + 18, wy + 60 + cnt * 19 - 2
		gcopy 3, cnt * 24 + 72, 30, 24, 18
		cs_list listn(0, cnt), wx + 44, wy + 60 + cnt * 19 - 1, 19
	loop

	font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
	gosub *PrintAIInfo
	cs_bk = cs
	redraw 1
	await cfg_wait1
	key_check
	cursor_check

	repeat NumActions+1
		if ( key == key_select(cnt) ) {
			if ( cnt < NumActions ) {
				AIData(10+CurrentTactic, tc-1) = cnt + (AIData(10+CurrentTactic, tc-1) / 1000) * 1000
			}
			cs = 0
			key = key_cancel
		}
	loop

	if ( key == key_cancel ) {
		cs = 0
		goto *AITacticConfigMenu
	}
	goto *AIEntitySetMenu
	return

*AIConditionSetMenu
	redraw 0
	s = "Tactical Instructions", strhint3b
	display_window (windoww - 680) / 2 + inf_screenx, winposy(500, 1) + 20, 680, 500
	s = "Teach Your Pet"
	gosub *screen_drawMsg2
	NumActions = 0

	repeat MAX_CHARA_FOLLOWER - 1
		if ( AITextData(cnt, 2) != "NULL" ) {
			listn(0, cnt) = AITextData(cnt, 2)
			NumActions++
		}
		else {
			break
		}
	loop

	listn(0, NumActions) = "Back"
	font lang(cfg_font1, cfg_font2), 14 - en * 2, 0

	repeat NumActions+1
		key_list(cnt) = key_select(cnt)
		keyrange = cnt + 1
		pos wx + 18, wy + 60 + cnt * 19 - 2
		gcopy 3, cnt * 24 + 72, 30, 24, 18
		cs_list listn(0, cnt), wx + 44, wy + 60 + cnt * 19 - 1, 19
	loop

	font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
	gosub *PrintAIInfo
	cs_bk = cs
	redraw 1
	await cfg_wait1
	key_check
	cursor_check

	repeat NumActions+1
		if ( key == key_select(cnt) ) {
			if ( cnt < NumActions ) {
				AIData(25+CurrentTactic, tc-1) = cnt
				if ( cnt == 4 | cnt == 6 | cnt == 7 ) {
					AIData(40+CurrentTactic, tc-1) = 0
				}
				AIData(55+CurrentTactic, tc-1) = 0
			}
			cs = 0
			key = key_cancel
		}
	loop

	if ( key == key_cancel ) {
		cs = 0
		goto *AITacticConfigMenu
	}
	goto *AIConditionSetMenu
	return

*AIComparatorSetMenu
	redraw 0
	s = "Tactical Instructions", strhint3b
	display_window (windoww - 680) / 2 + inf_screenx, winposy(500, 1) + 20, 680, 500
	s = "Teach Your Pet"
	gosub *screen_drawMsg2
	NumActions = 0

	sdim AIComparatorFix, 30, 15

	repeat MAX_CHARA_FOLLOWER - 1
		if ( AITextData(cnt, 3) != "NULL" ) {
			; "Not Set", "=" and "!=" are always included
			if ( cnt == 0 | (AIData(25+CurrentTactic, tc-1) != 4 & AIData(25+CurrentTactic, tc-1) != 6 & AIData(25+CurrentTactic, tc-1) != 7 ) | (cnt == 3) | (cnt == 4) ) {
				listn(0, NumActions) = AITextData(cnt, 3)
				key_list(NumActions) = key_select(NumActions)
				AIComparatorFix(NumActions) = cnt

				NumActions++
			}
		}
		else {
			break
		}
	loop

	listn(0, NumActions) = "Back"
	key_list(NumActions) = key_select(16)
	font lang(cfg_font1, cfg_font2), 14 - en * 2, 0

	repeat NumActions + 1
		keyrange = cnt + 1
		pos wx + 18, wy + 60 + cnt * 19 - 2
		gcopy 3, cnt * 24 + 72, 30, 24, 18
		cs_list listn(0, cnt), wx + 44, wy + 60 + cnt * 19 - 1, 19
	loop

	font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
	gosub *PrintAIInfo
	cs_bk = cs
	redraw 1
	await cfg_wait1
	key_check
	cursor_check

	repeat MAX_CHARA_FOLLOWER - 1
		if ( key == key_select(cnt) & cnt < NumActions + 1 ) {
			if ( cnt < NumActions ) {
				AIData(40+CurrentTactic, tc-1) = AIComparatorFix(cnt)
			}
			cs = 0
			key = key_cancel

			break
		}
	loop

	if ( key == key_cancel | key == key_select(16) ) {
		cs = 0
		goto *AITacticConfigMenu
	}
	goto *AIComparatorSetMenu
	return

*DeleteAIInfo
	LoopCount = 0

	while ( LoopCount < 125 )
		AIData(LoopCount, AllyID-1) = 0
		LoopCount++
	wend

	return

/********** ANNA CUSTOM - ENDING **********/

*export_chara
	sdim headtemp, 1024
	id = 0
	lensum = 1024
	sdim filebuff, lensum
	headtemp = "【" + gdatan(GDATAN_TEAM1) + "】(" + n + "体) Lv" + lv + "\n"
	headtemp += "" + cdatan(CDATAN_AKA, CHARA_PLAYER) + cdatan(CDATAN_NAME, CHARA_PLAYER) + "\n"
	headtemp += "\n"
	headtemp += "\n"
	headtemp += "" + 100002 + "\n"
	headtemp += "" + n + "\n"
	headtemp += "" + lv + "\n"
	memcpy filebuff, headtemp, 1024, 0
	fmode = 22
	gosub *game_ctrlFile
	bsave userfile, filebuff
	gosub *del_userTemp
	return

*del_userNpc
	procid = (procid + 1) \ 4
	proclist(procid) = "del_userNpc" + " ct:" + ct
	dirlist buff, exedir + "user\\_tmp_*.npc"
	notesel buff
	repeat stat
		noteget file, cnt
		delete exedir + "user\\" + file
	loop
	dirlist buff, exedir + "user\\!tmp*.npc"
	notesel buff
	repeat stat
		noteget file, cnt
		delete exedir + "user\\" + file
	loop
	return

*del_userTemp
	procid = (procid + 1) \ 4
	proclist(procid) = "del_userTemp" + " ct:" + ct
	dirlist buff, exedir + "user\\*.t"
	notesel buff
	repeat stat
		noteget file, cnt
		delete exedir + "user\\" + file
	loop
	return

*game_load
	filemod = ""
	fmode = 10
	gosub *game_ctrlFile
	folder = exedir + "save\\" + playerid + "\\"
	exist folder + "filelist.txt"
	if ( strsize != (-1) ) {
		delete folder + "filelist.txt"
	}
	fmode = 7
	gosub *game_ctrlFile
	gosub *fixSave
	gosub *db_setItem
	repeat MAX_CHARA_FOLLOWER
		if ( cbit(CHARA_BIT_PCC, cnt) == 1 | cnt == CHARA_PLAYER ) {
			create_pcpic cnt, 1
		}
	loop
	if ( gdata(GDATA_WIZARD) == 1 ) {
		cdatan(CDATAN_AKA, CHARA_PLAYER) = "*Debug*"
	}
	refreshspeed 0
	time_begin = timeGetTime() / 1000
	return

*game_save
	if ( gdata(GDATA_AREA) == AREA_SHOW_HOUSE | (gdata(GDATA_AREA) == AREA_CHAOS_CRADLE & gdata(GDATA_LEVEL) == 179) ) {
		txtef COLOR_RED
		txt lang("ここではセーブされない。", "The game is not saved in this map.")
		gosub *screen_draw
		return
	}
	procid = (procid + 1) \ 4
	proclist(procid) = "game_save" + " ct:" + ct
	fmode = 2
	gosub *game_ctrlFile
	file = "inv_" + mid + ".s2"
	fmode = 4
	gosub *game_ctrlFile
	file = exedir + "save\\" + playerid
	dirlist save_buff, file, 5
	notesel save_buff
	save_f = 0
	repeat noteinfo(0)
		noteget save_s, cnt
		if ( save_s == playerid ) {
			save_f = 1
			break
		}
	loop
	if ( save_f == 0 ) {
		mkdir file
	}
	file += "\\"
	notesel filemod
	repeat noteinfo(0)
		noteget save_s, cnt
		if ( strmid(save_s, 0, 1) == "*" ) {
			save_p = 0
		}
		else {
			save_p = 1
		}
		save_s = strmid(save_s, 1, strlen(save_s))
		if ( save_p == 0 ) {
			bcopy save_s, file + getpath(save_s, 8)
		}
		else {
			exist file + getpath(save_s, 8)
			if ( strsize != (-1) ) {
				delete file + getpath(save_s, 8)
			}
		}
	loop
	fmode = 8
	gosub *game_ctrlFile
	filemod = ""
	return

*extract_map
	snd SOUNDLIST_EXITMAP1
	gdata(GDATA_RETURN_AREA) = gdata(GDATA_AREA), gdata(GDATA_LEVEL), cdata(CDATA_X, CHARA_PLAYER), cdata(CDATA_Y, CHARA_PLAYER)
	gdata(GDATA_TELEPORT_AREA) = AREA_SHOW_HOUSE
	gdata(GDATA_TELEPORT_LEVEL) = 1
	levelexitby = 2
	goto *map_exit

*game_title
	if ( cfg_titledialog ) {
		dialog lang("＜利用規約＞\n\n elonaplusはフリーウェアであり、elonaの二次創作です。\n・本ソフトウェアは現在開発中です。不具合やバランスの急激な変動があります。\n・原作および他二次創作の作者・バランス・設定等を否定する意図はありません。\n・暴力的・性的・猟奇的な表現、描写が多数存在します。\n・本ソフトの利用によっていかなる不利益が発生した場合でも作者は一切の責任を負いません。自己責任で利用してください。\n・興味を持っていない人への過度の推薦や紹介は控え、wikiへの誘導程度に留めてください。\n・βテストプレイヤーとしてデバッグ義務なく普通に遊ぶことができますが、プレイ中にバグに遭遇した場合は報告していただけると助かります(任意)。\nただし、せっかく報告していただいても内容が不足しているとバグ修正に結びつかないため、テンプレートを用いた報告や検証にご協力ください。\n\n同梱の説明書(elona,elonaplus)にも目を通し、上記項目を含めて理解・承服できる方のみ利用できます。", "Elonaplus is a freeware, This is a secondary creation of elona. \n * This software is currently in development. There are defect and abrupt change of balance. \n * There is no intention to deny the author, balance, setting, of the other secondary creations and original creation. \n * There are many violent, sexual, bizarre, depictions. \n * Even if any disadvantage was caused by use of this software, the author does not take any responsibility. Please use at your own risk. \n * If you can comply the instructions and the above-mentioned items, you can use this software.")
	}

	/********** ANNA CUSTOM - BEGINNING **********/

	if ( dirinfo(4) == "export" ) {
		gosub *ExportCardDescriptions
		gosub *ExportItemDB
	}

	gosub *Load_Item_Highlights

	/********** ANNA CUSTOM - ENDING **********/

	mode = MODELIST_TITLE
	lomiaseaster = 0
	music = MUSICLIST_MCOPENING
	gosub *music_play
	cs = 0
	cs_bk = -1
	keyrange = 6
	key_list = "a", "b", "c", "d", "e", "f"
	pagesize = 0
	redraw 0
	gsel 2
	repeat 8
		pos cnt \ 4 * 180, cnt / 4 * 300
		picload exedir + "\\graphic\\g" + (cnt + 1) + ".bmp", 1
	loop
	gsel 4
	gmode 0
	pos 0, 0
	picload exedir + "\\graphic\\title" + devfile + ".bmp", 1
	gzoom windoww, windowh, 4, 0, 0, 800, 600
	gmode 2
	font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
	color 255, 255, 255
	pos 20, 2
	mes "Elona  Developed by Noa"
	pos 20, 20
	mes "ElonaPlus  Developed by Ano"
	pos 20, 38

	/********** ANNA CUSTOM - BEGINNING **********/

	mes "ElonaPlus Custom originally created by AnnaBannana"
	pos 20, 56
	mes "ElonaPlus Custom maintained by AnnaBannana & BloodyShade, contributions by Hebiko, Glyphy, Jehmil, et al"
	pos 20, 74
	mes "Elona+ Custom-G mod created by Glyphy"
	pos 20, 92
	mes "Elona+ Custom-GX created by Ruin0x11"
	pos 20, 110

	/********** ANNA CUSTOM - ENDING **********/

	if ( jp ) {
		mes "Contributor MSL / View the credits for more"
	}
	else {
		mes "Contributor f1r3fly, Sunstrike, Schmidt, Elvenspirit / View the credits for more"
	}
	s = lang("冒険の道標", "Starting Menu"), strhint1
	windowshadow = 1
	display_window 80, winposy(308, 1), 320, 320
	cmbg = 4
	x = ww / 5 * 4
	y = wh - 80
	gmode 4, 180, 300, 50
	pos wx + 160, wy + wh / 2
	grotate 2, cmbg / 2 * 180, cmbg \ 2 * 300, 0, x, y
	gmode 2
	if ( jp ) {
		s = "Restore an adventurer", "冒険を再開する", "Generate an adventurer", "新しい冒険者を作成する", "Incarnate an adventurer", "冒険者の引継ぎ", "View the homepage", "本家Elonaホームページ", "Configure", "設定の変更", "Exit", "終了"
	}
	if ( en ) {
		s = "Restore an Adventurer", "Generate an Adventurer", "Incarnate an Adventurer", "View the Homepage", "Options", "Exit"
	}
	if ( water_debug == 0 ) {
		water_getimage
		water_debug = 1
	}
	gsel 0
	gmode 0
	pos 0, 0
	gcopy 4, 0, 0, windoww, windowh
	gmode 2
*game_title_WHILE1
	if ( cfg_autonumlock ) {
		GetKeyboardState keybd_st
		if ( peek(keybd_st, 144) == 1 ) {
			keybd_event 144
			keybd_event 144, 0, 2
		}
	}
	redraw 0
	if ( cfg_titleeffect ) {
		tx += (rnd(10) + 2) * p(1)
		ty += (rnd(10) + 2) * p(2)
		if ( rnd(10) == 0 ) {
			tx = rnd(800)
			ty = rnd(600)
			p(1) = rnd(9) - 4, rnd(9) - 4
		}
		f = 0
		if ( tx > 40 & tx < 500 & ty > 100 & ty < 450 ) {
			f = 1
		}
		if ( f == 0 ) {
			if ( rnd(10) == 0 ) {
				f = 2
			}
		}
		if ( f == 0 ) {
			water_setripple tx, ty, rnd(300), rnd(4)
		}
		water_calc
	}
	else {
		water_refresh
	}
	water_draw
	cs_listbk
	repeat 6
		x = wx + 40
		y = cnt * 35 + wy + 50
		display_customkey key_list(cnt), x, y
		if ( jp ) {
			font lang(cfg_font1, cfg_font2), 11 - en * 2, 0
			pos x + 40, y - 4
			mes s(cnt * 2)
			font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
			cs_list s(cnt * 2 + 1), x + 40, y + 8, 19
		}
		else {
			font lang(cfg_font1, cfg_font2), 14 - en * 2, 0
			cs_list s(cnt), x + 40, y + 1, 19
		}
	loop
	cs_bk = cs
	redraw 1
	await cfg_wait1
	key_check
	cursor_check
	if ( key == "b" ) {
		snd SOUNDLIST_OK1
		geneuse = ""
		goto *cm_init
	}
	if ( key == "a" ) {
		snd SOUNDLIST_OK1
		goto *game_title_selectID
	}
	if ( key == "c" ) {
		snd SOUNDLIST_OK1
		goto *game_title_selectGen
	}
	if ( key == "d" ) {
		snd SOUNDLIST_OK1
		exec homepage, 16
	}
	if ( key == "e" ) {
		snd SOUNDLIST_OK1
		goto *com_config
	}
	if ( key == "f" ) {
		snd SOUNDLIST_OK1
		await 400
		goto *exit_game
	}
	goto *game_title_WHILE1

*game_title_selectID
	cs = 0
	cs_bk = -1
	redraw 0
	gsel 4
	pos 0, 0
	picload exedir + "\\graphic\\void.bmp", 1
	gzoom windoww, windowh, 4, 0, 0, 800, 600
	gsel 0
	gmode 0
	pos 0, 0
	gcopy 4, 0, 0, windoww, windowh
	gmode 2
	s = lang("どの冒険を再開するんだい？", "Which save game do you want to continue?")
	gosub *screen_drawMsg2
	file = exedir + "save\\*"
	dirlist buff, file, 5
	notesel buff
	keyrange = 0
	repeat noteinfo(0)
		noteget s, cnt
		file = exedir + "save\\" + s + "\\header.txt"
		exist file
		if ( strsize == (-1) ) {
			notedel cnt
			if ( cnt < noteinfo(0) ) {
				continue cnt
			}
			else {
				break
			}
		}
		bload file, playerheader
		list(0, cnt) = cnt
		listn(0, cnt) = s, "" + playerheader
		key_list(cnt) = key_select(cnt)
		keyrange++
	loop
	windowshadow = 1
*game_title_selectID_WHILE1
	redraw 0
	s = lang("冒険者の選択", "Game Selection"), lang("BackSpace [削除]  ", "BackSpace [Delete]  ") + strhint3b
	display_window (windoww - 440) / 2 + inf_screenx, winposy(288, 1), 440, 288
	cs_listbk
	repeat noteinfo(0)
		x = wx + 20
		y = cnt * 40 + wy + 50
		display_key x + 20, y - 2, cnt
		font lang(cfg_font1, cfg_font2), 11 - en * 2, 0
		pos x + 48, y - 4
		mes listn(0, cnt)
		font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
		cs_list listn(1, cnt), x + 48, y + 8, 19
	loop
	cs_bk = cs
	if ( noteinfo(0) == 0 ) {
		font lang(cfg_font1, cfg_font2), 14 - en * 2, 0
		color 0, 0, 0
		pos wx + 140, wy + 120
		mes "No save files found"
	}
	redraw 1
	await cfg_wait1
	key_check
	cursor_check
	p = -1
	repeat keyrange
		if ( key == key_select(cnt) ) {
			p = list(0, cnt)
			break
		}
	loop
	if ( p != (-1) ) {
		playerid = listn(0, p)
		snd SOUNDLIST_OK1
		await 200
		mode = MODELIST_CONTINUE
		music = MUSICLIST_NONE
		goto *world_init
	}
	getkey a, 8
	if ( ginfo(2) == 0 ) {
		if ( noteinfo(0) != 0 ) {
			if ( a == 1 ) {
				p = list(0, cs)
				playerid = listn(0, p)
				s = lang("本当に" + playerid + "を削除していいのかい？", "Do you really want to delete " + playerid + " ?")
				gosub *screen_drawMsg2
				promptYesNo 200
				if ( rtval != 0 ) {
					goto *game_title_selectID
				}
				s = lang("本当の本当に" + playerid + "を削除していいのかい？", "Are you sure you really want to delete " + playerid + " ?")
				gosub *screen_drawMsg2
				promptYesNo 200
				if ( rtval == 0 ) {
					snd SOUNDLIST_OK1
					fmode = 9
					gosub *game_ctrlFile
				}
				goto *game_title_selectID
			}
		}
	}
	if ( key == key_cancel ) {
		goto *game_title
	}
	goto *game_title_selectID_WHILE1

*game_title_selectGen
	cs = 0
	cs_bk = -1
	redraw 0
	gsel 4
	pos 0, 0
	picload exedir + "\\graphic\\void.bmp", 1
	gzoom windoww, windowh, 4, 0, 0, 800, 600
	gsel 0
	gmode 0
	pos 0, 0
	gcopy 4, 0, 0, windoww, windowh
	gmode 2
	s = lang("どの遺伝子を引き継ぐ？", "Which gene do you want to incarnate?")
	gosub *screen_drawMsg2
	file = exedir + "save\\*"
	dirlist buff, file, 5
	notesel buff
	keyrange = 0
	listmax = 0
	repeat noteinfo(0)
		noteget s, cnt
		file = exedir + "save\\" + s + "\\gene_header.txt"
		exist file
		await
		if ( strsize == (-1) ) {
			continue
		}
		bload file, playerheader
		list(0, listmax) = listmax
		listn(0, listmax) = s, "" + playerheader
		key_list(listmax) = key_select(listmax)
		keyrange++
		listmax++
	loop
	windowshadow = 1
*game_title_selectGen_WHILE1
	redraw 0
	s = lang("遺伝子の選択", "Gene Selection"), strhint3b
	display_window (windoww - 440) / 2 + inf_screenx, winposy(288, 1), 440, 288
	cs_listbk
	repeat listmax
		x = wx + 20
		y = cnt * 40 + wy + 50
		display_key x + 20, y - 2, cnt
		font lang(cfg_font1, cfg_font2), 11 - en * 2, 0
		pos x + 48, y - 4
		mes listn(0, cnt)
		font lang(cfg_font1, cfg_font2), 13 - en * 2, 0
		cs_list listn(1, cnt), x + 48, y + 8, 19
	loop
	cs_bk = cs
	if ( listmax == 0 ) {
		font lang(cfg_font1, cfg_font2), 14 - en * 2, 0
		color 0, 0, 0
		pos wx + 140, wy + 120
		mes "No gene files found."
	}
	redraw 1
	await cfg_wait1
	key_check
	cursor_check
	p = -1
	repeat keyrange
		if ( key == key_select(cnt) ) {
			p = list(0, cnt)
			break
		}
	loop
	if ( p != (-1) ) {
		snd SOUNDLIST_OK1
		geneuse = listn(0, p)
		playerid = listn(0, p)
		goto *cm_init
	}
	if ( key == key_cancel ) {
		goto *game_title
	}
	goto *game_title_selectGen_WHILE1

*define_los
	dim fovlist, 2, 17
	dim fovmap, 17 * 2 + 4, 17 * 2
	if ( cdata(CDATA_FOV, CHARA_PLAYER) < 1 ) {
		cdata(CDATA_FOV, CHARA_PLAYER) = 1
	}
	if ( cdata(CDATA_FOV, CHARA_PLAYER) >= 17 ) {
		cdata(CDATA_FOV, CHARA_PLAYER) = 17 - 1
	}
	repeat 17
		y = cnt
		repeat 17
			x = cnt
			if ( dist(x, y, 17 / 2, 17 / 2) < (17 - 2) / 2 + 1 ) {
				fovmap(x, y) = 1
			}
		loop
	loop
	repeat 17
		y = cnt
		p(1) = 0
		repeat 17
			x = cnt
			p = fovmap(x, y)
			if ( p != 0 & p(1) == 0 ) {
				fovlist(0, y) = x
				p(1) = 1
			}
			if ( p == 0 & p(1) == 1 ) {
				fovlist(1, y) = x
				break
			}
		loop
	loop
	return

*esc_check
	if ( wparam == 27 ) {
		if ( ginfo(2) == 0 ) {
			ime_esc = 1
		}
	}
	return

*prompt_word
	snd SOUNDLIST_POP2
	x = val
	y = val(1)
	dx = val(2) * 16 + 60
	font lang(cfg_font1, cfg_font2), 16 - en * 2, 0
	inputfail = 0
	sdim inputlog2
	if ( val(4) != 0 ) {
		val(5) = val(4)
		if ( strlen(str(val(5))) >= 3 ) {
			dx += strlen(str(val(5))) * 8
		}
		redraw 0
		pos x + 24, y + 4
		gfini dx - 42, 35
		gfdec 60, 60, 60
		repeat
			redraw 0
			window2 x + 20, y, dx - 40, 36, 0, 2
			pos x + dx / 2 - 56, y - 32
			gcopy 3, 128, 288, 128, 32
			pos x + 28, y + 4
			gcopy 3, 312, 336, 24, 24
			pos x + dx - 51, y + 4
			gcopy 3, 336, 336, 24, 24
			inputlog2 = "" + int(inputlog) + "(" + val(5) + ")"
			pos x + dx - 70 - strlen(inputlog2) * 8 + 8, y + 11
			color 255, 255, 255
			mes inputlog2
			redraw 1
			await cfg_wait1
			key_check
			if ( key == key_enter ) {
				f = 1
				break
			}
			if ( key == key_cancel ) {
				if ( val(3) == 1 ) {
					f = -1
					break
				}
			}
			if ( key == key_west ) {
				snd SOUNDLIST_CURSOR1
				val(4)--
				if ( val(4) < 1 ) {
					val(4) = val(5)
				}
			}
			if ( key == key_east ) {
				snd SOUNDLIST_CURSOR1
				val(4)++
				if ( val(4) > val(5) ) {
					val(4) = 1
				}
			}
			if ( key == key_south ) {
				snd SOUNDLIST_CURSOR1
				val(4) = 1
			}
			if ( key == key_north ) {
				snd SOUNDLIST_CURSOR1
				val(4) = val(5)
			}
			inputlog = "" + val(4)
		loop
		if ( f == (-1) ) {
			inputlog = ""
			rtval = -1
		}
		keywait = 1
		key = ""
		rtval = 0
		return
	}
	redraw 0
	objmode 2, 0
	if ( cfg_msg_box == 0 ) {
		pos x + 4, y + 4
		mesbox inputlog, dx - 8, 26, 1, val(2) * (1 + en)
	}
	else {
		pos x, y
		mesbox inputlog, 600, 0, 5, val(2) * (1 + en)
		pos x + 4, y + 4
		gfini dx - 1, 35
		gfdec 60, 60, 60
		aplsel "ElonaPlus 1.90"
		if ( stat == 1 ) {
			dialog "Failed to get WINDOW ID", 1
			clrobj 1
			cfg_msg_box = 0
			goto *prompt_word
		}
		aplobj "", 1
		if ( stat == 1 ) {
			dialog "Failed to get OBJECT ID", 1
			clrobj 1
			cfg_msg_box = 0
			goto *prompt_word
		}
	}
	notesel inputlog
	p(1) = 2
	ime_esc = 0
	onkey 1
	repeat
		if ( ginfo(2) == 0 ) {
			objsel 1
		}
		else {
			objprm 1, ""
			inputlog = ""
			await 100
			continue cnt
		}
		redraw 0
		await 40
		window2 x, y, dx, 36, 0, 2
		pos x + dx / 2 - 60, y - 32
		gcopy 3, 128, 288, 128, 32
		if ( cfg_msg_box == 1 ) {
			pos x + 8, y + 4
			if ( imeget() != 0 ) {
				gcopy 3, 48, 336, 24, 24
			}
			else {
				gcopy 3, 24, 336, 24, 24
			}
			apledit p(2), 2, 0
			if ( p(2) > val(2) * (1 + en) - 2 ) {
				pos x + 8, y + 4
				gcopy 3, 72, 336, 24, 24
			}
			if ( cnt \ 20 < 10 ) {
				p(1) = p(1) * 2
			}
			else {
				p(1) = p(1) / 2
			}
			apledit p(2), 0
			p(4) = 0
			repeat p(2)
				p(3) = peek(inputlog, p(4))
				if ( p(3) >= 129 & p(3) <= 159 | (p(3) >= 224 & p(3) <= 252) ) {
					p(4) += 2
				}
				else {
					p(4) += 1
				}
			loop
			gmode 4, , , p(1) / 2 + 50
			pos x + 34 + p(4) * 8, y + 5
			color 0, 0, 0
			gcopy 3, 0, 336, 12, 24
			gmode 2
			color 255, 255, 255
			pos x + 36, y + 9
			noteget s, 0
			mes s
		}
		if ( instr(inputlog, 0, "\n") != (-1) ) {
			rtval = 0
			break
		}
		if ( instr(inputlog, 0, "\t") != (-1) ) {
			objprm 1, ""
			inputlog = ""
			if ( val(3) == 1 ) {
				ime_esc = 1
			}
		}
		redraw 1
		if ( val(3) == 1 ) {
			if ( ime_esc == 1 ) {
				inputlog = ""
				keywait = 1
				key = ""
				break
			}
		}
	loop
	gmode 2
	clrobj 1
	if ( inputfail ) {
		cfg_msg_box = 0
		goto *prompt_word
	}
	if ( input_mode == 1 ) {
		cnv_filestr inputlog
	}
	input_mode = 0
	if ( en ) {
		cnv_str inputlog, "\"", "'"
	}
	rm_crlf inputlog
	onkey 0
	return

*prompt_direction
	snd SOUNDLIST_POP2
	redraw 0
	gsel 4
	x = (cdata(CDATA_X, CHARA_PLAYER) - scx) * inf_tiles + inf_screenx - 48
	y = (cdata(CDATA_Y, CHARA_PLAYER) - scy) * inf_tiles + inf_screeny - 48
	gmode 0
	pos 0, 0
	gcopy 0, x, y, 48 * 3, 48 * 3
	gsel 0
	t = 0
*prompt_direction_WHILE1
	t++
	gmode 4, 28, 28, 200 - t / 2 \ 20 * (t / 2 \ 20)
	color 0, 0, 0
	x = (cdata(CDATA_X, CHARA_PLAYER) - scx) * inf_tiles + inf_screenx + 24
	y = (cdata(CDATA_Y, CHARA_PLAYER) - scy) * inf_tiles + inf_screeny + 24
	if ( key_alt == 0 ) {
		pos x, y - 48
		grotate 3, 212, 432, 0, 28, 28
		pos x, y + 48
		grotate 3, 212, 432, 1.0 * 3.14, 28, 28
		pos x + 48, y
		grotate 3, 212, 432, 0.5 * 3.14, 28, 28
		pos x - 48, y
		grotate 3, 212, 432, 1.5 * 3.14, 28, 28
	}
	pos x - 48, y - 48
	grotate 3, 212, 432, 1.75 * 3.14, 28, 28
	pos x + 48, y + 48
	grotate 3, 212, 432, 0.75 * 3.14, 28, 28
	pos x + 48, y - 48
	grotate 3, 212, 432, 0.25 * 3.14, 28, 28
	pos x - 48, y + 48
	grotate 3, 212, 432, 1.25 * 3.14, 28, 28
	redraw 1
	redraw 0
	gmode 0
	pos x - 48 - 24, y - 48 - 24
	gcopy 4, 0, 0, 48 * 3, 48 * 3
	gmode 2
	await 30
	key_check 1
	x = cdata(CDATA_X, CHARA_PLAYER)
	y = cdata(CDATA_Y, CHARA_PLAYER)
	if ( key == key_alter ) {
		goto *prompt_direction_WHILE1_CONTINUE
	}
	if ( key == key_wait | key == key_enter ) {
		tlocx = x
		tlocy = y
		keyhalt = 1
		return 1
	}
	if ( key == key_north ) {
		if ( key_alt ) {
			goto *prompt_direction_WHILE1_CONTINUE
		}
		else {
			y -= 1
		}
	}
	if ( key == key_south ) {
		if ( key_alt ) {
			goto *prompt_direction_WHILE1_CONTINUE
		}
		else {
			y += 1
		}
	}
	if ( key == key_west ) {
		if ( key_alt ) {
			goto *prompt_direction_WHILE1_CONTINUE
		}
		else {
			x -= 1
		}
	}
	if ( key == key_east ) {
		if ( key_alt ) {
			goto *prompt_direction_WHILE1_CONTINUE
		}
		else {
			x += 1
		}
	}
	if ( key == key_northwest ) {
		x -= 1
		y -= 1
	}
	if ( key == key_northeast ) {
		x += 1
		y -= 1
	}
	if ( key == key_southwest ) {
		x -= 1
		y += 1
	}
	if ( key == key_southeast ) {
		x += 1
		y += 1
	}
	if ( key != "" ) {
		if ( x < 0 | y < 0 | x >= mdata(MDATA_WIDTH) | y >= mdata(MDATA_HEIGHT) ) {
			x = cdata(CDATA_X, CHARA_PLAYER)
			y = cdata(CDATA_Y, CHARA_PLAYER)
			keyhalt = 1
			return 0
		}
		if ( x == cdata(CDATA_X, CHARA_PLAYER) & y == cdata(CDATA_Y, CHARA_PLAYER) ) {
			return 0
		}
		tlocx = x
		tlocy = y
		keyhalt = 1
		return 1
	}
*prompt_direction_WHILE1_CONTINUE
	goto *prompt_direction_WHILE1

*prompt_key
	snd SOUNDLIST_POP2
	csprev = cs
	cs = 0
	cs_bk = -1
	redraw 0
	gsel 3
	gmode 0
	font lang(cfg_font1, cfg_font2), 15 - en * 2, 0
	repeat promptmax
		if ( promptl(1, cnt) == "null" ) {
			promptl(1, cnt) = key_select(cnt)
		}
		pos cnt * 24 + 624, 30
		gcopy 3, 0, 30, 24, 18
		pos cnt * 24 + 629, 31
		color 50, 60, 80
		bmes promptl(1, cnt), 250, 240, 230
	loop
	gsel 0
	sx = val - val(2) / 2
	sy = val(1) - promptmax * 10
	pos sx + 12, sy + 12
	gfini val(2) - 17, promptmax * 20 + 43 - 18
	gfdec 60, 60, 60
	keyhalt = 1
	if ( val(3) == 2 ) {
		dx = 200, 10
		dy = sy + 140
		val(5) = val(4)
		val(4) = 1
		val = 1
		if ( strlen(str(val(5))) >= 3 ) {
			dx += strlen(str(val(5))) * 8
		}
		pos dx(1) + sx + 24, dy + 4
		gfini dx - 42, 35
		gfdec 60, 60, 60
	}
*prompt_key_WHILE1
	redraw 0
	gmode 2
	if ( val(3) == 2 ) {
		window2 dx(1) + sx + 20, dy, dx - 40, 36, 0, 2
		pos dx(1) + sx + dx / 2 - 56, dy - 32
		gcopy 3, 128, 288, 128, 32
		pos dx(1) + sx + 28, dy + 4
		gcopy 3, 312, 336, 24, 24
		pos dx(1) + sx + dx - 51, dy + 4
		gcopy 3, 336, 336, 24, 24
		inputlog2 = "" + int(inputlog) + "(" + val(5) + ")"
		pos dx(1) + sx + dx - 70 - strlen(inputlog2) * 8 + 8, dy + 11
		color 255, 255, 255
		mes inputlog2
		inputlog = "" + val(4)
	}
	window2 sx + 8, sy + 8, val(2) - 16, promptmax * 20 + 42 - 16, 0, 0
	pos sx - 16, sy
	gcopy 3, 64, 288, 50, 32
	color 255, 255, 255
	font lang(cfg_font1, cfg_font2), 14 - en * 2, 0
	keyrange = 0
	cs_listbk
	repeat promptmax
		pos sx + 30, cnt * 20 + sy + 22
		gcopy 3, cnt * 24 + 624, 30, 24, 24
		cs_list promptl(0, cnt), sx + 56, cnt * 20 + sy + 21, 19
		key_list(cnt) = promptl(1, cnt)
		keyrange++
	loop
	cs_bk = cs
	if ( rpmode ) {
		window_recipe2
		color 255, 255, 255
		font lang(cfg_font1, cfg_font2), 14 - en * 2, 0
	}
	redraw 1
	await cfg_wait1
	key_check
	cursor_check
	rtval = -1
	repeat promptmax
		if ( key == promptl(1, cnt) ) {
			rtval = int(promptl(2, cnt))
			break
		}
	loop
	if ( val(3) == 2 ) {
		val = int(inputlog)
		if ( key == key_west | key == key_pagedown ) {
			snd SOUNDLIST_CURSOR1
			val(4)--
			if ( val(4) < 1 ) {
				val(4) = val(5)
			}
		}
		if ( key == key_east | key == key_pageup ) {
			snd SOUNDLIST_CURSOR1
			val(4)++
			if ( val(4) > val(5) ) {
				val(4) = 1
			}
		}
	}
	if ( rtval != (-1) ) {
		promptmax = 0
		cs = csprev
		return 1
	}
	if ( val(3) != 0 ) {
		if ( key == key_cancel ) {
			promptmax = 0
			cs = csprev
			return 0
		}
	}
	goto *prompt_key_WHILE1

*game_debug
	notesel dbm
	buff = ""
	if ( dbm == "" ) {
		noteadd "ElonaPlus 1.90" + " v" + "3.21" + " Debug Console    Type \"?\" for help. Hit ESC to exit."
		noteadd ""
	}
	font lang(cfg_font1, cfg_font2), 14 - en * 2, 0
	objmode 2
	pos 0, 24
	mesbox dbm, 800, 576, 0
	pos 0, 0
	mesbox buff, 800, 24, 1
	objsel 2
*game_debug_WHILE1
	await 20
	stick a
	if ( a == 128 ) {
		goto *game_debug_WEND1
	}
	if ( a == 32 ) {
		gosub *dbg_GetInfo
	}
	goto *game_debug_WHILE1
*game_debug_WEND1
	clrobj 1
	clrobj 2
	if ( dbg_exitshowroom == 1 ) {
		dbg_exitshowroom = 0
		levelexitby = 4
		goto *map_exit
	}
	goto *pc_turn

*dbg_GetInfo
	if ( instr(buff, 0, "?") != (-1) ) {
		noteadd "\t1\t\tShows charainfo."
		noteadd "\t2\t\tShows pc equipment."
		noteadd "\t3\t\tShows pc inventory."
		noteadd "\t4\t\tBegin/end var-comparison."
		noteadd "\t5\t\tShows core game data."
		noteadd "\tdel\t\tDeletes current log."
		noteadd "\tquest\t\tLists all the quests."
		noteadd "\tclient\t\tLists all the clients."
		noteadd "\texitroom\tLeaves current show-room."
		noteadd "\twizard\t\tEnables wizard mode."
		noteadd ""
		noteadd "\tThe commands below can be used in the Wizard mode."
		noteadd "\tgain_spell\tPC gains all spells."
		noteadd "\tgain_spact\tPC gains all special actions."
		noteadd "\tgain_exp\tPC gains a billion of exp."
		noteadd "\tgain_fame\tPC gains fame."
		noteadd "\tallinv\t\tDisplays all the items in the map."
		noteadd ""
		noteadd "\tThe commands below should be only used to deal with certain problems."
		noteadd "\t108fix\t\tTurns all the NPCs in the map hostile."
		noteadd "\tadvreset\tRemoves all items from adventureres."
		noteadd "\tfixcorrupt1\tTries to fix corrputed save files."
		noteadd "\tfreemove\tEnables freemove."
		noteadd "\tresetmap\tResets towns and some areas."
		noteadd "\tfixmap\t\tFixes possible bugs for current map."
		noteadd "\tmapinfo\t\tShows map info."
		goto *console_write
	}
	if ( int(buff) == 1 ) {
		repeat MAX_CHARA_TOTAL
			noteadd "" + cnt + "\t" + cdatan(CDATAN_NAME, cnt) + "\tExist:" + cdata(CDATA_EXIST, cnt) + "\tRespawn:" + cdata(CDATA_RESPAWN, cnt) + "\tRole:" + cdata(CDATA_ROLE, cnt)
		loop
		goto *console_write
	}
	if ( int(buff) == 2 ) {
		repeat 30
			p = 100 + cnt
			if ( cdata(p, CHARA_PLAYER) != 0 ) {
				p(1) = cdata(p, CHARA_PLAYER)
				s = "" + p + "\t" + p(1) + "\t"
				if ( p(1) \ 10000 > 0 ) {
					s += itemname(p(1) \ 10000 - 1)
				}
				noteadd s
			}
		loop
		goto *console_write
	}
	if ( int(buff) == 3 ) {
		inv_getheader 0
		repeat invrange, invhead
			noteadd "" + cnt + "\t" + itemname(cnt) + "\t"
		loop
		goto *console_write
	}
	if ( int(buff) == 4 ) {
		if ( dbg_compare == 0 ) {
			sdim cdatan2, 40, MAX_CDATAN, MAX_CHARA_TOTAL
			dim cdata2, MAX_CHARA_DATA, MAX_CHARA_TOTAL
			dim sdata2, MAX_SKILL_DATA, MAX_CHARA_TOTAL
			dim inv2, INV_ITEM_MAX, MAX_INV_DATA
		}
		noteadd "cdata"
		repeat MAX_CHARA_TOTAL
			cnt2 = cnt
			repeat MAX_CHARA_DATA
				s = ""
				if ( cnt == 6 | cnt == 10 ) {
					s = "*"
				}
				if ( dbg_compare == 0 ) {
					cdata2(cnt, cnt2) = cdata(cnt, cnt2)
				}
				if ( dbg_compare == 1 ) {
					if ( cdata2(cnt, cnt2) != cdata(cnt, cnt2) ) {
						noteadd s + "" + cnt2 + "\t" + cnt + "\t" + cdata2(cnt, cnt2) + "\t->" + cdata(cnt, cnt2)
					}
				}
			loop
		loop
		noteadd "cdatan"
		repeat MAX_CHARA_TOTAL
			cnt2 = cnt
			repeat MAX_CDATAN
				s = ""
				if ( dbg_compare == 0 ) {
					cdatan2(cnt, cnt2) = cdatan(cnt, cnt2)
				}
				if ( dbg_compare == 1 ) {
					if ( cdatan2(cnt, cnt2) != cdatan(cnt, cnt2) ) {
						noteadd s + "" + cnt2 + "\t" + cnt + "\t" + cdatan2(cnt, cnt2) + "\t->" + cdatan(cnt, cnt2)
					}
				}
			loop
		loop
		noteadd "skill"
		repeat MAX_CHARA_TOTAL
			cnt2 = cnt
			repeat MAX_SKILL_DATA
				s = ""
				if ( dbg_compare == 0 ) {
					sdata2(cnt, cnt2) = sdata(cnt, cnt2)
				}
				if ( dbg_compare == 1 ) {
					if ( sdata2(cnt, cnt2) != sdata(cnt, cnt2) ) {
						noteadd s + "" + cnt2 + "\t" + cnt + "\t" + sdata2(cnt, cnt2) + "\t->" + sdata(cnt, cnt2)
					}
				}
			loop
		loop
		noteadd "inv"
		repeat MAX_INV_DATA
			cnt2 = cnt
			repeat INV_ITEM_MAX
				s = ""
				if ( dbg_compare == 0 ) {
					inv2(cnt, cnt2) = inv(cnt, cnt2)
				}
				if ( dbg_compare == 1 ) {
					if ( inv2(cnt, cnt2) != inv(cnt, cnt2) ) {
						noteadd s + "" + cnt2 + "\t" + cnt + "\t" + inv2(cnt, cnt2) + "\t->" + inv(cnt, cnt2)
					}
				}
			loop
		loop
		if ( dbg_compare == 0 ) {
			dbg_compare = 1
			noteadd "Var_comparison begins."
		}
		else {
			dbg_compare = 0
		}
		goto *console_write
	}
	if ( int(buff) == 5 ) {
		repeat 1000
			noteadd "" + cnt + "\t" + gdata(cnt)
		loop
		goto *console_write
	}
	if ( instr(buff, 0, "del") != (-1) | buff == "\n" ) {
		dbm = ""
		goto *console_write
	}
	if ( instr(buff, 0, "freemove") != (-1) ) {
		dbg_freemove = 1
		noteadd "Done."
		goto *console_write
	}
	if ( instr(buff, 0, "resetmap") != (-1) ) {
		gosub *mapReset
		noteadd "Done."
		goto *console_write
	}
	if ( instr(buff, 0, "exitroom") != (-1) ) {
		if ( gdata(GDATA_AREA) == AREA_SHOW_HOUSE ) {
			dbg_exitshowroom = 1
			noteadd "Done."
		}
		else {
			noteadd "Wrong map."
		}
		goto *console_write
	}
	if ( instr(buff, 0, "removequest") != (-1) ) {
		repeat gdata(GDATA_CLIENT)
			if ( qdata(QDATA_STATUS, cnt) != QUEST_STATE_NONE ) {
				if ( qdata(QDATA_DEADLINE, cnt) == (-1) ) {
					qdata(QDATA_STATUS, cnt) = QUEST_STATE_NONE
				}
			}
		loop
		noteadd "Done."
		goto *console_write
	}
	if ( instr(buff, 0, "fixmap") != (-1) ) {
		repeat MAX_CHARA_TOTAL
			if ( cdata(CDATA_EXIST, cnt) != CHAR_STATE_ALIVE ) {
				continue
			}
			if ( cdata(CDATA_X, cnt) < 0 | cdata(CDATA_X, cnt) >= mdata(MDATA_WIDTH) | cdata(CDATA_Y, cnt) < 0 | cdata(CDATA_Y, cnt) >= mdata(MDATA_HEIGHT) ) {
				cdata(CDATA_X, cnt) = 0
				cdata(CDATA_Y, cnt) = 0
			}
		loop
		repeat MAX_MAP_INV, RANGE_INV2
			if ( inv(INV_ITEM_NUM, cnt) <= 0 ) {
				continue
			}
			if ( inv(INV_ITEM_X, cnt) < 0 | inv(INV_ITEM_X, cnt) >= mdata(MDATA_WIDTH) | inv(INV_ITEM_Y, cnt) < 0 | inv(INV_ITEM_Y, cnt) >= mdata(MDATA_HEIGHT) ) {
				inv(INV_ITEM_X, cnt) = 0
				inv(INV_ITEM_Y, cnt) = 0
			}
		loop
		cell_refresh 0, 0
		noteadd "Done."
		goto *console_write
	}
	if ( instr(buff, 0, "advreset") != (-1) ) {
		repeat MAX_CHARA_ADVENTURER, MAX_CHARA_FOLLOWER
			rc = cnt
			inv_getheader rc
			repeat invrange, invhead
				cnt2 = cnt
				repeat INV_ITEM_MAX
					inv(cnt, cnt2) = 0
				loop
			loop
			repeat MAX_EQUIP_SLOT_TOTAL, CDATA_STARTING_EQUIP_SLOTS
				cdata(cnt, rc) = 0
			loop
		loop
		noteadd "Done."
		goto *console_write
	}
	if ( instr(buff, 0, "fixcorrupt1") != (-1) ) {
		repeat MAX_CHARA_SAVE
			rc = cnt
			inv_getheader rc
			repeat invrange, invhead
				cnt2 = cnt
				if ( inv(INV_ITEM_ID, cnt) >= MAX_DB | inv(INV_ITEM_ID, cnt) <= ITEM_ID_DUMMY | inv(INV_ITEM_NUM, cnt) <= 0 ) {
					repeat INV_ITEM_MAX
						inv(cnt, cnt2) = 0
					loop
				}
				if ( inv(INV_ITEM_EQUIP, cnt) != 0 ) {
					inv(INV_ITEM_EQUIP, cnt) = 0
				}
			loop
			repeat MAX_EQUIP_SLOT_TOTAL, CDATA_STARTING_EQUIP_SLOTS
				cdata(cnt, rc) = cdata(cnt, rc) / EXT_EQUIP_SLOTS * EXT_EQUIP_SLOTS
			loop
			if ( cnt >= MAX_CHARA_FOLLOWER ) {
				cdata(CDATA_EXIST, cnt) = CHAR_STATE_ADV_DEAD
				gosub *adv_generate
			}
		loop
		noteadd "Done."
		goto *console_write
	}
	if ( instr(buff, 0, "client") != (-1) ) {
		dim mapclient, 1000
		repeat QDATA_MAX_CLIENT
			if ( qdata(QDATA_CLIENT, cnt) == 0 ) {
				i = cnt
				continue
			}
			noteadd "id:" + cnt + " name:" + qname(cnt) + " map:" + mapname(qdata(QDATA_MAP, cnt))
			mapclient(qdata(QDATA_MAP, cnt))++
		loop
		repeat 1000
			if ( mapclient(cnt) != 0 ) {
				noteadd "" + mapname(cnt) + ":" + mapclient(cnt), 1
			}
		loop
		goto *console_write
	}
	if ( instr(buff, 0, "108fix") != (-1) ) {
		repeat MAX_CHARA_TOTAL
			if ( cnt < MAX_CHARA_SAVE ) {
				continue
			}
			if ( cdata(CDATA_EXIST, cnt) == CHAR_STATE_ALIVE ) {
				cdata(CDATA_RELATION, cnt) = -3
				cdata(CDATA_RELATION_ORG, cnt) = -3
			}
		loop
		noteadd "Done."
		goto *console_write
	}
	if ( instr(buff, 0, "test") != (-1) ) {
		repeat 500
			noteadd "" + cnt + ":" + mapname(cnt) + "/" + adata(ADATA_ID, cnt)
		loop
		noteadd "Done."
		goto *console_write
	}
	if ( instr(buff, 0, "mapinfo") != (-1) ) {
		noteadd "gArea\t\t:" + gdata(GDATA_AREA)
		noteadd "gLevel\t\t:" + gdata(GDATA_LEVEL)
		noteadd "file\t\t:" + "mdata_" + mid + ".s2"
		noteadd "pc x/y\t\t:" + cdata(CDATA_X, CHARA_PLAYER) + "/" + cdata(CDATA_Y, CHARA_PLAYER)
		noteadd "map max w/h\t:" + mdata(MDATA_WIDTH) + "/" + mdata(MDATA_HEIGHT)
		noteadd "Done."
		goto *console_write
	}
	if ( instr(buff, 0, "quest") != (-1) ) {
		noteadd "gQuest:" + gdata(GDATA_QUEST) + " gQuestRef:" + gdata(GDATA_QUEST_REF) + " gQuestStatus:" + gdata(GDATA_QUEST_STATUS) + " rq:" + rq
		repeat 5
			p = gdata(GDATA_QUEST_POOL + cnt)
			noteadd "quest" + cnt + " " + p + " exist" + qdata(QDATA_EXIST, p) + " status" + qdata(QDATA_STATUS, p) + " var" + qdata(QDATA_VAR, p) + " encount" + qdata(QDATA_ENCOUNTER, p)
		loop
		repeat gdata(GDATA_CLIENT)
			noteadd "" + cnt + " " + qdata(QDATA_CLIENT, cnt) + "/" + qdata(QDATA_MAP, cnt)
		loop
		goto *console_write
	}
	if ( instr(buff, 0, "wizard") != (-1) ) {
		gdata(GDATA_WIZARD) = 1
		cdatan(CDATAN_AKA, CHARA_PLAYER) = "*Debug*"
		noteadd "Wizard mode activated."
		goto *console_write
	}
	if ( gdata(GDATA_WIZARD) ) {

		/********** ANNA CUSTOM - BEGINNING **********/ // Spawn npc command

		if ( instr(buff, 0, "spawn") != (-1) ) {
			if ( instr(buff, 0, " ") != (-1) ) {
				characreate -1, int(strmid(buff, instr(buff, 0, " "), strlen(buff) - instr(buff, 0, " "))), cdata(CDATA_X, CHARA_PLAYER), cdata(CDATA_Y, CHARA_PLAYER)
				goto *console_write
			}
			else {
				noteadd "Must add a NPC ID e.g. spawn 2"
				goto *console_write
			}
		}

		/********** ANNA CUSTOM - ENDING **********/

		if ( instr(buff, 0, "gain_spell") != (-1) ) {
			repeat MAX_SPELL - STARTING_SKILL_SPELL, STARTING_SKILL_SPELL
				skillgain CHARA_PLAYER, cnt, cdata(CDATA_LEVEL, r1), 100 * 100
			loop
			noteadd "Done."
			goto *console_write
		}
		if ( instr(buff, 0, "gain_spact") != (-1) ) {
			repeat MAX_SKILL - STARTING_SKILL_SPACT
				spact(cnt + STARTING_SKILL_SPACT - STARTING_SKILL_SPACT) = 1
			loop
			noteadd "Done."
			goto *console_write
		}
		if ( instr(buff, 0, "allinv") != (-1) ) {
			repeat MAX_INV_DATA
				if ( cnt < RANGE_INV2 ) {
					if ( cnt >= SIZE_INV1 ) {
						if ( (cnt - SIZE_INV1) \ SIZE_INV2 == 0 ) {
							noteadd "-----------" + cdatan(CDATAN_NAME, (cnt - SIZE_INV1) / SIZE_INV2 + 1)
						}
					}
				}
				if ( cnt == RANGE_INV2 ) {
					noteadd "-----------------------MAP INV"
				}
				noteadd "" + cnt + "\t" + inv(INV_ITEM_NUM, cnt) + "\t" + itemname(cnt) + " it:" + inv(INV_ITEM_TURN, cnt)
			loop
			goto *console_write
		}
		if ( instr(buff, 0, "mapinv") != (-1) ) {
			repeat MAX_INV_DATA - RANGE_INV2
				if ( cnt == RANGE_INV2 ) {
					noteadd "-----------------------MAP INV"
				}
				if ( inv(INV_ITEM_NUM, cnt) != 0 ) {
					noteadd "" + cnt + "\t" + inv(INV_ITEM_NUM, cnt) + "\t" + itemname(cnt) + " it:" + inv(INV_ITEM_TURN, cnt)
				}
			loop
			goto *console_write
		}
		if ( instr(buff, 0, "gain_exp") != (-1) ) {
			cdata(CDATA_EXP, CHARA_PLAYER) += 1000000000
			r1 = CHARA_PLAYER
			r2 = 0
			gosub *calcLevelUp
			noteadd "Done."
			goto *console_write
		}
		if ( instr(buff, 0, "gain_fame") != (-1) ) {
			cdata(CDATA_FAME, CHARA_PLAYER) += 10000
			noteadd "Done."
			goto *console_write
		}
	}
	noteadd "Unknown command. Type \"?\" for help. Hit ESC to exit."
	goto *console_write

*console_write
	noteadd ""
	objprm 1, dbm
	objprm 2, ""
	return

*mutexobj
	CreateMutexA 0, 0, "ElonaPlus 1.90"
	mutex_handle = stat
	_GetLastError
	if ( stat == 183 ) {
		dialog lang("二重起動のため終了します。", "The program is already running."), 1
		end
	}
	return

